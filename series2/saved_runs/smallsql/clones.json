[{"content":"if(isNull()) return null;int dataType = getDataType();switch(dataType){case SQLTokenizer.BIT:case SQLTokenizer.BOOLEAN:return getBoolean() ? Boolean.TRUE : Boolean.FALSE;case SQLTokenizer.BINARY:case SQLTokenizer.VARBINARY:return getBytes();case SQLTokenizer.TINYINT:case SQLTokenizer.SMALLINT:case SQLTokenizer.INT:return new Integer( getInt() );case SQLTokenizer.BIGINT:return new Long( getLong() );case SQLTokenizer.REAL:return new Float( getFloat() );case SQLTokenizer.FLOAT:case SQLTokenizer.DOUBLE:return new Double( getDouble() );case SQLTokenizer.MONEY:case SQLTokenizer.SMALLMONEY:return Money.createFromUnscaledValue( getMoney() );case SQLTokenizer.NUMERIC:case SQLTokenizer.DECIMAL:return getNumeric();case SQLTokenizer.CHAR:case SQLTokenizer.NCHAR:case SQLTokenizer.VARCHAR:case SQLTokenizer.NVARCHAR:case SQLTokenizer.LONGNVARCHAR:case SQLTokenizer.LONGVARCHAR:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getObject()","rawLines":"Object getObject() throws java.lang.Exception {\r\n        if(isNull()) return null;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return getBytes();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n                    return new Integer( getInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long( getLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( getFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( getDouble() );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( getMoney() );\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return getNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            \t\treturn getString( left.getString(), right.getString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    Object lObj = left.getObject();\r\n                    //FIXME NullPointerException bei NEGATIVE\r\n                    Object rObj = right.getObject();\r\n                    if(lObj instanceof Number && rObj instanceof Number)\r\n                        return new Double( getDoubleImpl( ((Number)lObj).doubleValue(), ((Number)rObj).doubleValue() ) );\r\n                    else\r\n                        return getString( lObj.toString(), rObj.toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n                    return getBytes();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getLong(), dataType );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return getBytes();\r\n            default: throw createUnspportedDataType();\r\n        }\r\n    }","startLine":1,"lastLine":32},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1/getObject()","rawLines":"Object getObject() throws Exception{\r\n\t\tif(isNull()) return null;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n\t        case SQLTokenizer.BIT:\r\n\t        case SQLTokenizer.BOOLEAN:\r\n\t                return getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n\t        case SQLTokenizer.BINARY:\r\n\t        case SQLTokenizer.VARBINARY:\r\n\t                return getBytes();\r\n\t        case SQLTokenizer.TINYINT:\r\n\t        case SQLTokenizer.SMALLINT:\r\n\t        case SQLTokenizer.INT:\r\n\t                return new Integer( getInt() );\r\n\t        case SQLTokenizer.BIGINT:\r\n\t                return new Long( getLong() );\r\n\t        case SQLTokenizer.REAL:\r\n\t                return new Float( getFloat() );\r\n\t        case SQLTokenizer.FLOAT:\r\n\t        case SQLTokenizer.DOUBLE:\r\n\t                return new Double( getDouble() );\r\n\t        case SQLTokenizer.MONEY:\r\n\t        case SQLTokenizer.SMALLMONEY:\r\n\t                return Money.createFromUnscaledValue( getMoney() );\r\n\t        case SQLTokenizer.NUMERIC:\r\n\t        case SQLTokenizer.DECIMAL:\r\n\t                return getNumeric();\r\n\t        case SQLTokenizer.CHAR:\r\n\t        case SQLTokenizer.NCHAR:\r\n\t        case SQLTokenizer.VARCHAR:\r\n\t        case SQLTokenizer.NVARCHAR:\r\n\t        case SQLTokenizer.LONGNVARCHAR:\r\n\t        case SQLTokenizer.LONGVARCHAR:\r\n\t        \t\treturn getString();\r\n\t        case SQLTokenizer.LONGVARBINARY:\r\n\t                return getBytes();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getLong(), dataType );\r\n\t        case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t                return getBytes();\r\n\t        default: throw createUnspportedDataType(param1.getDataType());\r\n\t    }\r\n    }","startLine":1,"lastLine":32}],"window":32},{"content":"offset += 2;break;case SQLTokenizer.INT:case SQLTokenizer.REAL:case SQLTokenizer.SMALLMONEY:case SQLTokenizer.TIME:case SQLTokenizer.DATE:case SQLTokenizer.SMALLDATETIME:offset += 4;break;case SQLTokenizer.BIGINT:case SQLTokenizer.FLOAT:case SQLTokenizer.DOUBLE:case SQLTokenizer.MONEY:case SQLTokenizer.JAVA_OBJECT:case SQLTokenizer.LONGVARBINARY:case SQLTokenizer.BLOB:case SQLTokenizer.CLOB:case SQLTokenizer.NCLOB:case SQLTokenizer.LONGNVARCHAR:case SQLTokenizer.LONGVARCHAR:case SQLTokenizer.TIMESTAMP:offset += 8;break;","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/scanObjectOffsets(int%5B%5D,int%5B%5D)","rawLines":"@Override\r\n    void scanObjectOffsets( int[] offsets, int dataTypes[] ){\r\n        offset = PAGE_CONTROL_SIZE;\r\n        for(int i=0; i<offsets.length; i++){\r\n            offsets[i] = offset;\r\n            boolean isNull = readBoolean(); // for isNull\r\n            switch(dataTypes[i]){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                    int count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count;  // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    count = readByte();\r\n\t\t\t\t\toffset += 2;\r\n\t\t\t\t\tif(!isNull) offset += count*4;\r\n                    break;\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count << 1; // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                default: throw new Error(String.valueOf( dataTypes[i] ) );\r\n            }\r\n        }\r\n    }","startLine":13,"lastLine":36},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":29,"lastLine":52}],"window":24},{"content":"pr.setObject( 1, testValue.small);pr.setObject( 2, testValue.large);pr.execute();pr.setObject( 1, testValue.small);pr.setObject( 2, testValue.small);pr.execute();pr.setObject( 1, testValue.large);pr.setObject( 2, testValue.large);pr.execute();pr.setObject( 1, testValue.large);pr.setObject( 2, testValue.small);pr.execute();pr.setObject( 1, null);pr.setObject( 2, testValue.small);pr.execute();pr.setObject( 1, testValue.small);pr.setObject( 2, null);pr.execute();pr.setObject( 1, null);pr.setObject( 2, null);pr.execute();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOperatoren/setUp()","rawLines":"public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(a \" + testValue.dataType +\", b \" + testValue.dataType + \")\");\r\n            st.close();\r\n            PreparedStatement pr = con.prepareStatement(\"INSERT into \" + table + \"(a,b) Values(?,?)\");\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n            pr.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }","startLine":9,"lastLine":35},{"locFile":"java+method:///smallsql/junit/TestJoins/insertValues(java.sql.PreparedStatement)","rawLines":"private void insertValues(PreparedStatement pr ) throws Exception{\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n    }","startLine":1,"lastLine":27}],"window":21},{"content":"}catch(Throwable ex){throwable = ex;}}});threadList.add(thread);thread.start();}for(int i = 0; i < threadList.size(); i++){Thread thread = (Thread)threadList.get(i);thread.join(5000);}if(throwable != null){throw throwable;}assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");}finally{dropTable(con, \"ConcurrentWrite\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentThreadWrite()","rawLines":"/**\r\n     * Create a table with a single row. In different threads on the same connection a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentThreadWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Statement st2 = con.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }","startLine":24,"lastLine":49},{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentConnectionWrite()","rawLines":"/**\r\n     * Create a table with a single row. In different connections a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentConnectionWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Connection con2 = AllTests.createConnection();\r\n                            Statement st2 = con2.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                            con2.close();\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }","startLine":26,"lastLine":51}],"window":20},{"content":"if(isNull()) return 0;int dataType = getDataType();switch(dataType){case SQLTokenizer.BIT:case SQLTokenizer.BOOLEAN:return getBoolean() ? 1 : 0;case SQLTokenizer.TINYINT:case SQLTokenizer.SMALLINT:case SQLTokenizer.INT:return getIntImpl();case SQLTokenizer.BIGINT:return getLongImpl();case SQLTokenizer.REAL:return getFloatImpl();case SQLTokenizer.FLOAT:case SQLTokenizer.DOUBLE:case SQLTokenizer.MONEY:case SQLTokenizer.SMALLMONEY:case SQLTokenizer.NUMERIC:case SQLTokenizer.DECIMAL:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getDouble()","rawLines":"double getDouble() throws java.lang.Exception {\r\n        if(isNull()) return 0;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return getDoubleImpl();\r\n        }\r\n\t\tthrow createUnspportedConversion( SQLTokenizer.DOUBLE);\r\n    }","startLine":1,"lastLine":20},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getFloat()","rawLines":"float getFloat() throws java.lang.Exception {\r\n        if(isNull()) return 0;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return (float)getDoubleImpl();\r\n        }\r\n\t\tthrow createUnspportedConversion( SQLTokenizer.DOUBLE);\r\n    }","startLine":1,"lastLine":20}],"window":20},{"content":"assertEquals(\"getRow\", 1, rs.getRow() );assertTrue(\"isLast\", rs.isLast() );assertFalse(\"next\", rs.next() );assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );assertTrue(\"isAfterLast\", rs.isAfterLast() );assertEquals(\"getRow\", 0, rs.getRow() );assertTrue(\"first\", rs.first() );assertEquals(\"getRow\", 1, rs.getRow() );assertFalse(\"previous\", rs.previous() );assertEquals(\"getRow\", 0, rs.getRow() );assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );assertFalse(\"isAfterLast\", rs.isAfterLast() );assertTrue(\"last\", rs.last() );assertEquals(\"getRow\", 1, rs.getRow() );assertTrue(\"isLast\", rs.isLast() );rs.afterLast();assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );assertTrue(\"isAfterLast\", rs.isAfterLast() );assertEquals(\"getRow\", 0, rs.getRow() );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestResultSet/testScrollStates()","rawLines":"public void testScrollStates() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs = st.executeQuery(\"Select * From ResultSet Where 1=0\");\r\n        \r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        \r\n        rs.moveToInsertRow();\r\n        rs.insertRow();\r\n        \r\n        rs.beforeFirst();\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        assertTrue(\"next\", rs.next() );\r\n        assertTrue(\"isFirst\", rs.isFirst() );\r\n        assertTrue(\"rowInserted\", rs.rowInserted() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        assertTrue(\"isLast\", rs.isLast() );\r\n        assertFalse(\"next\", rs.next() );\r\n        assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        \r\n        assertTrue(\"first\", rs.first() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        \r\n        assertFalse(\"previous\", rs.previous() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        \r\n        assertTrue(\"last\", rs.last() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        assertTrue(\"isLast\", rs.isLast() );\r\n        \r\n        rs.afterLast();\r\n        assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n    }","startLine":19,"lastLine":42},{"locFile":"java+method:///smallsql/junit/TestResultSet/testScrollStatesGroupBy()","rawLines":"public void testScrollStatesGroupBy() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs = st.executeQuery(\"Select i,max(c) From ResultSet Group By i HAVING i=1\");\r\n        \r\n        assertEquals(\"getConcurrency\",ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        \r\n        rs.beforeFirst();\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        assertTrue(\"next\", rs.next() );\r\n        assertTrue(\"isFirst\", rs.isFirst() );\r\n        assertFalse(\"rowInserted\", rs.rowInserted() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        assertTrue(\"isLast\", rs.isLast() );\r\n        assertFalse(\"next\", rs.next() );\r\n        assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        \r\n        assertTrue(\"first\", rs.first() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        \r\n        assertFalse(\"previous\", rs.previous() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        \r\n        assertTrue(\"last\", rs.last() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        assertTrue(\"isLast\", rs.isLast() );\r\n        \r\n        rs.afterLast();\r\n        assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n    }","startLine":17,"lastLine":40}],"window":20},{"content":"final double getDouble() throws Exception{if(isNull()) return 0;final int places = param2.getInt();double value = param1.getDouble();long factor = 1;if(places > 0){for(int i=0; i<places; i++){factor *= 10;}value *= factor;}else{for(int i=0; i>places; i--){factor *= 10;}value /= factor;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionRound/getDouble()","rawLines":"final double getDouble() throws Exception{\r\n\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}\r\n\t\tvalue = Math.rint( value );\r\n\t\tif(places > 0){\r\n\t\t\tvalue /= factor;\r\n\t\t}else{\r\n\t\t\tvalue *= factor;\r\n\t\t}\r\n\t\treturn value;\r\n    }","startLine":0,"lastLine":15},{"locFile":"java+method:///smallsql/database/ExpressionFunctionTruncate/getDouble()","rawLines":"final double getDouble() throws Exception{\r\n\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}\r\n        value -= value % 1; //modulo also work with values larger long\r\n\t\tif(places > 0){\r\n\t\t\tvalue /= factor;\r\n\t\t}else{\r\n\t\t\tvalue *= factor;\r\n\t\t}\r\n\t\treturn value;\r\n    }","startLine":0,"lastLine":15}],"window":16},{"content":"rs.next();rs.next();rs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehenrs.last();count = 0;while(rs.previous()) count++;assertEquals( valueCount, count );rs.beforeFirst();count = -1;while(rs.next()) count++;assertEquals( valueCount, count );rs.beforeFirst();count = -1;while(rs.next()) count++;assertEquals( valueCount, count );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_ScollableDesc()","rawLines":"public void testOrderBy_ScollableDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i desc, d\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":10,"lastLine":28},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_Scollable()","rawLines":"public void testOrderBy_Scollable() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":10,"lastLine":28}],"window":16},{"content":"assertTrue( rs.next() );oldValue = rs.getString(\"v\");int count = 1;while(oldValue != null && rs.next()){String newValue = rs.getString(\"v\");if(newValue != null){assertTrue( oldValue.compareTo( newValue ) > 0 );count++;}oldValue = newValue;}assertNull(oldValue);assertFalse( rs.next() );assertEquals( valueCount, count );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_desc()","rawLines":"public void testOrderBy_varchar_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":9,"lastLine":25},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_DescAsc()","rawLines":"public void testOrderBy_varchar_DescAsc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc, i asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":9,"lastLine":25}],"window":15},{"content":"rs.next();int count = rs.getInt(1);if (count != rowCount)System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");else System.out.println( \"  Test time: \" + time + \" ms\");st.close();}catch(Exception e){System.out.println(\"  Failed:\"+e);}finally{System.out.println();System.out.println(\"===================================================================\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertEmptyRows(java.sql.Connection)","rawLines":"/**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":18,"lastLine":30},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertClassic(java.sql.Connection)","rawLines":"/**\r\n      *  1. Test\r\n      *  Insert rows with default values with a classic insert statement.\r\n      */  \r\n    static void test_InsertClassic(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with default values with a classic insert statement: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                st.execute(\"INSERT INTO \" + tableName + \"(i) VALUES(\" + i +\")\");\r\n            }\r\n            time += System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":16,"lastLine":28}],"window":13},{"content":"case SQLTokenizer.CHAR:case SQLTokenizer.NCHAR:case SQLTokenizer.VARCHAR:case SQLTokenizer.NVARCHAR:return readString();case SQLTokenizer.CLOB:case SQLTokenizer.NCLOB:case SQLTokenizer.LONGNVARCHAR:case SQLTokenizer.LONGVARCHAR:return readLongString();case SQLTokenizer.JAVA_OBJECT:ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());ObjectInputStream ois = new ObjectInputStream(bais);","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getObject(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getObject()\r\n     */\r\n    @Override\r\n    Object getObject(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n                    return Utils.getInteger( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return Utils.getInteger( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return Utils.getInteger(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue(readLong());\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME );\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE );\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":34,"lastLine":46},{"locFile":"java+method:///smallsql/database/StoreImpl/getString(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getString()\r\n     */\r\n    @Override\r\n    String getString( int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                    return readBoolean() ? \"1\" : \"0\";\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return String.valueOf( readBoolean() );\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2hex( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return String.valueOf( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return String.valueOf( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return String.valueOf( readInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return String.valueOf( readLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return String.valueOf( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return String.valueOf( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue( readLong() ).toString();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( readInt() ).toString();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toString();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject().toString();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2hex( readLongBinary() );\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME ).toString();\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE ).toString();\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":35,"lastLine":47}],"window":13},{"content":"return;}}time += System.currentTimeMillis();System.out.println( \"  Test time: \" + time + \" ms\");pr.close();}catch(Exception e){System.out.println(\"  Failed:\"+e);}finally{System.out.println();System.out.println(\"===================================================================\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepare(java.sql.Connection)","rawLines":"/**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":33,"lastLine":45},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepareBatch(java.sql.Connection)","rawLines":"/**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":39,"lastLine":51}],"window":13},{"content":"try{Statement st1 = con.createStatement();ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);rs.next();int count = rs.getInt(1);if (count != rowCount){if (count == 0){createTestDataWithClassicInsert( con );rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);rs.next();count = rs.getInt(1);}if (count != rowCount){","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteRows(java.sql.Connection)","rawLines":"/**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":8,"lastLine":21},{"locFile":"java+method:///smallsql/junit/BenchTest/test_RowRequestPages(java.sql.Connection)","rawLines":"/**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":9,"lastLine":22}],"window":13},{"content":"pr.close();time += System.currentTimeMillis();System.out.println( \"  Test time: \" + time + \" ms\");fis.close();java.io.File file = new java.io.File(tableName+\".bin\");file.delete();}catch(Exception e){System.out.println(\"  Failed:\"+e);}finally{System.out.println();System.out.println(\"===================================================================\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateLargeBinary(java.sql.Connection)","rawLines":"/**\r\n      *  12. Test\r\n      *  Update large binary data.\r\n      */  \r\n    static void test_UpdateLargeBinary(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            PreparedStatement pr = con.prepareStatement(\"Update \" + tableName + \" set im=? WHERE pr=1\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":20,"lastLine":32},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateLargeBinaryWithSP(java.sql.Connection)","rawLines":"/**\r\n      *  12. Test\r\n      *  Update large binary data with a SP.\r\n      */  \r\n    static void test_UpdateLargeBinaryWithSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data with a SP: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"CREATE PROCEDURE #UpdateLargeBinary(@im image) as Update \" + tableName + \" set im=@im WHERE pr=2\");\r\n            PreparedStatement pr = con.prepareStatement(\"exec #UpdateLargeBinary ?\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            st.execute(\"DROP PROCEDURE #UpdateLargeBinary\");\r\n            st.close();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":24,"lastLine":36}],"window":13},{"content":"assertTrue( rs.next() );oldValue = (Integer)rs.getObject(\"i\");assertNull(oldValue);assertTrue( rs.next() );oldValue = (Integer)rs.getObject(\"i\");int count = 1;while(rs.next()){assertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );oldValue = (Integer)rs.getObject(\"i\");count++;}assertEquals( valueCount, count );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_int_asc()","rawLines":"public void testOrderBy_int_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":9,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_int()","rawLines":"public void testOrderBy_int() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":9,"lastLine":23}],"window":13},{"content":"pr.setDouble(  8 , 23.45 );pr.setDouble(  9 , 567.45 );pr.setFloat (  10 , (float)78.89 );pr.setTime  (  11, new Time( System.currentTimeMillis() ) );pr.setShort (  12, (short)23456 );pr.setFloat (  13, (float)34.56 );pr.setString(  14, \"sysname (30) NULL\" );pr.setString(  15 , \"text NULL\" );pr.setByte  (  16, (byte)28 );pr.setBytes (  17, byteArray );pr.setString(  18, \"varchar (255) NULL\" );pr.setInt   (  19 , i );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepareBatch(java.sql.Connection)","rawLines":"/**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":22,"lastLine":33},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepare(java.sql.Connection)","rawLines":"/**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":18,"lastLine":29}],"window":12},{"content":"if(failed == null){failed = new BatchUpdateException(ex.getMessage(), ex.getSQLState(), ex.getErrorCode(), result);failed.initCause(ex);}failed.setNextException(ex);}}batches.clear();if(failed != null)throw failed;return result;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSPreparedStatement/executeBatch()","rawLines":"public int[] executeBatch() throws BatchUpdateException {\r\n\t\tif(batches == null || batches.size() == 0) return new int[0];\r\n\t\tint[] result = new int[batches.size()];\r\n\t\tBatchUpdateException failed = null;\r\n\t\tfor(int b=0; b<batches.size(); b++){\r\n\t\t\ttry{\r\n                checkStatement();\r\n\t\t\t\tExpressionValue[] values = (ExpressionValue[])batches.get(b);\r\n\t\t\t\tfor(int i=0; i<values.length; i++){\r\n\t\t\t\t\t((ExpressionValue)cmd.params.get(i)).set( values[i] );\r\n\t\t\t\t}\r\n\t\t\t\tresult[b] = executeUpdate();\r\n\t\t\t} catch (SQLException ex) {\r\n\t\t\t\tresult[b] = EXECUTE_FAILED;\r\n\t\t\t\tif(failed == null){\r\n\t\t\t\t\tfailed = new BatchUpdateException(ex.getMessage(), ex.getSQLState(), ex.getErrorCode(), result);\r\n\t\t\t\t\tfailed.initCause(ex);\r\n\t\t\t\t}\r\n\t\t\t\tfailed.setNextException(ex);\r\n\t\t\t}\r\n\t\t}\r\n    \tbatches.clear();\r\n    \tif(failed != null)\r\n    \t\tthrow failed;\r\n    \treturn result;\r\n\t}","startLine":14,"lastLine":25},{"locFile":"java+method:///smallsql/database/SSStatement/executeBatch()","rawLines":"public int[] executeBatch() throws BatchUpdateException{\r\n        if(batches == null)\r\n            return new int[0];\r\n        final int[] result = new int[batches.size()];\r\n        BatchUpdateException failed = null;\r\n        for(int i = 0; i < result.length; i++){\r\n            try{\r\n                result[i] = executeUpdate((String)batches.get(i));\r\n            }catch(SQLException ex){\r\n                result[i] = EXECUTE_FAILED;\r\n                if(failed == null){\r\n                    failed = new BatchUpdateException(ex.getMessage(), ex.getSQLState(), ex.getErrorCode(), result);\r\n                    failed.initCause(ex);\r\n                }\r\n                failed.setNextException(ex);\r\n            }\r\n        }\r\n        batches.clear();\r\n        if(failed != null)\r\n            throw failed;\r\n        return result;\r\n    }","startLine":10,"lastLine":21}],"window":12},{"content":"buf.append(' ');formatNumber( details.year, 4, buf);buf.append(' ');formatHour12( details.hour, buf );buf.append(':');formatNumber( details.minute, 2, buf);buf.append(':');formatNumber( details.second, 2, buf);buf.append(':');formatMillis( details.millis, buf);buf.append( details.hour < 12 ? \"AM\" : \"PM\" );return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":135,"lastLine":146},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":261,"lastLine":272}],"window":12},{"content":"case SQLTokenizer.TINYINT:return readUnsignedByte();case SQLTokenizer.SMALLINT:return readShort();case SQLTokenizer.INT:return readInt();case SQLTokenizer.BIGINT:return readLong();case SQLTokenizer.REAL:return readFloat();case SQLTokenizer.FLOAT:case SQLTokenizer.DOUBLE:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getDouble(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getDouble()\r\n     */\r\n    @Override\r\n    double getDouble(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2double( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().doubleValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Double.parseDouble( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Double.parseDouble( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Double.parseDouble( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2double( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n        }\r\n    }","startLine":14,"lastLine":25},{"locFile":"java+method:///smallsql/database/StoreImpl/getFloat(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getFloat()\r\n     */\r\n    @Override\r\n    float getFloat(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2float( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (float)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / (float)10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / (float)10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().floatValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Float.parseFloat( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Float.parseFloat( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Float.parseFloat( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2float( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"REAL\" });\r\n        }\r\n    }","startLine":14,"lastLine":25}],"window":12},{"content":"if(idx == -1){if(status.nodeValue != null){if(status.nodeValue instanceof IndexNode){level++;nodeStack.push(new IndexNodeScrollStatus( \t(IndexNode)status.nodeValue,(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR),scroll, level));continue;}elsereturn getReturnValue(status.nodeValue);}","cloneLocs":[{"locFile":"java+method:///smallsql/database/IndexScrollStatus/getRowOffset(boolean)","rawLines":"/**\r\n\t * Return the next rowOffset of this index. You need to call reset() before the first use. \r\n\t * @param next if true the next rowOffset else the previous rowOffset\r\n\t */\r\n\tfinal long getRowOffset( boolean scroll){\r\n\t\tif(longList != null){\r\n\t\t\tlong rowOffset = scroll ? \r\n\t\t\t\t\t\t\t\tlongList.getNext(longListEnum) : \r\n\t\t\t\t\t\t\t\tlongList.getPrevious(longListEnum);\r\n\t\t\tif(rowOffset < 0){\r\n\t\t\t\t// No more entries on this node\r\n\t\t\t\tlongList = null;\r\n\t\t\t}else{\r\n\t\t\t\treturn rowOffset;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\tIndexNodeScrollStatus status = (IndexNodeScrollStatus)nodeStack.peek();\r\n\t\t\tint level = status.level;\r\n\t\t\tif(!status.asc ^ scroll){\r\n\t\t\t\t//ASC order\r\n\t\t\t\tint idx = ++status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t\tidx = ++status.idx;\r\n\t\t\t\t}\r\n\t\t\t\tif(idx >= status.nodes.length){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n                        status.idx = status.nodes.length; //to prevent problems with scroll back after multiple calls after the end.\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}else{\r\n\t\t\t\t//DESC order\r\n\t\t\t\tint idx = --status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t}\r\n\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":22,"lastLine":33},{"locFile":"java+method:///smallsql/database/IndexScrollStatus/getRowOffset(boolean)","rawLines":"/**\r\n\t * Return the next rowOffset of this index. You need to call reset() before the first use. \r\n\t * @param next if true the next rowOffset else the previous rowOffset\r\n\t */\r\n\tfinal long getRowOffset( boolean scroll){\r\n\t\tif(longList != null){\r\n\t\t\tlong rowOffset = scroll ? \r\n\t\t\t\t\t\t\t\tlongList.getNext(longListEnum) : \r\n\t\t\t\t\t\t\t\tlongList.getPrevious(longListEnum);\r\n\t\t\tif(rowOffset < 0){\r\n\t\t\t\t// No more entries on this node\r\n\t\t\t\tlongList = null;\r\n\t\t\t}else{\r\n\t\t\t\treturn rowOffset;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\tIndexNodeScrollStatus status = (IndexNodeScrollStatus)nodeStack.peek();\r\n\t\t\tint level = status.level;\r\n\t\t\tif(!status.asc ^ scroll){\r\n\t\t\t\t//ASC order\r\n\t\t\t\tint idx = ++status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t\tidx = ++status.idx;\r\n\t\t\t\t}\r\n\t\t\t\tif(idx >= status.nodes.length){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n                        status.idx = status.nodes.length; //to prevent problems with scroll back after multiple calls after the end.\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}else{\r\n\t\t\t\t//DESC order\r\n\t\t\t\tint idx = --status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t}\r\n\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":53,"lastLine":64}],"window":12},{"content":"}time += System.currentTimeMillis();System.out.println( \"  Test time: \" + time + \" ms\");st.close();}catch(Exception e){System.out.println(\"  Failed:\"+e);}finally{System.out.println();System.out.println(\"===================================================================\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_RowRequestPages(java.sql.Connection)","rawLines":"/**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":47,"lastLine":57},{"locFile":"java+method:///smallsql/junit/BenchTest/test_Scroll_getXXX(java.sql.Connection)","rawLines":"/**\r\n      *  11. Test\r\n      *  Scroll and call the getXXX methods for every columns.\r\n      */  \r\n    static void test_Scroll_getXXX(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test scroll and call the getXXX methods for every columns: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            long time = -System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            for (int i=0; i<rowCount; i++){\r\n                    rs.next();\r\n\t                rs.getInt   (  1 );\r\n\t                rs.getBytes (  2 );\r\n\t                rs.getString(  3 );\r\n\t                rs.getDate  (  4 );\r\n\t                rs.getFloat (  5 );\r\n\t                rs.getFloat (  6 );\r\n\t                rs.getBytes (  7 );\r\n\t                rs.getInt   (  8 );\r\n\t                rs.getDouble(  9 );\r\n\t                rs.getDouble(  10 );\r\n\t                rs.getFloat (  11 );\r\n\t                rs.getTime  (  12 );\r\n\t                rs.getShort (  13 );\r\n\t                rs.getFloat (  14 );\r\n\t                rs.getString(  15 );\r\n\t                rs.getString(  16 );\r\n\t                rs.getByte  (  17 );\r\n\t                rs.getBytes (  18 );\r\n\t                rs.getString(  19 );\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":33,"lastLine":43}],"window":11},{"content":"formatNumber( details.year, 4, buf);buf.append('-');formatNumber( details.month+1, 2, buf);buf.append('-');formatNumber( details.day, 2, buf);buf.append(' ');formatNumber( details.hour, 2, buf);buf.append(':');formatNumber( details.minute, 2, buf);buf.append(':');formatNumber( details.second, 2, buf);","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":213,"lastLine":223},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":227,"lastLine":237}],"window":11},{"content":"}if(serializeConnections.size() > 0){Iterator values = locks.values().iterator();while(values.hasNext()){TableStorePage lock = (TableStorePage)values.next();if(lock.con != con) return null;}}tabLockConnection = con;tabLockCount++;TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);","cloneLocs":[{"locFile":"java+method:///smallsql/database/Table/requestLockImpl(smallsql.database.SSConnection,int,long)","rawLines":"/**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * In the other case it return null.\r\n     * @param page The fileOffset or -1 for a new page\r\n     * @throws SQLException \r\n     */\r\n\tfinal private TableStorePage requestLockImpl(SSConnection con, int pageOperation, long page) throws SQLException{\r\n\t\tsynchronized(locks){\r\n\t\t\tif(tabLockConnection != null && tabLockConnection != con) return null;\r\n\t\t\tswitch(con.isolationLevel){\r\n\t\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\t\tserializeConnections.put( con, con);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tswitch(pageOperation){\r\n\t\t\t\tcase SQLTokenizer.CREATE:{\r\n\t\t\t\t\t\t// first check if another connection has a lock before creating a table lock\r\n\t\t\t\t\t\tif(locks.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\t//the first StorePage in the linked list must be ever TableStorePageInsert\r\n\t\t\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttabLockConnection = con;\r\n\t\t\t\t\t\ttabLockCount++;\r\n\t\t\t\t\t\tTableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n                case SQLTokenizer.ALTER:{\r\n                    // first check if there is any lock before creating a table lock\r\n                    if(locks.size() > 0 || locksInsert.size() > 0){\r\n                        return null;\r\n                    }\r\n                    if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }\r\n                    tabLockConnection = con;\r\n                    tabLockCount++;\r\n                    TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n                    lock.rollback();\r\n                    return lock;\r\n                }\r\n\t\t\t\tcase SQLTokenizer.INSERT:{\r\n\t\t\t\t\t\t// if there are more as one Connection with a serializable lock then an INSERT is not valid\r\n\t\t\t\t\t\tif(serializeConnections.size() > 1) return null;\r\n\t\t\t\t\t\tif(serializeConnections.size() == 1 && serializeConnections.get(con) == null) return null;\r\n\t\t\t\t\t\tTableStorePageInsert lock = new TableStorePageInsert(con, this, LOCK_INSERT);\r\n\t\t\t\t\t\tlocksInsert.add( lock );\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.SELECT:\r\n\t\t\t\tcase SQLTokenizer.UPDATE:{\r\n\t\t\t\t\t\tLong pageKey = new Long(page); //TODO performance\r\n\t\t\t\t\t\tTableStorePage prevLock = null;\r\n\t\t\t\t\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tTableStorePage usableLock = null;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock.con == con || \r\n\t\t\t\t\t\t\t   con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\t\t\t\t    usableLock = lock;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t    if(lock.lockType == LOCK_WRITE){\r\n\t\t\t\t\t\t\t        return null; // write lock of another Connection\r\n\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprevLock = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(usableLock != null){\r\n\t\t\t\t\t\t    return usableLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlock = new TableStorePage( con, this, LOCK_NONE, page);\r\n\t\t\t\t\t\tif(con.isolationLevel >= Connection.TRANSACTION_REPEATABLE_READ || pageOperation == SQLTokenizer.UPDATE){\r\n\t\t\t\t\t\t\tlock.lockType = pageOperation == SQLTokenizer.UPDATE ? LOCK_WRITE : LOCK_READ;\r\n\t\t\t\t\t\t\tif(prevLock != null){\r\n\t\t\t\t\t\t\t    prevLock.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t    locks.put( pageKey, lock );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lock;\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t// is used for written BLOB and CLOB\r\n\t\t\t\t\t// the difference to INSERT is that page described the size of the byte buffer\r\n\t\t\t\t\treturn new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"pageOperation:\"+pageOperation);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":29,"lastLine":39},{"locFile":"java+method:///smallsql/database/Table/requestLockImpl(smallsql.database.SSConnection,int,long)","rawLines":"/**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * In the other case it return null.\r\n     * @param page The fileOffset or -1 for a new page\r\n     * @throws SQLException \r\n     */\r\n\tfinal private TableStorePage requestLockImpl(SSConnection con, int pageOperation, long page) throws SQLException{\r\n\t\tsynchronized(locks){\r\n\t\t\tif(tabLockConnection != null && tabLockConnection != con) return null;\r\n\t\t\tswitch(con.isolationLevel){\r\n\t\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\t\tserializeConnections.put( con, con);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tswitch(pageOperation){\r\n\t\t\t\tcase SQLTokenizer.CREATE:{\r\n\t\t\t\t\t\t// first check if another connection has a lock before creating a table lock\r\n\t\t\t\t\t\tif(locks.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\t//the first StorePage in the linked list must be ever TableStorePageInsert\r\n\t\t\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttabLockConnection = con;\r\n\t\t\t\t\t\ttabLockCount++;\r\n\t\t\t\t\t\tTableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n                case SQLTokenizer.ALTER:{\r\n                    // first check if there is any lock before creating a table lock\r\n                    if(locks.size() > 0 || locksInsert.size() > 0){\r\n                        return null;\r\n                    }\r\n                    if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }\r\n                    tabLockConnection = con;\r\n                    tabLockCount++;\r\n                    TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n                    lock.rollback();\r\n                    return lock;\r\n                }\r\n\t\t\t\tcase SQLTokenizer.INSERT:{\r\n\t\t\t\t\t\t// if there are more as one Connection with a serializable lock then an INSERT is not valid\r\n\t\t\t\t\t\tif(serializeConnections.size() > 1) return null;\r\n\t\t\t\t\t\tif(serializeConnections.size() == 1 && serializeConnections.get(con) == null) return null;\r\n\t\t\t\t\t\tTableStorePageInsert lock = new TableStorePageInsert(con, this, LOCK_INSERT);\r\n\t\t\t\t\t\tlocksInsert.add( lock );\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.SELECT:\r\n\t\t\t\tcase SQLTokenizer.UPDATE:{\r\n\t\t\t\t\t\tLong pageKey = new Long(page); //TODO performance\r\n\t\t\t\t\t\tTableStorePage prevLock = null;\r\n\t\t\t\t\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tTableStorePage usableLock = null;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock.con == con || \r\n\t\t\t\t\t\t\t   con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\t\t\t\t    usableLock = lock;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t    if(lock.lockType == LOCK_WRITE){\r\n\t\t\t\t\t\t\t        return null; // write lock of another Connection\r\n\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprevLock = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(usableLock != null){\r\n\t\t\t\t\t\t    return usableLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlock = new TableStorePage( con, this, LOCK_NONE, page);\r\n\t\t\t\t\t\tif(con.isolationLevel >= Connection.TRANSACTION_REPEATABLE_READ || pageOperation == SQLTokenizer.UPDATE){\r\n\t\t\t\t\t\t\tlock.lockType = pageOperation == SQLTokenizer.UPDATE ? LOCK_WRITE : LOCK_READ;\r\n\t\t\t\t\t\t\tif(prevLock != null){\r\n\t\t\t\t\t\t\t    prevLock.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t    locks.put( pageKey, lock );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lock;\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t// is used for written BLOB and CLOB\r\n\t\t\t\t\t// the difference to INSERT is that page described the size of the byte buffer\r\n\t\t\t\t\treturn new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"pageOperation:\"+pageOperation);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":47,"lastLine":57}],"window":11},{"content":"if(newValue != null){assertTrue( oldValue.compareTo( newValue ) > 0 );count++;}oldValue = newValue;}assertNull(oldValue);assertFalse( rs.next() );assertEquals( valueCount, count );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_desc()","rawLines":"public void testOrderBy_varchar_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":15,"lastLine":25},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_DescAsc()","rawLines":"public void testOrderBy_varchar_DescAsc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc, i asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":15,"lastLine":25},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_int_desc()","rawLines":"public void testOrderBy_int_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tInteger newValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":15,"lastLine":24}],"window":10},{"content":"}catch(Throwable e){if(raFile != null)try{raFile.close();}catch(Exception e2){DriverManager.println(e2.toString());}throw SmallSQLException.createFromException(e);}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/TableView/load(smallsql.database.SSConnection,smallsql.database.Database,java.lang.String)","rawLines":"/**\r\n\t * Load a Table or View object. \r\n\t */\r\n\tstatic TableView load(SSConnection con, Database database, String name) throws SQLException{\r\n\t    FileChannel raFile = null;\r\n\t\ttry{\r\n\t\t\tString fileName = Utils.createTableViewFileName( database, name );\r\n\t\t\tFile file = new File( fileName );\r\n\t\t\tif(!file.exists())\r\n\t\t\t\tthrow SmallSQLException.create(Language.TABLE_OR_VIEW_MISSING, name);\r\n\t\t\traFile = Utils.openRaFile( file, database.isReadOnly() );\r\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(8);\r\n\t\t\traFile.read(buffer);\r\n\t\t\tbuffer.position(0);\r\n\t\t\tint magic   = buffer.getInt();\r\n\t\t\tint version = buffer.getInt();\r\n\t\t\tswitch(magic){\r\n\t\t\t\tcase MAGIC_TABLE:\r\n\t\t\t\tcase MAGIC_VIEW:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.TABLE_OR_VIEW_FILE_INVALID, fileName);\r\n\t\t\t}\r\n\t\t\tif(version > TABLE_VIEW_VERSION)\r\n\t\t\t\tthrow SmallSQLException.create(Language.FILE_TOONEW, new Object[] { new Integer(version), fileName });\r\n\t\t\tif(version < TABLE_VIEW_OLD_VERSION)\r\n\t\t\t\tthrow SmallSQLException.create(Language.FILE_TOOOLD, new Object[] { new Integer(version), fileName });\r\n\t\t\tif(magic == MAGIC_TABLE)\r\n\t\t\t\treturn new Table( database, con, name, raFile, raFile.position(), version);\r\n\t\t\t\treturn new View ( con, name, raFile, raFile.position());\r\n\t\t}catch(Throwable e){\r\n\t\t\tif(raFile != null)\r\n\t\t\t\ttry{\r\n\t\t\t\t\traFile.close();\r\n\t\t\t\t}catch(Exception e2){\r\n\t\t\t\t\tDriverManager.println(e2.toString());\r\n\t\t\t\t}\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}","startLine":30,"lastLine":39},{"locFile":"java+method:///smallsql/database/IndexDescription/load(smallsql.database.Database)","rawLines":"private void load(Database database) throws SQLException{\r\n        try{\r\n            File file = getFile( database, name );\r\n            if(!file.exists())\r\n                throw SmallSQLException.create(Language.INDEX_MISSING, name);\r\n            raFile = Utils.openRaFile( file, database.isReadOnly() );\r\n            ByteBuffer buffer = ByteBuffer.allocate(8);\r\n            raFile.read(buffer);\r\n            buffer.position(0);\r\n            int magic   = buffer.getInt();\r\n            int version = buffer.getInt();\r\n            if(magic != MAGIC_INDEX){\r\n                throw SmallSQLException.create(Language.INDEX_FILE_INVALID, file.getName());\r\n            }\r\n            if(version > INDEX_VERSION){\r\n            \tObject[] params = { new Integer(version), file.getName() };\r\n                throw SmallSQLException.create(Language.FILE_TOONEW, params);\r\n            }\r\n        }catch(Throwable e){\r\n            if(raFile != null)\r\n                try{\r\n                    raFile.close();\r\n                }catch(Exception e2){\r\n                    DriverManager.println(e2.toString());\r\n                }\r\n            throw SmallSQLException.createFromException(e);\r\n        }\r\n    }","startLine":18,"lastLine":27}],"window":10},{"content":"if(value == null){if(expr.isNull())dataType = expr.getDataType();elseinitValue( expr );}else if(!expr.isNull()){switch(dataType){case SQLTokenizer.TINYINT:case SQLTokenizer.SMALLINT:case SQLTokenizer.INT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":110,"lastLine":119},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":53,"lastLine":62}],"window":10},{"content":"pr.setObject( 1, testValue.small);pr.setObject( 2, testValue.large);rs = pr.executeQuery();assertTrue( \"To few rows\", rs.next() );assertTrue( \"To few rows\", rs.next() );assertTrue( \"To few rows\", rs.next() );assertTrue( \"To few rows\", rs.next() );assertTrue( \"To few rows\", rs.next() );assertFalse( \"To many rows\", rs.next() );pr.close();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":81,"lastLine":90},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":60,"lastLine":69}],"window":10},{"content":"time += System.currentTimeMillis();System.out.println( \"  Test time: \" + time + \" ms\");st.close();}catch(Exception e){System.out.println(\"  Failed:\"+e);}finally{System.out.println();System.out.println(\"===================================================================\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_RowRequestPages(java.sql.Connection)","rawLines":"/**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":48,"lastLine":57},{"locFile":"java+method:///smallsql/junit/BenchTest/test_Scroll_getXXX(java.sql.Connection)","rawLines":"/**\r\n      *  11. Test\r\n      *  Scroll and call the getXXX methods for every columns.\r\n      */  \r\n    static void test_Scroll_getXXX(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test scroll and call the getXXX methods for every columns: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            long time = -System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            for (int i=0; i<rowCount; i++){\r\n                    rs.next();\r\n\t                rs.getInt   (  1 );\r\n\t                rs.getBytes (  2 );\r\n\t                rs.getString(  3 );\r\n\t                rs.getDate  (  4 );\r\n\t                rs.getFloat (  5 );\r\n\t                rs.getFloat (  6 );\r\n\t                rs.getBytes (  7 );\r\n\t                rs.getInt   (  8 );\r\n\t                rs.getDouble(  9 );\r\n\t                rs.getDouble(  10 );\r\n\t                rs.getFloat (  11 );\r\n\t                rs.getTime  (  12 );\r\n\t                rs.getShort (  13 );\r\n\t                rs.getFloat (  14 );\r\n\t                rs.getString(  15 );\r\n\t                rs.getString(  16 );\r\n\t                rs.getByte  (  17 );\r\n\t                rs.getBytes (  18 );\r\n\t                rs.getString(  19 );\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":34,"lastLine":43},{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteAll(java.sql.Connection)","rawLines":"/**\r\n      *  2. Test\r\n      *  Delete all rows with a single statement.\r\n      */  \r\n    static void test_DeleteAll(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete all rows: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":12,"lastLine":21}],"window":10},{"content":"switch(operation){case IN:case EQUALS_NULL:case EQUALS:    return comp == 0;case GREATER:   return comp >  0;case GRE_EQU:   return comp >= 0;case LESSER:    return comp <  0;case LES_EQU:   return comp <= 0;case UNEQUALS:  return comp != 0;case BETWEEN:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":126,"lastLine":135},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":173,"lastLine":182},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":151,"lastLine":160}],"window":10},{"content":"assertRowCount( 4, \"Select * from transactions\");con.commit();assertRowCount( 4, \"Select * from transactions\");}finally{try{con.createStatement().execute(\"Drop Table transactions\");}catch(Throwable e){e.printStackTrace();}con.setAutoCommit(true);}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testCommitWithOneCommitRow()","rawLines":"/**\r\n\t * In the table there is already one row that is committed.\r\n\t */\r\n\tpublic void testCommitWithOneCommitRow() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions (Select * From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":17,"lastLine":28},{"locFile":"java+method:///smallsql/junit/TestTransactions/testCommit()","rawLines":"public void testCommit() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions Select * From transactions\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":14,"lastLine":25}],"window":10},{"content":"result |= (((long)nextEntry) << shift);if(listEnum.stack>=3){listEnum.offsetStack[listEnum.stack] = offset;return result;}listEnum.offsetStack[listEnum.stack] = offset+pointerSize;offset = getPointer();shift -= 16;listEnum.stack++;listEnum.resultStack[listEnum.stack] = result;","cloneLocs":[{"locFile":"java+method:///smallsql/database/LongTreeList/getPrevious(smallsql.database.LongTreeListEnum)","rawLines":"/**\r\n\t * Get the next long value from this list.\r\n     * If there are no more values then it return -1.\r\n\t * @return\r\n\t */\r\n\tfinal long getPrevious(LongTreeListEnum listEnum){\r\n\t\tint shift = (3-listEnum.stack) << 4;\r\n\t\tif(shift >= 64){ //a previous call of getNext() has return -1\r\n\t\t\tshift = 48;\r\n\t\t\toffset = 0;\r\n\t\t\tlistEnum.stack = 0;\r\n\t\t\tlistEnum.offsetStack[0] = 2 + pointerSize;\r\n\t\t\tloopToEndOfNode(listEnum);\r\n\t\t}else{\r\n\t\t\tsetPreviousOffset(listEnum);\r\n\t\t}\r\n\t\tlong result = listEnum.resultStack[listEnum.stack];\r\n\t\twhile(true){\r\n\t\t\tint nextEntry = (offset < 0) ? -1 : getUnsignedShort();\r\n\t\t\tif(nextEntry >= 0){\r\n\t\t\t\t// there are more entries in this node\r\n\t\t\t\tresult |= (((long)nextEntry) << shift);\r\n\t\t\t\tif(listEnum.stack>=3){\r\n\t\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset+pointerSize;\r\n\t\t\t\toffset = getPointer();\r\n\t\t\t\tshift -= 16;\r\n\t\t\t\tlistEnum.stack++;\r\n\t\t\t\tlistEnum.resultStack[listEnum.stack] = result;\r\n\t\t\t\tloopToEndOfNode(listEnum);\r\n\t\t\t}else{\r\n\t\t\t\t//no more entries in this node\r\n\t\t\t\tshift += 16;\r\n\t\t\t\tlistEnum.stack--;\r\n\t\t\t\tif(listEnum.stack<0) return -1; // no more entries\r\n\t\t\t\tresult = listEnum.resultStack[listEnum.stack];\r\n\t\t\t\tsetPreviousOffset(listEnum);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":21,"lastLine":30},{"locFile":"java+method:///smallsql/database/LongTreeList/getNext(smallsql.database.LongTreeListEnum)","rawLines":"/**\r\n\t * Get the next long value from this list. \r\n     * If there are no more values then it return -1.\r\n\t * @return\r\n\t */\r\n\tfinal long getNext(LongTreeListEnum listEnum){\r\n\t\tint shift = (3-listEnum.stack) << 4;\r\n\t\tif(shift >= 64) return -1; //a previous call has return -1\r\n\t\toffset \t\t= listEnum.offsetStack[listEnum.stack];\r\n\t\tlong result = listEnum.resultStack[listEnum.stack];\r\n\t\tboolean firstNode = (offset == 0); // true if it the first entry in a level\r\n\t\twhile(true){\r\n\t\t\tint nextEntry = getUnsignedShort();\r\n\t\t\tif(nextEntry != 0 || firstNode){\r\n\t\t\t\t//there are more entries in this node\r\n\t\t\t\tresult |= (((long)nextEntry) << shift);\r\n\t\t\t\tif(listEnum.stack>=3){\r\n\t\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset+pointerSize;\r\n\t\t\t\toffset = getPointer();\r\n\t\t\t\tshift -= 16;\r\n\t\t\t\tlistEnum.stack++;\r\n\t\t\t\tlistEnum.resultStack[listEnum.stack] = result;\r\n\t\t\t\tfirstNode = true;\r\n\t\t\t}else{\r\n\t\t\t\t//no more entries in this node\r\n\t\t\t\tshift += 16;\r\n\t\t\t\tlistEnum.stack--;\r\n\t\t\t\tif(listEnum.stack<0) return -1; // no more entries\r\n\t\t\t\tresult = listEnum.resultStack[listEnum.stack];\r\n\t\t\t\toffset = listEnum.offsetStack[listEnum.stack];\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":15,"lastLine":24}],"window":10},{"content":"}}else{prev.nextLock = lock.nextLock;}return;}prev = lock;lock = lock.nextLock;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Table/freeLock(smallsql.database.TableStorePage)","rawLines":"/**\r\n\t * Remove the lock from this table.\r\n\t */\r\n\tvoid freeLock(TableStorePage storePage){\r\n\t\tfinal int lockType = storePage.lockType;\r\n\t\tfinal long fileOffset = storePage.fileOffset;\r\n\t\tsynchronized(locks){\r\n\t\t\ttry{\r\n\t\t\t\tTableStorePage lock;\r\n\t\t\t\tTableStorePage prev;\r\n\t\t\t\tswitch(lockType){\r\n\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();\r\n\t\t\t\t}\r\n\t\t\t}finally{\r\n\t\t\t\tlocks.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":51,"lastLine":60},{"locFile":"java+method:///smallsql/database/Table/freeLock(smallsql.database.TableStorePage)","rawLines":"/**\r\n\t * Remove the lock from this table.\r\n\t */\r\n\tvoid freeLock(TableStorePage storePage){\r\n\t\tfinal int lockType = storePage.lockType;\r\n\t\tfinal long fileOffset = storePage.fileOffset;\r\n\t\tsynchronized(locks){\r\n\t\t\ttry{\r\n\t\t\t\tTableStorePage lock;\r\n\t\t\t\tTableStorePage prev;\r\n\t\t\t\tswitch(lockType){\r\n\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();\r\n\t\t\t\t}\r\n\t\t\t}finally{\r\n\t\t\t\tlocks.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":24,"lastLine":33}],"window":9},{"content":"buf.append( SHORT_MONTHS[ details.month ]);buf.append(' ');formatNumber( details.day, 2, buf);buf.append(' ');formatNumber( details.year, 4, buf);buf.append(' ');formatHour12( details.hour, buf );buf.append(':');formatNumber( details.minute, 2, buf);","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":132,"lastLine":140},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":11,"lastLine":19}],"window":9},{"content":"if(obj == null) return 0;switch(dataType){case SQLTokenizer.BIT:case SQLTokenizer.BOOLEAN:return (obj == Boolean.TRUE) ? 1 : 0;case SQLTokenizer.TINYINT:case SQLTokenizer.SMALLINT:case SQLTokenizer.INT:case SQLTokenizer.BIGINT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/getInt(java.lang.Object,int)","rawLines":"static int getInt(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n                return ((Number)obj).intValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn (int)((DateTime)obj).getTimeMillis();\r\n            default:\r\n\t\t\t\tString str = obj.toString().trim();\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Integer.parseInt( str );\r\n\t\t\t\t}catch(Throwable th){/* A NumberFormatException can occur if it a floating point number */}\r\n\t\t\t\treturn (int)Double.parseDouble( str );\r\n        }\r\n    }","startLine":1,"lastLine":9},{"locFile":"java+method:///smallsql/database/ExpressionValue/getLong(java.lang.Object,int)","rawLines":"static long getLong(Object obj, int dataType) throws Exception{\r\n       if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).longValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: \r\n            \tString str = obj.toString();\r\n            \tif(str.indexOf('-') > 0 || str.indexOf(':') > 0)\r\n            \t\treturn DateTime.parse(str);\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Long.parseLong( str );\r\n\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\treturn (long)Double.parseDouble( str );\r\n\t\t\t\t}\r\n        }\r\n    }","startLine":1,"lastLine":9}],"window":9},{"content":"else System.out.println( \"  Test time: \" + time + \" ms\");st.close();}catch(Exception e){System.out.println(\"  Failed:\"+e);}finally{System.out.println();System.out.println(\"===================================================================\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteRows(java.sql.Connection)","rawLines":"/**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":41,"lastLine":49},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertEmptyRows(java.sql.Connection)","rawLines":"/**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":22,"lastLine":30},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertClassic(java.sql.Connection)","rawLines":"/**\r\n      *  1. Test\r\n      *  Insert rows with default values with a classic insert statement.\r\n      */  \r\n    static void test_InsertClassic(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with default values with a classic insert statement: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                st.execute(\"INSERT INTO \" + tableName + \"(i) VALUES(\" + i +\")\");\r\n            }\r\n            time += System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":20,"lastLine":28}],"window":9},{"content":"if(page == null)return null;if(i + 1 == count)return page.getValue();elsepage = (IndexNode)page.getValue();}throw new Error();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.Expressions,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Returns a Long (unique) or a LongTreeList with rowOffsets. If the value in expressions does not exist then it\r\n     * return a null.\r\n     * \r\n     * @param expressions\r\n     *            The value that are search in the Index.\r\n     * @param searchNullValues\r\n     *            expressions with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     */\r\n\tfinal Object findRows(Expressions expressions, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n        IndexNode page = rootPage;\r\n        int count = expressions.size();\r\n        for(int i = 0; i < count; i++){\r\n            page = findRows(page, expressions.get(i), searchNullValues, nodeList);\r\n            if(page == null)\r\n                return null;\r\n            if(i + 1 == count)\r\n                return page.getValue();\r\n            else\r\n                page = (IndexNode)page.getValue();\r\n        }\r\n        throw new Error();\r\n    }","startLine":16,"lastLine":24},{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.Expression%5B%5D,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Returns a Long (unique) or a LongTreeList with rowOffsets. If the value in expressions does not exist then it\r\n     * return a null.\r\n     * \r\n     * @param expressions\r\n     *            The value that are search in the Index.\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     */\r\n    final Object findRows(Expression[] expressions, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n        IndexNode page = rootPage;\r\n        int count = expressions.length;\r\n        for(int i = 0; i < count; i++){\r\n            page = findRows(page, expressions[i], searchNullValues, nodeList);\r\n            if(page == null)\r\n                return null;\r\n            if(i + 1 == count)\r\n                return page.getValue();\r\n            else\r\n                page = (IndexNode)page.getValue();\r\n        }\r\n        throw new Error();\r\n    }","startLine":16,"lastLine":24}],"window":9},{"content":"try{java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");byte bytes[] = new byte[1024];for(int i=0; i<rowCount; i++){fos.write(bytes);}fos.close();java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");long time = -System.currentTimeMillis();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateLargeBinaryWithSP(java.sql.Connection)","rawLines":"/**\r\n      *  12. Test\r\n      *  Update large binary data with a SP.\r\n      */  \r\n    static void test_UpdateLargeBinaryWithSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data with a SP: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"CREATE PROCEDURE #UpdateLargeBinary(@im image) as Update \" + tableName + \" set im=@im WHERE pr=2\");\r\n            PreparedStatement pr = con.prepareStatement(\"exec #UpdateLargeBinary ?\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            st.execute(\"DROP PROCEDURE #UpdateLargeBinary\");\r\n            st.close();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":8,"lastLine":16},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateLargeBinary(java.sql.Connection)","rawLines":"/**\r\n      *  12. Test\r\n      *  Update large binary data.\r\n      */  \r\n    static void test_UpdateLargeBinary(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            PreparedStatement pr = con.prepareStatement(\"Update \" + tableName + \" set im=? WHERE pr=1\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":8,"lastLine":16}],"window":9},{"content":"case SQLTokenizer.TIMESTAMP:return readTimestamp();case SQLTokenizer.TIME:return readTime();case SQLTokenizer.DATE:return readDate();case SQLTokenizer.SMALLDATETIME:return readSmallDateTime();default:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getLong(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getLong()\r\n     */\r\n    @Override\r\n    long getLong(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2long( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (long)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().longValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Long.parseLong( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Long.parseLong( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getLong( ois.readObject().toString(), SQLTokenizer.VARCHAR );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2long( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BIGINT\" });\r\n        }\r\n    }","startLine":51,"lastLine":59},{"locFile":"java+method:///smallsql/database/StoreImpl/getFloat(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getFloat()\r\n     */\r\n    @Override\r\n    float getFloat(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2float( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (float)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / (float)10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / (float)10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().floatValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Float.parseFloat( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Float.parseFloat( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Float.parseFloat( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2float( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"REAL\" });\r\n        }\r\n    }","startLine":51,"lastLine":59},{"locFile":"java+method:///smallsql/database/StoreImpl/getDouble(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getDouble()\r\n     */\r\n    @Override\r\n    double getDouble(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2double( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().doubleValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Double.parseDouble( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Double.parseDouble( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Double.parseDouble( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2double( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n        }\r\n    }","startLine":51,"lastLine":59}],"window":9},{"content":"public void tearDown(){try{Connection con = AllTests.getConnection();Statement st = con.createStatement();st.execute(\"drop table \" + table);st.close();}catch(Throwable e){}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOperatoren/tearDown()","rawLines":"public void tearDown(){\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }","startLine":0,"lastLine":9},{"locFile":"java+method:///smallsql/junit/TestDataTypes/tearDown()","rawLines":"public void tearDown(){\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }","startLine":0,"lastLine":9},{"locFile":"java+method:///smallsql/junit/TestFunctions/tearDown()","rawLines":"public void tearDown(){\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }","startLine":0,"lastLine":9},{"locFile":"java+method:///smallsql/junit/TestMoneyRounding/tearDown()","rawLines":"public void tearDown(){\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }","startLine":0,"lastLine":9}],"window":9},{"content":"rows.add(row);}}}}Object[][] result = new Object[rows.size()][];rows.toArray(result);return result;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Database/getBestRowIdentifier(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getBestRowIdentifier(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isUnique()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tString columnName = columns.get(c);\r\n\t\t\t\t\t\tColumn column = tab.findColumn(columnName);\r\n\t\t\t\t\t\tObject[] row = new Object[8];\r\n\t\t\t\t\t\trow[0] = Utils.getShort(DatabaseMetaData.bestRowSession);//SCOPE\r\n\t\t\t\t\t\trow[1] = columnName;\t\t\t//COLUMN_NAME\r\n\t\t\t\t\t\tfinal int dataType = column.getDataType();\r\n\t\t\t\t\t\trow[2] = Utils.getInteger(dataType);//DATA_TYPE\r\n\t\t\t\t\t\trow[3] = SQLTokenizer.getKeyWord(dataType);//TYPE_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getInteger(column.getPrecision());\t//COLUMN_SIZE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//BUFFER_LENGTH\r\n\t\t\t\t\t\trow[6] = Utils.getShort(column.getScale());\t\t//DECIMAL_DIGITS\r\n\t\t\t\t\t\trow[7] = Utils.getShort(DatabaseMetaData.bestRowNotPseudo);//PSEUDO_COLUMN\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":25,"lastLine":33},{"locFile":"java+method:///smallsql/database/Database/getReferenceKeys(smallsql.database.SSConnection,java.lang.String,java.lang.String)","rawLines":"Object[][] getReferenceKeys(SSConnection con, String pkTable, String fkTable) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = (pkTable != null) ? getTables(pkTable) : getTables(fkTable);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tForeignKeys references = ((Table)tab).references;\r\n\t\t\tfor(int i=0; i<references.size(); i++){\r\n\t\t\t\tForeignKey foreignKey = references.get(i);\r\n\t\t\t\tIndexDescription pk = foreignKey.pk;\r\n\t\t\t\tIndexDescription fk = foreignKey.fk;\r\n\t\t\t\tif((pkTable == null || pkTable.equals(foreignKey.pkTable)) &&\r\n\t\t\t\t   (fkTable == null || fkTable.equals(foreignKey.fkTable))){\r\n\t\t\t\t\tStrings columnsPk = pk.getColumns();\r\n\t\t\t\t\tStrings columnsFk = fk.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columnsPk.size(); c++){\r\n\t\t\t\t\t\tObject[] row = new Object[14];\r\n\t\t\t\t\t\trow[0] = getName();\t\t\t\t//PKTABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//PKTABLE_SCHEM\r\n\t\t\t\t\t\trow[2] = foreignKey.pkTable;\t//PKTABLE_NAME\r\n\t\t\t\t\t\trow[3] = columnsPk.get(c);\t\t//PKCOLUMN_NAME\r\n\t\t\t\t\t\trow[4] = getName();\t\t\t\t//FKTABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//FKTABLE_SCHEM\r\n\t\t\t\t\t\trow[6] = foreignKey.fkTable;\t//FKTABLE_NAME\r\n\t\t\t\t\t\trow[7] = columnsFk.get(c);\t\t//FKCOLUMN_NAME\r\n\t\t\t\t\t\trow[8] = Utils.getShort(c+1);\t//KEY_SEQ\r\n\t\t\t\t\t\trow[9] = Utils.getShort(foreignKey.updateRule);//UPDATE_RULE\r\n\t\t\t\t\t\trow[10]= Utils.getShort(foreignKey.deleteRule); //DELETE_RULE\r\n\t\t\t\t\t\trow[11]= fk.getName();\t//FK_NAME\r\n\t\t\t\t\t\trow[12]= pk.getName();\t//PK_NAME\r\n\t\t\t\t\t\trow[13]= Utils.getShort(DatabaseMetaData.importedKeyNotDeferrable); //DEFERRABILITY\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":32,"lastLine":40},{"locFile":"java+method:///smallsql/database/Database/getPrimaryKeys(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getPrimaryKeys(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isPrimary()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tObject[] row = new Object[6];\r\n\t\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\t\trow[3] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getShort(c+1);\t//KEY_SEQ\r\n\t\t\t\t\t\trow[5] = index.getName();\t\t//PK_NAME\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":20,"lastLine":28}],"window":9},{"content":"Connection con = AllTests.getConnection();try{con.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");assertRowCount( 0, \"Select * from transactions\");con.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");assertRowCount( 1, \"Select * from transactions\");con.setAutoCommit(false);con.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");assertRowCount( 2, \"Select * from transactions\");","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testRollbackWithOneCommitRow()","rawLines":"/**\r\n\t * In the table there is already one row that is commited.\r\n\t */\r\n\tpublic void testRollbackWithOneCommitRow() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) (Select v From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.rollback();\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":4,"lastLine":14},{"locFile":"java+method:///smallsql/junit/TestTransactions/testCommitWithOneCommitRow()","rawLines":"/**\r\n\t * In the table there is already one row that is committed.\r\n\t */\r\n\tpublic void testCommitWithOneCommitRow() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions (Select * From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":4,"lastLine":14}],"window":9},{"content":"List rows = new ArrayList();Strings tables = getTables(table);for(int t=0; t<tables.size(); t++){String tableName = tables.get(t);TableView tab = getTableView( con, tableName);if(!(tab instanceof Table)) continue;IndexDescriptions indexes = ((Table)tab).indexes;for(int i=0; i<indexes.size(); i++){IndexDescription index = indexes.get(i);","cloneLocs":[{"locFile":"java+method:///smallsql/database/Database/getPrimaryKeys(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getPrimaryKeys(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isPrimary()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tObject[] row = new Object[6];\r\n\t\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\t\trow[3] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getShort(c+1);\t//KEY_SEQ\r\n\t\t\t\t\t\trow[5] = index.getName();\t\t//PK_NAME\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":1,"lastLine":9},{"locFile":"java+method:///smallsql/database/Database/getBestRowIdentifier(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getBestRowIdentifier(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isUnique()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tString columnName = columns.get(c);\r\n\t\t\t\t\t\tColumn column = tab.findColumn(columnName);\r\n\t\t\t\t\t\tObject[] row = new Object[8];\r\n\t\t\t\t\t\trow[0] = Utils.getShort(DatabaseMetaData.bestRowSession);//SCOPE\r\n\t\t\t\t\t\trow[1] = columnName;\t\t\t//COLUMN_NAME\r\n\t\t\t\t\t\tfinal int dataType = column.getDataType();\r\n\t\t\t\t\t\trow[2] = Utils.getInteger(dataType);//DATA_TYPE\r\n\t\t\t\t\t\trow[3] = SQLTokenizer.getKeyWord(dataType);//TYPE_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getInteger(column.getPrecision());\t//COLUMN_SIZE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//BUFFER_LENGTH\r\n\t\t\t\t\t\trow[6] = Utils.getShort(column.getScale());\t\t//DECIMAL_DIGITS\r\n\t\t\t\t\t\trow[7] = Utils.getShort(DatabaseMetaData.bestRowNotPseudo);//PSEUDO_COLUMN\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":1,"lastLine":9}],"window":9},{"content":"case SQLTokenizer.LONGVARBINARY:return getBytes();case SQLTokenizer.DATE:case SQLTokenizer.TIME:case SQLTokenizer.TIMESTAMP:case SQLTokenizer.SMALLDATETIME:return new DateTime( getLong(), dataType );case SQLTokenizer.UNIQUEIDENTIFIER:return getBytes();","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getObject()","rawLines":"Object getObject() throws java.lang.Exception {\r\n        if(isNull()) return null;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return getBytes();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n                    return new Integer( getInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long( getLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( getFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( getDouble() );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( getMoney() );\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return getNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            \t\treturn getString( left.getString(), right.getString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    Object lObj = left.getObject();\r\n                    //FIXME NullPointerException bei NEGATIVE\r\n                    Object rObj = right.getObject();\r\n                    if(lObj instanceof Number && rObj instanceof Number)\r\n                        return new Double( getDoubleImpl( ((Number)lObj).doubleValue(), ((Number)rObj).doubleValue() ) );\r\n                    else\r\n                        return getString( lObj.toString(), rObj.toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n                    return getBytes();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getLong(), dataType );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return getBytes();\r\n            default: throw createUnspportedDataType();\r\n        }\r\n    }","startLine":42,"lastLine":50},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1/getObject()","rawLines":"Object getObject() throws Exception{\r\n\t\tif(isNull()) return null;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n\t        case SQLTokenizer.BIT:\r\n\t        case SQLTokenizer.BOOLEAN:\r\n\t                return getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n\t        case SQLTokenizer.BINARY:\r\n\t        case SQLTokenizer.VARBINARY:\r\n\t                return getBytes();\r\n\t        case SQLTokenizer.TINYINT:\r\n\t        case SQLTokenizer.SMALLINT:\r\n\t        case SQLTokenizer.INT:\r\n\t                return new Integer( getInt() );\r\n\t        case SQLTokenizer.BIGINT:\r\n\t                return new Long( getLong() );\r\n\t        case SQLTokenizer.REAL:\r\n\t                return new Float( getFloat() );\r\n\t        case SQLTokenizer.FLOAT:\r\n\t        case SQLTokenizer.DOUBLE:\r\n\t                return new Double( getDouble() );\r\n\t        case SQLTokenizer.MONEY:\r\n\t        case SQLTokenizer.SMALLMONEY:\r\n\t                return Money.createFromUnscaledValue( getMoney() );\r\n\t        case SQLTokenizer.NUMERIC:\r\n\t        case SQLTokenizer.DECIMAL:\r\n\t                return getNumeric();\r\n\t        case SQLTokenizer.CHAR:\r\n\t        case SQLTokenizer.NCHAR:\r\n\t        case SQLTokenizer.VARCHAR:\r\n\t        case SQLTokenizer.NVARCHAR:\r\n\t        case SQLTokenizer.LONGNVARCHAR:\r\n\t        case SQLTokenizer.LONGVARCHAR:\r\n\t        \t\treturn getString();\r\n\t        case SQLTokenizer.LONGVARBINARY:\r\n\t                return getBytes();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getLong(), dataType );\r\n\t        case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t                return getBytes();\r\n\t        default: throw createUnspportedDataType(param1.getDataType());\r\n\t    }\r\n    }","startLine":34,"lastLine":42}],"window":9},{"content":"Connection con = AllTests.getConnection();try{con.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");assertRowCount( 0, \"Select * from Scrollable\");con.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert')\");assertRowCount( 1, \"Select * from Scrollable\");assertRowCount( 0, \"Select * from Scrollable Where 1=0\");Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestScrollable/testFirstWithWhere()","rawLines":"public void testFirstWithWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from Scrollable\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable Where 1=0\");\r\n\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n            testFirstWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0\") );\r\n            testFirstWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0 Order By v\") );\r\n            testFirstWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v\") );\r\n            testFirstWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v Order By v\") );\r\n\t\t}finally{\r\n            dropTable( con, \"Scrollable\");\r\n\t\t}\r\n\t}","startLine":1,"lastLine":10},{"locFile":"java+method:///smallsql/junit/TestScrollable/testPreviousWithWhere()","rawLines":"public void testPreviousWithWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from Scrollable\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable Where 1=0\");\r\n\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0\") );\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0 Order By v\") );\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v\") );\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v Order By v\") );\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select v from Scrollable Group By v Having 1=0 Order By v\") );\r\n\t\t\t\r\n\t\t}finally{\r\n            dropTable( con, \"Scrollable\");\r\n\t\t}\r\n\t}","startLine":1,"lastLine":10},{"locFile":"java+method:///smallsql/junit/TestScrollable/testLastWithWhere()","rawLines":"public void testLastWithWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from Scrollable\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable Where 1=0\");\r\n\r\n\t\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n            testLastWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0\") );\r\n            testLastWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0 Order By v\") );\r\n            testLastWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Order By v\") );\r\n            testLastWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v Order By v\") );\r\n\t\t}finally{\r\n            dropTable( con, \"Scrollable\");\r\n\t\t}\r\n\t}","startLine":1,"lastLine":10},{"locFile":"java+method:///smallsql/junit/TestScrollable/testNextWithWhere()","rawLines":"public void testNextWithWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from Scrollable\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable Where 1=0\");\r\n\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n            testNextWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0\") );\r\n            testNextWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0 Order By v\") );\r\n            testNextWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v\") );\r\n            testNextWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v Order By v\") );\r\n\t\t}finally{\r\n            dropTable( con, \"Scrollable\");\r\n\t\t}\r\n\t}","startLine":1,"lastLine":10}],"window":8},{"content":"formatNumber( details.hour, 2, buf);buf.append(':');formatNumber( details.minute, 2, buf);buf.append(':');formatNumber( details.second, 2, buf);buf.append('.');formatMillis( details.millis, buf );return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":233,"lastLine":240},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":249,"lastLine":256}],"window":8},{"content":"break;case SQLTokenizer.BIGINT:case SQLTokenizer.DATE:case SQLTokenizer.TIME:case SQLTokenizer.TIMESTAMP:case SQLTokenizer.SMALLDATETIME:case SQLTokenizer.MONEY:case SQLTokenizer.SMALLMONEY:","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":30,"lastLine":37},{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.IndexNode,smallsql.database.Expression,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}","startLine":36,"lastLine":43}],"window":8},{"content":"Statement st = con.createStatement();try{st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");for(int i = 0; i < 200; i++){Thread thread = new Thread(new Runnable(){public void run(){try{","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentConnectionWrite()","rawLines":"/**\r\n     * Create a table with a single row. In different connections a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentConnectionWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Connection con2 = AllTests.createConnection();\r\n                            Statement st2 = con2.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                            con2.close();\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }","startLine":10,"lastLine":20},{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentThreadWrite()","rawLines":"/**\r\n     * Create a table with a single row. In different threads on the same connection a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentThreadWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Statement st2 = con.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }","startLine":10,"lastLine":20}],"window":8},{"content":"rs.beforeFirst();assertTrue( rs.next() );assertEquals(\"qwert2\", rs.getString(\"v\"));assertFalse( rs.next() );}finally{try{con.createStatement().execute(\"Drop Table transactions\");}catch(Throwable e){e.printStackTrace();}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_withWrongWhere()","rawLines":"/**\r\n     * If there was insert a row within the ResultSet that not map WHERE than you scroll to this row. If there an Insert\r\n     * outsite the ResultSet that not map the WHERE then you can't scroll this row.\r\n     * \r\n     * @throws Exception\r\n     */\r\n\tpublic void testInsertRow_withWrongWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":22,"lastLine":29},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_Last(java.sql.Connection,boolean)","rawLines":"private void testInsertRow_Last(Connection con, boolean callLastBefore) throws Exception{\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\tif(callLastBefore) rs.last();\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.last();\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t\tassertTrue( rs.previous() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t}\r\n\t}","startLine":21,"lastLine":29}],"window":8},{"content":"assertTrue( rs.next() );oldValue = rs.getString(\"v\");assertNull(oldValue);assertTrue( rs.next() );oldValue = rs.getString(\"v\");int count = 1;while(rs.next()){String newValue = rs.getString(\"v\");","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar()","rawLines":"public void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":9,"lastLine":18},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_asc()","rawLines":"public void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":9,"lastLine":18}],"window":8},{"content":"st.close();}catch(Exception e){System.out.println(\"  Failed:\"+e);}finally{System.out.println();System.out.println(\"===================================================================\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_RowRequestPages(java.sql.Connection)","rawLines":"/**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":50,"lastLine":57},{"locFile":"java+method:///smallsql/junit/BenchTest/test_Scroll_getXXX(java.sql.Connection)","rawLines":"/**\r\n      *  11. Test\r\n      *  Scroll and call the getXXX methods for every columns.\r\n      */  \r\n    static void test_Scroll_getXXX(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test scroll and call the getXXX methods for every columns: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            long time = -System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            for (int i=0; i<rowCount; i++){\r\n                    rs.next();\r\n\t                rs.getInt   (  1 );\r\n\t                rs.getBytes (  2 );\r\n\t                rs.getString(  3 );\r\n\t                rs.getDate  (  4 );\r\n\t                rs.getFloat (  5 );\r\n\t                rs.getFloat (  6 );\r\n\t                rs.getBytes (  7 );\r\n\t                rs.getInt   (  8 );\r\n\t                rs.getDouble(  9 );\r\n\t                rs.getDouble(  10 );\r\n\t                rs.getFloat (  11 );\r\n\t                rs.getTime  (  12 );\r\n\t                rs.getShort (  13 );\r\n\t                rs.getFloat (  14 );\r\n\t                rs.getString(  15 );\r\n\t                rs.getString(  16 );\r\n\t                rs.getByte  (  17 );\r\n\t                rs.getBytes (  18 );\r\n\t                rs.getString(  19 );\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":36,"lastLine":43},{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteRows(java.sql.Connection)","rawLines":"/**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":42,"lastLine":49},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertEmptyRows(java.sql.Connection)","rawLines":"/**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":23,"lastLine":30},{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteAll(java.sql.Connection)","rawLines":"/**\r\n      *  2. Test\r\n      *  Delete all rows with a single statement.\r\n      */  \r\n    static void test_DeleteAll(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete all rows: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":14,"lastLine":21},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertClassic(java.sql.Connection)","rawLines":"/**\r\n      *  1. Test\r\n      *  Insert rows with default values with a classic insert statement.\r\n      */  \r\n    static void test_InsertClassic(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with default values with a classic insert statement: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                st.execute(\"INSERT INTO \" + tableName + \"(i) VALUES(\" + i +\")\");\r\n            }\r\n            time += System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":21,"lastLine":28}],"window":8},{"content":"result = left.next();if(result){result = right.first();if(!result){switch(type){case Join.LEFT_JOIN:case Join.FULL_JOIN:isOuterValid = false;","cloneLocs":[{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":13,"lastLine":20},{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":50,"lastLine":57}],"window":8},{"content":"fail(\"SQLException 'Duplicated Column' should be throw\");}catch(SQLException e){assertSQLException(\"01000\", 0, e);}}finally{dropTable(con, \"DuplicatedColumn\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testDuplicatedColumnAlter()","rawLines":"public void testDuplicatedColumnAlter() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"Create Table DuplicatedColumn(col INT)\");\r\n            try{\r\n                st.execute(\"ALTER TABLE DuplicatedColumn Add Col INT\");\r\n                fail(\"SQLException 'Duplicated Column' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"DuplicatedColumn\");\r\n        }\r\n    }","startLine":7,"lastLine":14},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testDuplicatedColumnInsert()","rawLines":"public void testDuplicatedColumnInsert() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"Create Table DuplicatedColumn(col INT)\");\r\n            try{\r\n                st.execute(\"INSERT INTO DuplicatedColumn(col,Col) Values(1,2)\");\r\n                fail(\"SQLException 'Duplicated Column' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"DuplicatedColumn\");\r\n        }\r\n    }","startLine":7,"lastLine":14}],"window":8},{"content":"formatNumber( details.hour, 2, buf);buf.append(':');formatNumber( details.minute, 2, buf);buf.append(':');formatNumber( details.second, 2, buf);buf.append(':');formatMillis( details.millis, buf );return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":203,"lastLine":210},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":280,"lastLine":287}],"window":8},{"content":"try{Expression expr = getValue(i);wasNull = expr.isNull();return expr.getLong();}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSCallableStatement/getDouble(int)","rawLines":"public double getDouble(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getLong(int)","rawLines":"public long getLong(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":8}],"window":8},{"content":"this.offset = valueOffset;if(readBoolean()) return 0;switch(dataType){case SQLTokenizer.BIT:case SQLTokenizer.BOOLEAN:return readBoolean() ? 1 : 0;case SQLTokenizer.BINARY:case SQLTokenizer.VARBINARY:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getInt(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getInt()\r\n     */\r\n    @Override\r\n    int getInt(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return (int)readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (int)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (int)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n            \t\tlong longValue = readLong() / 10000;\r\n            \t\treturn Utils.money2int(longValue);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().intValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Integer.parseInt( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Integer.parseInt( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getInt(ois.readObject().toString(), SQLTokenizer.VARCHAR);\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn (int)readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn (int)readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn (int)readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn (int)readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"INT\" });\r\n        }\r\n    }","startLine":5,"lastLine":12},{"locFile":"java+method:///smallsql/database/StoreImpl/getLong(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getLong()\r\n     */\r\n    @Override\r\n    long getLong(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2long( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (long)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().longValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Long.parseLong( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Long.parseLong( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getLong( ois.readObject().toString(), SQLTokenizer.VARCHAR );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2long( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BIGINT\" });\r\n        }\r\n    }","startLine":5,"lastLine":12},{"locFile":"java+method:///smallsql/database/StoreImpl/getFloat(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getFloat()\r\n     */\r\n    @Override\r\n    float getFloat(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2float( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (float)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / (float)10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / (float)10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().floatValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Float.parseFloat( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Float.parseFloat( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Float.parseFloat( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2float( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"REAL\" });\r\n        }\r\n    }","startLine":5,"lastLine":12},{"locFile":"java+method:///smallsql/database/StoreImpl/getDouble(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getDouble()\r\n     */\r\n    @Override\r\n    double getDouble(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2double( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().doubleValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Double.parseDouble( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Double.parseDouble( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Double.parseDouble( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2double( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n        }\r\n    }","startLine":5,"lastLine":12}],"window":8},{"content":"wasNull = obj == null;if(wasNull) return null;return obj.toBigDecimal(scale);}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getBigDecimal(int,int)","rawLines":"public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(columnIndex).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal(scale);\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBigDecimal(int,int)","rawLines":"public BigDecimal getBigDecimal(int i, int scale) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal(scale);\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9}],"window":7},{"content":"}}}Object[][] result = new Object[rows.size()][];rows.toArray(result);return result;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Database/getBestRowIdentifier(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getBestRowIdentifier(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isUnique()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tString columnName = columns.get(c);\r\n\t\t\t\t\t\tColumn column = tab.findColumn(columnName);\r\n\t\t\t\t\t\tObject[] row = new Object[8];\r\n\t\t\t\t\t\trow[0] = Utils.getShort(DatabaseMetaData.bestRowSession);//SCOPE\r\n\t\t\t\t\t\trow[1] = columnName;\t\t\t//COLUMN_NAME\r\n\t\t\t\t\t\tfinal int dataType = column.getDataType();\r\n\t\t\t\t\t\trow[2] = Utils.getInteger(dataType);//DATA_TYPE\r\n\t\t\t\t\t\trow[3] = SQLTokenizer.getKeyWord(dataType);//TYPE_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getInteger(column.getPrecision());\t//COLUMN_SIZE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//BUFFER_LENGTH\r\n\t\t\t\t\t\trow[6] = Utils.getShort(column.getScale());\t\t//DECIMAL_DIGITS\r\n\t\t\t\t\t\trow[7] = Utils.getShort(DatabaseMetaData.bestRowNotPseudo);//PSEUDO_COLUMN\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":27,"lastLine":33},{"locFile":"java+method:///smallsql/database/Database/getIndexInfo(smallsql.database.SSConnection,java.lang.String,boolean)","rawLines":"Object[][] getIndexInfo( SSConnection con, String table, boolean unique) throws SQLException {\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tShort type = Utils.getShort( DatabaseMetaData.tableIndexOther );\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\tObject[] row = new Object[13];\r\n\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\trow[3] = Boolean.valueOf(!index.isUnique());//NON_UNIQUE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//INDEX_QUALIFIER\r\n\t\t\t\t\trow[5] = index.getName();\t\t//INDEX_NAME\r\n\t\t\t\t\trow[6] = type;\t\t\t\t\t//TYPE\r\n\t\t\t\t\trow[7] = Utils.getShort(c+1);\t//ORDINAL_POSITION\r\n\t\t\t\t\trow[8] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//ASC_OR_DESC\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//CARDINALITY\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//PAGES\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//FILTER_CONDITION\r\n\t\t\t\t\trows.add(row);\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\r\n\t}","startLine":28,"lastLine":34},{"locFile":"java+method:///smallsql/database/Database/getReferenceKeys(smallsql.database.SSConnection,java.lang.String,java.lang.String)","rawLines":"Object[][] getReferenceKeys(SSConnection con, String pkTable, String fkTable) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = (pkTable != null) ? getTables(pkTable) : getTables(fkTable);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tForeignKeys references = ((Table)tab).references;\r\n\t\t\tfor(int i=0; i<references.size(); i++){\r\n\t\t\t\tForeignKey foreignKey = references.get(i);\r\n\t\t\t\tIndexDescription pk = foreignKey.pk;\r\n\t\t\t\tIndexDescription fk = foreignKey.fk;\r\n\t\t\t\tif((pkTable == null || pkTable.equals(foreignKey.pkTable)) &&\r\n\t\t\t\t   (fkTable == null || fkTable.equals(foreignKey.fkTable))){\r\n\t\t\t\t\tStrings columnsPk = pk.getColumns();\r\n\t\t\t\t\tStrings columnsFk = fk.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columnsPk.size(); c++){\r\n\t\t\t\t\t\tObject[] row = new Object[14];\r\n\t\t\t\t\t\trow[0] = getName();\t\t\t\t//PKTABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//PKTABLE_SCHEM\r\n\t\t\t\t\t\trow[2] = foreignKey.pkTable;\t//PKTABLE_NAME\r\n\t\t\t\t\t\trow[3] = columnsPk.get(c);\t\t//PKCOLUMN_NAME\r\n\t\t\t\t\t\trow[4] = getName();\t\t\t\t//FKTABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//FKTABLE_SCHEM\r\n\t\t\t\t\t\trow[6] = foreignKey.fkTable;\t//FKTABLE_NAME\r\n\t\t\t\t\t\trow[7] = columnsFk.get(c);\t\t//FKCOLUMN_NAME\r\n\t\t\t\t\t\trow[8] = Utils.getShort(c+1);\t//KEY_SEQ\r\n\t\t\t\t\t\trow[9] = Utils.getShort(foreignKey.updateRule);//UPDATE_RULE\r\n\t\t\t\t\t\trow[10]= Utils.getShort(foreignKey.deleteRule); //DELETE_RULE\r\n\t\t\t\t\t\trow[11]= fk.getName();\t//FK_NAME\r\n\t\t\t\t\t\trow[12]= pk.getName();\t//PK_NAME\r\n\t\t\t\t\t\trow[13]= Utils.getShort(DatabaseMetaData.importedKeyNotDeferrable); //DEFERRABILITY\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":34,"lastLine":40},{"locFile":"java+method:///smallsql/database/Database/getPrimaryKeys(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getPrimaryKeys(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isPrimary()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tObject[] row = new Object[6];\r\n\t\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\t\trow[3] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getShort(c+1);\t//KEY_SEQ\r\n\t\t\t\t\t\trow[5] = index.getName();\t\t//PK_NAME\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":22,"lastLine":28}],"window":7},{"content":"public void tearDown(){try {dropTable( AllTests.getConnection(), table );} catch (SQLException ex) {ex.printStackTrace();}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestAlterTable2/tearDown()","rawLines":"public void tearDown(){\r\n        try {\r\n            dropTable( AllTests.getConnection(), table );\r\n        } catch (SQLException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }","startLine":0,"lastLine":6},{"locFile":"java+method:///smallsql/junit/TestAlterTable/tearDown()","rawLines":"public void tearDown(){\r\n        try {\r\n            dropTable( AllTests.getConnection(), table );\r\n        } catch (SQLException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }","startLine":0,"lastLine":6}],"window":7},{"content":"wasNull = expr.isNull();if(wasNull) return null;return DateTime.getTime( expr.getLong() );}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSCallableStatement/getTime(int)","rawLines":"public Time getTime(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTime( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSResultSet/getTime(int)","rawLines":"public Time getTime(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTime( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9}],"window":7},{"content":"for(int t=0; t<tables.size(); t++){String tableName = tables.get(t);TableView tab = getTableView( con, tableName);if(!(tab instanceof Table)) continue;IndexDescriptions indexes = ((Table)tab).indexes;for(int i=0; i<indexes.size(); i++){IndexDescription index = indexes.get(i);","cloneLocs":[{"locFile":"java+method:///smallsql/database/Database/getPrimaryKeys(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getPrimaryKeys(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isPrimary()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tObject[] row = new Object[6];\r\n\t\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\t\trow[3] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getShort(c+1);\t//KEY_SEQ\r\n\t\t\t\t\t\trow[5] = index.getName();\t\t//PK_NAME\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":3,"lastLine":9},{"locFile":"java+method:///smallsql/database/Database/getIndexInfo(smallsql.database.SSConnection,java.lang.String,boolean)","rawLines":"Object[][] getIndexInfo( SSConnection con, String table, boolean unique) throws SQLException {\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tShort type = Utils.getShort( DatabaseMetaData.tableIndexOther );\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\tObject[] row = new Object[13];\r\n\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\trow[3] = Boolean.valueOf(!index.isUnique());//NON_UNIQUE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//INDEX_QUALIFIER\r\n\t\t\t\t\trow[5] = index.getName();\t\t//INDEX_NAME\r\n\t\t\t\t\trow[6] = type;\t\t\t\t\t//TYPE\r\n\t\t\t\t\trow[7] = Utils.getShort(c+1);\t//ORDINAL_POSITION\r\n\t\t\t\t\trow[8] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//ASC_OR_DESC\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//CARDINALITY\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//PAGES\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//FILTER_CONDITION\r\n\t\t\t\t\trows.add(row);\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\r\n\t}","startLine":4,"lastLine":10},{"locFile":"java+method:///smallsql/database/Database/getBestRowIdentifier(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getBestRowIdentifier(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isUnique()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tString columnName = columns.get(c);\r\n\t\t\t\t\t\tColumn column = tab.findColumn(columnName);\r\n\t\t\t\t\t\tObject[] row = new Object[8];\r\n\t\t\t\t\t\trow[0] = Utils.getShort(DatabaseMetaData.bestRowSession);//SCOPE\r\n\t\t\t\t\t\trow[1] = columnName;\t\t\t//COLUMN_NAME\r\n\t\t\t\t\t\tfinal int dataType = column.getDataType();\r\n\t\t\t\t\t\trow[2] = Utils.getInteger(dataType);//DATA_TYPE\r\n\t\t\t\t\t\trow[3] = SQLTokenizer.getKeyWord(dataType);//TYPE_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getInteger(column.getPrecision());\t//COLUMN_SIZE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//BUFFER_LENGTH\r\n\t\t\t\t\t\trow[6] = Utils.getShort(column.getScale());\t\t//DECIMAL_DIGITS\r\n\t\t\t\t\t\trow[7] = Utils.getShort(DatabaseMetaData.bestRowNotPseudo);//PSEUDO_COLUMN\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":3,"lastLine":9}],"window":7},{"content":"assertFalse( rs.next() );}finally{try{con.createStatement().execute(\"Drop Table transactions\");}catch(Throwable e){e.printStackTrace();}}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_withRightWhere()","rawLines":"/**\r\n\t * A row that was inserted and committed with a valid WHERE expression should not count 2 times.\r\n\t */\r\n\tpublic void testInsertRow_withRightWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert2')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where v = 'qwert'\");\r\n\t\t\t\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t}\r\n\t}","startLine":21,"lastLine":27},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_Last(java.sql.Connection,boolean)","rawLines":"private void testInsertRow_Last(Connection con, boolean callLastBefore) throws Exception{\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\tif(callLastBefore) rs.last();\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.last();\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t\tassertTrue( rs.previous() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t}\r\n\t}","startLine":24,"lastLine":31}],"window":7},{"content":"if(!previous()){return false;}}}return true;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SortedResult/relative(int)","rawLines":"boolean relative(int rows) throws Exception{\r\n        if(rows == 0) return (row != 0);\r\n        if(rows > 0){\r\n            while(rows-- > 0){\r\n                if(!next()){\r\n                    return false;\r\n                }\r\n            }\r\n        }else{\r\n            while(rows++ < 0){\r\n                if(!previous()){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","startLine":10,"lastLine":16},{"locFile":"java+method:///smallsql/database/SortedResult/absolute(int)","rawLines":"boolean absolute(int newRow) throws Exception{\r\n        if(newRow == 0) throw SmallSQLException.create(Language.ROW_0_ABSOLUTE);\r\n        if(newRow > 0){\r\n            beforeFirst();\r\n            while(newRow-- > 0){\r\n                if(!next()){\r\n                    return false;\r\n                }\r\n            }\r\n        }else{\r\n            afterLast();\r\n            while(newRow++ < 0){\r\n                if(!previous()){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","startLine":12,"lastLine":18}],"window":7},{"content":"wasNull = obj == null;if(wasNull) return null;return obj.toBigDecimal();}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getBigDecimal(int)","rawLines":"public BigDecimal getBigDecimal(int columnIndex) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(columnIndex).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBigDecimal(int)","rawLines":"public BigDecimal getBigDecimal(int i) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9}],"window":7},{"content":"if(places > 0){value /= factor;}else{value *= factor;}return value;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionTruncate/getDouble()","rawLines":"final double getDouble() throws Exception{\r\n\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}\r\n        value -= value % 1; //modulo also work with values larger long\r\n\t\tif(places > 0){\r\n\t\t\tvalue /= factor;\r\n\t\t}else{\r\n\t\t\tvalue *= factor;\r\n\t\t}\r\n\t\treturn value;\r\n    }","startLine":17,"lastLine":23},{"locFile":"java+method:///smallsql/database/ExpressionFunctionRound/getDouble()","rawLines":"final double getDouble() throws Exception{\r\n\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}\r\n\t\tvalue = Math.rint( value );\r\n\t\tif(places > 0){\r\n\t\t\tvalue /= factor;\r\n\t\t}else{\r\n\t\t\tvalue *= factor;\r\n\t\t}\r\n\t\treturn value;\r\n    }","startLine":17,"lastLine":23}],"window":7},{"content":"node.addNode( digit, rowOffset );return null;}return node.addRoot(digit);}node = node.addNode(digit);if(node.isEmpty()){","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/add(smallsql.database.IndexNode,long,long,boolean,int)","rawLines":"/**\r\n\t * The key has a binary sort order. This means the most significant byte is in the high byte.\r\n\t * @param digitCount The count of 16Bit digits.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, long key, boolean isLastValue, int digitCount) throws SQLException{\r\n\t\tfor(int i=digitCount-1; i>=0; i--){\r\n\t\t\tchar digit = (char)(key >> (i<<4));\r\n\t\t\tif(i == 0){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i);\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.saveValue( rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\tthrow new Error();\r\n\t}","startLine":9,"lastLine":15},{"locFile":"java+method:///smallsql/database/Index/add(smallsql.database.IndexNode,long,char%5B%5D,boolean)","rawLines":"/**\r\n\t * Add a byte array to the Index.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, char[] key, boolean isLast) throws SQLException{\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tif(++i == length){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i );\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.saveValue(rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":12,"lastLine":18}],"window":7},{"content":"wasNull = expr.isNull();if(wasNull) return null;return DateTime.getDate( expr.getLong() );}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSCallableStatement/getDate(int)","rawLines":"public Date getDate(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getDate( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSResultSet/getDate(int)","rawLines":"public Date getDate(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getDate( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9}],"window":7},{"content":"private static TestValue a(String dataType, Object small, Object large){TestValue value = new TestValue();value.dataType  = dataType;value.small     = small;value.large     = large;return value;}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestJoins/a(java.lang.String,java.lang.Object,java.lang.Object)","rawLines":"private static TestValue a(String dataType, Object small, Object large){\r\n        TestValue value = new TestValue();\r\n        value.dataType  = dataType;\r\n        value.small     = small;\r\n        value.large     = large;\r\n        return value;\r\n    }","startLine":0,"lastLine":6},{"locFile":"java+method:///smallsql/junit/TestOperatoren/a(java.lang.String,java.lang.Object,java.lang.Object)","rawLines":"private static TestValue a(String dataType, Object small, Object large){\r\n        TestValue value = new TestValue();\r\n        value.dataType  = dataType;\r\n        value.small     = small;\r\n        value.large     = large;\r\n        return value;\r\n    }","startLine":0,"lastLine":6}],"window":7},{"content":"wasNull = expr.isNull();if(wasNull) return null;return DateTime.getTimestamp( expr.getLong() );}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getTimestamp(int)","rawLines":"public Timestamp getTimestamp(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTimestamp( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getTimestamp(int)","rawLines":"public Timestamp getTimestamp(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return DateTime.getTimestamp( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":9}],"window":7},{"content":"}catch(Exception e){System.out.println(\"  Failed:\"+e);}finally{System.out.println();System.out.println(\"===================================================================\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepare(java.sql.Connection)","rawLines":"/**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":39,"lastLine":45},{"locFile":"java+method:///smallsql/junit/BenchTest/test_RowRequestPages(java.sql.Connection)","rawLines":"/**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":51,"lastLine":57},{"locFile":"java+method:///smallsql/junit/BenchTest/test_Scroll_getXXX(java.sql.Connection)","rawLines":"/**\r\n      *  11. Test\r\n      *  Scroll and call the getXXX methods for every columns.\r\n      */  \r\n    static void test_Scroll_getXXX(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test scroll and call the getXXX methods for every columns: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            long time = -System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            for (int i=0; i<rowCount; i++){\r\n                    rs.next();\r\n\t                rs.getInt   (  1 );\r\n\t                rs.getBytes (  2 );\r\n\t                rs.getString(  3 );\r\n\t                rs.getDate  (  4 );\r\n\t                rs.getFloat (  5 );\r\n\t                rs.getFloat (  6 );\r\n\t                rs.getBytes (  7 );\r\n\t                rs.getInt   (  8 );\r\n\t                rs.getDouble(  9 );\r\n\t                rs.getDouble(  10 );\r\n\t                rs.getFloat (  11 );\r\n\t                rs.getTime  (  12 );\r\n\t                rs.getShort (  13 );\r\n\t                rs.getFloat (  14 );\r\n\t                rs.getString(  15 );\r\n\t                rs.getString(  16 );\r\n\t                rs.getByte  (  17 );\r\n\t                rs.getBytes (  18 );\r\n\t                rs.getString(  19 );\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":37,"lastLine":43},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateLargeBinary(java.sql.Connection)","rawLines":"/**\r\n      *  12. Test\r\n      *  Update large binary data.\r\n      */  \r\n    static void test_UpdateLargeBinary(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            PreparedStatement pr = con.prepareStatement(\"Update \" + tableName + \" set im=? WHERE pr=1\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":26,"lastLine":32},{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteRows(java.sql.Connection)","rawLines":"/**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":43,"lastLine":49},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertEmptyRows(java.sql.Connection)","rawLines":"/**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":24,"lastLine":30},{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteAll(java.sql.Connection)","rawLines":"/**\r\n      *  2. Test\r\n      *  Delete all rows with a single statement.\r\n      */  \r\n    static void test_DeleteAll(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete all rows: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":15,"lastLine":21},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertClassic(java.sql.Connection)","rawLines":"/**\r\n      *  1. Test\r\n      *  Insert rows with default values with a classic insert statement.\r\n      */  \r\n    static void test_InsertClassic(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with default values with a classic insert statement: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                st.execute(\"INSERT INTO \" + tableName + \"(i) VALUES(\" + i +\")\");\r\n            }\r\n            time += System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":22,"lastLine":28},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepareBatch(java.sql.Connection)","rawLines":"/**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":45,"lastLine":51},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateLargeBinaryWithSP(java.sql.Connection)","rawLines":"/**\r\n      *  12. Test\r\n      *  Update large binary data with a SP.\r\n      */  \r\n    static void test_UpdateLargeBinaryWithSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data with a SP: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"CREATE PROCEDURE #UpdateLargeBinary(@im image) as Update \" + tableName + \" set im=@im WHERE pr=2\");\r\n            PreparedStatement pr = con.prepareStatement(\"exec #UpdateLargeBinary ?\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            st.execute(\"DROP PROCEDURE #UpdateLargeBinary\");\r\n            st.close();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":30,"lastLine":36}],"window":7},{"content":"if(obj == null) return 0;switch(dataType){case SQLTokenizer.BIT:return (obj.equals(Boolean.TRUE)) ? 1 : 0;case SQLTokenizer.INT:case SQLTokenizer.BIGINT:case SQLTokenizer.DOUBLE:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/getDouble(java.lang.Object,int)","rawLines":"static double getDouble(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: return Double.parseDouble( obj.toString() );\r\n        }\r\n    }","startLine":1,"lastLine":7},{"locFile":"java+method:///smallsql/database/ExpressionValue/getFloat(java.lang.Object,int)","rawLines":"static float getFloat(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).floatValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: return Float.parseFloat( obj.toString() );\r\n        }\r\n    }","startLine":1,"lastLine":7}],"window":7},{"content":"}finally{try{con.createStatement().execute(\"Drop Table transactions\");}catch(Throwable e){e.printStackTrace();}con.setAutoCommit(true);}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testCommitWithOneCommitRow()","rawLines":"/**\r\n\t * In the table there is already one row that is committed.\r\n\t */\r\n\tpublic void testCommitWithOneCommitRow() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions (Select * From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":22,"lastLine":28},{"locFile":"java+method:///smallsql/junit/TestTransactions/testCommit()","rawLines":"public void testCommit() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions Select * From transactions\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":19,"lastLine":25},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_withWrongWhere()","rawLines":"/**\r\n     * If there was insert a row within the ResultSet that not map WHERE than you scroll to this row. If there an Insert\r\n     * outsite the ResultSet that not map the WHERE then you can't scroll this row.\r\n     * \r\n     * @throws Exception\r\n     */\r\n\tpublic void testInsertRow_withWrongWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":26,"lastLine":32},{"locFile":"java+method:///smallsql/junit/TestTransactions/testRollback()","rawLines":"public void testRollback() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t    con.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) (Select v From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.rollback();\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":19,"lastLine":25},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertAndUpdate()","rawLines":"/**\r\n     * Insert a row and update the inserted row in the same transaction. Then make a partial rollback. Test the correct\r\n     * status after of the table after every change of the database.\r\n     * \r\n     * @throws Exception\r\n     *             if an error occur\r\n     */\r\n\tpublic void testInsertAndUpdate() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions ( v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Insert Into transactions(v) Values('qwert')\") );\r\n\t\t\tassertEqualsRsValue(\"qwert\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t\t\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert1'\") );\r\n\t\t\tassertEqualsRsValue(\"qwert1\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t\t\r\n            assertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert2'\") );\r\n            assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n            \r\n\t\t\tSavepoint savepoint = con.setSavepoint();\r\n\t\t\t\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 3'\") );\r\n\t\t\tassertEqualsRsValue(\"qwert 3\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n\t\t\tcon.rollback( savepoint );\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":37,"lastLine":43},{"locFile":"java+method:///smallsql/junit/TestTransactions/testRollbackWithOneCommitRow()","rawLines":"/**\r\n\t * In the table there is already one row that is commited.\r\n\t */\r\n\tpublic void testRollbackWithOneCommitRow() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) (Select v From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.rollback();\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":22,"lastLine":28}],"window":7},{"content":"}firstNode = false;if(shift != 0) offset += pointerSize;}shift -= 16;}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/LongTreeList/remove(long)","rawLines":"/**\r\n\t * Remove a value from this list.\r\n\t * @param value\r\n\t * @throws SQLException\r\n\t */\r\n\tfinal void remove(long value) throws SQLException{\r\n\t\tif(size == 0) return;\r\n\t\tint offset1 = 0;\r\n\t\tint offset2 = 0;\r\n\t\tint offset3 = 0;\r\n\t\toffset = 0;\r\n\t\tint shift = 48;\r\n\t\tboolean firstNode = true; // if this the first node in this tree level (0 can be the first node and are the end of the level)\r\n\t\tboolean firstNode1 = true;\r\n\t\tboolean firstNode2 = true;\r\n\t\tboolean firstNode3 = true;\r\n\t\twhile(shift>=0){\r\n\t\t\tint octet = (int)(value >> shift) & 0xFFFF;\r\n\t\t\twhile(true){\r\n\t\t\t\tint nextEntry = getUnsignedShort();\r\n\t\t\t\tif(nextEntry == octet){\r\n\t\t\t\t\tif(shift == 0){\r\n\t\t\t\t\t\t//value find\r\n\t\t\t\t\t\toffset -= 2;\r\n\t\t\t\t\t\tremoveNodeLastLevel();\r\n\t\t\t\t\t\twhile(firstNode && getUnsignedShort() == 0){\r\n\t\t\t\t\t\t\toffset -= 2;\r\n\t\t\t\t\t\t\tremoveNodeLastLevel(); // the end 0 of a node\r\n\t\t\t\t\t\t\tif(shift >= 3) \r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\toffset = offset1;\r\n\t\t\t\t\t\t\toffset1 = offset2;\r\n\t\t\t\t\t\t\toffset2 = offset3;\r\n\t\t\t\t\t\t\tfirstNode = firstNode1;\r\n\t\t\t\t\t\t\tfirstNode1 = firstNode2;\r\n\t\t\t\t\t\t\tfirstNode2 = firstNode3;\r\n\t\t\t\t\t\t\tremoveNode();\r\n\t\t\t\t\t\t\tshift++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\toffset3 = offset2;\r\n\t\t\t\t\toffset2 = offset1;\r\n\t\t\t\t\toffset1 = offset -2;\r\n\t\t\t\t\toffset = getPointer();\r\n\t\t\t\t\tfirstNode3 = firstNode2;\r\n\t\t\t\t\tfirstNode2 = firstNode1;\r\n\t\t\t\t\tfirstNode1 = firstNode;\r\n\t\t\t\t\tfirstNode = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif((nextEntry == 0 && !firstNode) || nextEntry > octet){\r\n\t\t\t\t\t//value is not in the list, this should not occur\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t\tif(shift != 0) offset += pointerSize;\r\n\t\t\t}\r\n\t\t\tshift -= 16;\r\n\t\t}\r\n\t}","startLine":54,"lastLine":60},{"locFile":"java+method:///smallsql/database/LongTreeList/add(long)","rawLines":"/**\r\n\t * Add a value to this list.\r\n\t * @param value\r\n\t * @throws SQLException\r\n\t */\r\n\tfinal void add(long value) throws SQLException{\r\n\t\toffset = 0;\r\n\t\tif(size == 0){\r\n\t\t\twriteShort( (int)(value >> 48) );\r\n\t\t\twritePointer ( offset+pointerSize+2 );\r\n\t\t\twriteShort( 0 );\r\n\t\t\twriteShort( (int)(value >> 32) );\r\n\t\t\twritePointer ( offset+pointerSize+2 );\r\n\t\t\twriteShort( 0 );\r\n\t\t\twriteShort( (int)(value >> 16) );\r\n\t\t\twritePointer ( offset+pointerSize+2 );\r\n\t\t\twriteShort( 0 );\r\n\t\t\twriteShort( (int)(value) );\r\n\t\t\twriteShort( 0 );\r\n\t\t\tsize = offset;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint shift = 48;\r\n\t\tboolean firstNode = (size > 2); // if this the first node in this tree level (0 can be the first node and are the end of the level)\r\n\t\twhile(shift>=0){\r\n\t\t\tint octet = (int)(value >> shift) & 0xFFFF;\r\n\t\t\twhile(true){\r\n\t\t\t\tint nextEntry = getUnsignedShort();\r\n\t\t\t\tif(nextEntry == octet){\r\n\t\t\t\t\tif(shift == 0) return; //value exist already, this case should not occur\r\n\t\t\t\t\toffset = getPointer();\r\n\t\t\t\t\tfirstNode = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif((nextEntry == 0 && !firstNode) || nextEntry > octet){\r\n\t\t\t\t\toffset -= 2;\r\n\t\t\t\t\twhile(true){\r\n\t\t\t\t\t\tif(shift != 0){\r\n\t\t\t\t\t\t\toffset = insertNode(octet);\t\t\t\t\t\t\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tinsertNodeLastLevel(octet);\t\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tshift -= 16;\r\n\t\t\t\t\t\toctet = (int)(value >> shift) & 0xFFFF;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t\tif(shift != 0) offset += pointerSize;\r\n\t\t\t}\r\n\t\t\tshift -= 16;\r\n\t\t}\r\n\t}","startLine":46,"lastLine":52}],"window":7},{"content":"try{rs.getString(\"v\");fail(\"SQLException 'No current row' should be throw\");}catch(SQLException ex){assertSQLException(\"01000\", 0, ex);}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestScrollable/testFirstWithWhereAssert(java.sql.ResultSet)","rawLines":"private void testFirstWithWhereAssert(ResultSet rs) throws Exception{\r\n        assertFalse( \"isFirst\", rs.isFirst() );\r\n        assertTrue( rs.isBeforeFirst() );\r\n        assertFalse( \"There should be no rows:\", rs.first());\r\n        assertFalse( \"isFirst\", rs.isFirst() );\r\n        assertTrue( rs.isBeforeFirst() );\r\n        try{\r\n            rs.getString(\"v\");\r\n            fail(\"SQLException 'No current row' should be throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n    }","startLine":6,"lastLine":12},{"locFile":"java+method:///smallsql/junit/TestScrollable/testPreviousWithWhereAssert(java.sql.ResultSet)","rawLines":"private void testPreviousWithWhereAssert(ResultSet rs) throws Exception{\r\n        assertTrue( rs.isBeforeFirst() );\r\n        assertTrue( rs.isAfterLast() );\r\n        rs.afterLast();\r\n        assertTrue( rs.isAfterLast() );\r\n        assertFalse(\"There should be no rows:\", rs.previous());\r\n        try{\r\n            rs.getString(\"v\");\r\n            fail(\"SQLException 'No current row' should be throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n    }","startLine":6,"lastLine":12}],"window":7},{"content":"}catch(Throwable e){con.rollback(savepoint);throw SmallSQLException.createFromException(e);}finally{if(con.getAutoCommit()) con.commit();}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Command/execute(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"final void execute(SSConnection con, SSStatement st) throws SQLException{\r\n    \tint savepoint = con.getSavepoint();\r\n        try{\r\n            executeImpl( con, st );\r\n        }catch(Throwable e){\r\n            con.rollback(savepoint);\r\n            throw SmallSQLException.createFromException(e);\r\n        }finally{\r\n            if(con.getAutoCommit()) con.commit();\r\n        }\r\n    }","startLine":4,"lastLine":10},{"locFile":"java+method:///smallsql/database/CommandSelect/deleteRow(smallsql.database.SSConnection)","rawLines":"final void deleteRow(SSConnection con) throws SQLException{\r\n\t\tint savepoint = con.getSavepoint();\r\n\t\ttry{\r\n\t\t\tif(tables.size() > 1)\r\n\t\t\t\tthrow SmallSQLException.create(Language.JOIN_DELETE);\r\n\t\t\tif(tables.size() == 0)\r\n\t\t\t\tthrow SmallSQLException.create(Language.DELETE_WO_FROM);\r\n\t\t\tTableViewResult.getTableViewResult( tables.get(0) ).deleteRow();\r\n\t\t}catch(Throwable e){\r\n\t\t\tcon.rollback(savepoint);\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}finally{\r\n\t\t\tif(con.getAutoCommit()) con.commit();\r\n\t\t}\r\n\t}","startLine":8,"lastLine":14},{"locFile":"java+method:///smallsql/database/CommandSelect/insertRow(smallsql.database.SSConnection,smallsql.database.Expression%5B%5D)","rawLines":"final void insertRow(SSConnection con, Expression[] newRowSources) throws SQLException{\r\n\t\tif(tables.size() > 1)\r\n\t\t\tthrow SmallSQLException.create(Language.JOIN_INSERT);\r\n\t\tif(tables.size() == 0)\r\n\t\t\tthrow SmallSQLException.create(Language.INSERT_WO_FROM);\r\n\t\t\r\n\t\tint savepoint = con.getSavepoint();\r\n\t\ttry{\r\n\t\t\tTableViewResult result = TableViewResult.getTableViewResult( tables.get(0) );\r\n\t\t\tTableView table = result.getTableView();\r\n\t\t\tColumns tabColumns = table.columns;\r\n\t\t\tint count = tabColumns.size();\r\n\t\t\t\t\t\r\n\t\t\t// order the new Values after it position in the table\r\n\t\t\tExpression[] updateValues = new Expression[count];\r\n\t\t\tif(newRowSources != null){\r\n\t\t\t\tfor(int i=0; i<columnExpressions.size(); i++){\r\n\t\t\t\t\tExpression src = newRowSources[i];\r\n\t\t\t\t\tif(src != null && (!(src instanceof ExpressionValue) || !((ExpressionValue)src).isEmpty())){\t\r\n\t\t\t\t\t\tExpression rsColumn = columnExpressions.get(i); // Column of the ResultSet\r\n\t\t\t\t\t\tif(!rsColumn.isDefinitelyWritable())\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.COL_READONLY, new Integer(i));\r\n\t\t\t\t\t\tExpressionName exp = (ExpressionName)rsColumn;\r\n\t\t\t\t\t\tif(table == exp.getTable()){\r\n\t\t\t\t\t\t\tupdateValues[exp.getColumnIndex()] = src;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdateValues[i] = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t// save the new values if there are new value for this table\r\n\t\t\tresult.insertRow(updateValues);\r\n\t\t}catch(Throwable e){\r\n\t\t\tcon.rollback(savepoint);\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}finally{\r\n\t\t\tif(con.getAutoCommit()) con.commit();\r\n\t\t}\r\n\t}","startLine":34,"lastLine":40},{"locFile":"java+method:///smallsql/database/CommandSelect/updateRow(smallsql.database.SSConnection,smallsql.database.Expression%5B%5D)","rawLines":"final void updateRow(SSConnection con, Expression[] newRowSources) throws SQLException{\r\n\t\tint savepoint = con.getSavepoint();\r\n\t\ttry{\r\n\t\t\t//loop through all tables of this ResultSet \r\n\t\t\tfor(int t=0; t<tables.size(); t++){\r\n\t\t\t\tTableViewResult result = TableViewResult.getTableViewResult( tables.get(t) );\r\n\t\t\t\tTableView table = result.getTableView();\r\n\t\t\t\tColumns tableColumns = table.columns;\r\n\t\t\t\tint count = tableColumns.size();\r\n\t\t\t\t\r\n\t\t\t\t// order the new Values after it position in the table\r\n\t\t\t\tExpression[] updateValues = new Expression[count];\r\n\t\t\t\tboolean isUpdateNeeded = false;\r\n\t\t\t\tfor(int i=0; i<columnExpressions.size(); i++){\r\n\t\t\t\t\tExpression src = newRowSources[i];\r\n\t\t\t\t\tif(src != null && (!(src instanceof ExpressionValue) || !((ExpressionValue)src).isEmpty())){\t\r\n\t\t\t\t\t\tExpression col = columnExpressions.get(i);\r\n\t\t\t\t\t\tif(!col.isDefinitelyWritable())\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.COL_READONLY, new Integer(i));\r\n\t\t\t\t\t\tExpressionName exp = (ExpressionName)col;\r\n\t\t\t\t\t\tif(table == exp.getTable()){\r\n\t\t\t\t\t\t\tupdateValues[exp.getColumnIndex()] = src;\r\n\t\t\t\t\t\t\tisUpdateNeeded = true;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// save the new values if there are new value for this table\r\n\t\t\t\tif(isUpdateNeeded){\r\n\t\t\t\t\tresult.updateRow(updateValues);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}catch(Throwable e){\r\n\t\t\tcon.rollback(savepoint);\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}finally{\r\n\t\t\tif(con.getAutoCommit()) con.commit();\r\n\t\t}\r\n\t}","startLine":33,"lastLine":39}],"window":7},{"content":"StringBuffer buf = new StringBuffer(bytes.length << 1);for(int i=0; i<bytes.length; i++){buf.append( digits[ (bytes[i] >> 4) & 0x0F ] );buf.append( digits[ (bytes[i]     ) & 0x0F ] );}return buf.toString();}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BasicTestCase/bytes2hex(byte%5B%5D)","rawLines":"private static String bytes2hex( byte[] bytes ){\r\n\t\tStringBuffer buf = new StringBuffer(bytes.length << 1);\r\n\t\tfor(int i=0; i<bytes.length; i++){\r\n\t\t\tbuf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n\t\t\tbuf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}","startLine":1,"lastLine":7},{"locFile":"java+method:///smallsql/database/Utils/bytes2hex(byte%5B%5D)","rawLines":"static String bytes2hex( byte[] bytes ){\r\n        StringBuffer buf = new StringBuffer(bytes.length << 1);\r\n        for(int i=0; i<bytes.length; i++){\r\n            buf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n            buf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n        }\r\n        return buf.toString();\r\n    }","startLine":1,"lastLine":7}],"window":7},{"content":"case SQLTokenizer.NUMERIC:case SQLTokenizer.DECIMAL:return readNumeric();case SQLTokenizer.CHAR:case SQLTokenizer.NCHAR:case SQLTokenizer.VARCHAR:case SQLTokenizer.NVARCHAR:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getObject(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getObject()\r\n     */\r\n    @Override\r\n    Object getObject(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n                    return Utils.getInteger( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return Utils.getInteger( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return Utils.getInteger(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue(readLong());\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME );\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE );\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":31,"lastLine":37},{"locFile":"java+method:///smallsql/database/StoreImpl/getNumeric(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBigDecimal()\r\n     */\r\n    @Override\r\n    MutableNumeric getNumeric(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":31,"lastLine":37}],"window":7},{"content":"case SQLTokenizer.COMMA:continue;default:throw new Error();}}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/expressionDefList(smallsql.database.Command,smallsql.database.Expressions,smallsql.database.Strings)","rawLines":"private void expressionDefList(Command cmd, Expressions expressions, Strings columns) throws SQLException{\r\n        SQLToken token = nextToken();\r\n        if(token.value != SQLTokenizer.PARENTHESIS_L) throw createSyntaxError(token, MISSING_PARENTHESIS_L );\r\n        Loop:\r\n        while(true){\r\n            int offset = token.offset + token.length;\r\n            token = nextToken();\r\n            if(token != null) offset = token.offset;\r\n            previousToken();  \r\n            \r\n            expressions.add( expression(cmd, 0) );\r\n            SQLToken last = lastToken();\r\n            int length = last.offset + last.length - offset;\r\n            columns.add( new String( sql, offset, length ) );\r\n\r\n            token = nextToken(MISSING_COMMA_PARENTHESIS);\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    break Loop;\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n                    throw new Error();\r\n            }\r\n        }\r\n    }","startLine":19,"lastLine":25},{"locFile":"java+method:///smallsql/database/SQLParser/expressionParenthesisList(smallsql.database.Command)","rawLines":"/**\r\n     * Read a Expression list in parenthesis like of VALUES() or functions. \r\n     * The left parenthesis is already consumed.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     * @see #expressionDefList\r\n     */ \r\n    private Expressions expressionParenthesisList(Command cmd) throws SQLException{\r\n\t\tExpressions list = new Expressions();\r\n\t\t{\r\n\t\t\tSQLToken token = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_R){\r\n\t\t\t\t// empty list like functions without parameters\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\t\t\tpreviousToken();\r\n\t\t}\r\n        while(true){\r\n            list.add( expression(cmd, 0) );\r\n            SQLToken token = nextToken(MISSING_COMMA_PARENTHESIS);\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    return list;\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n                    throw new Error();\r\n            }\r\n        }\r\n    }","startLine":23,"lastLine":29}],"window":7},{"content":"case SQLTokenizer.BIT:case SQLTokenizer.BOOLEAN:case SQLTokenizer.TINYINT:offset++;break;case SQLTokenizer.SMALLINT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":17,"lastLine":22},{"locFile":"java+method:///smallsql/database/StoreImpl/scanObjectOffsets(int%5B%5D,int%5B%5D)","rawLines":"@Override\r\n    void scanObjectOffsets( int[] offsets, int dataTypes[] ){\r\n        offset = PAGE_CONTROL_SIZE;\r\n        for(int i=0; i<offsets.length; i++){\r\n            offsets[i] = offset;\r\n            boolean isNull = readBoolean(); // for isNull\r\n            switch(dataTypes[i]){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                    int count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count;  // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    count = readByte();\r\n\t\t\t\t\toffset += 2;\r\n\t\t\t\t\tif(!isNull) offset += count*4;\r\n                    break;\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count << 1; // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                default: throw new Error(String.valueOf( dataTypes[i] ) );\r\n            }\r\n        }\r\n    }","startLine":7,"lastLine":12}],"window":6},{"content":"assertEquals(1,pr.executeUpdate());rs = pr.getGeneratedKeys();assertNotNull(\"RETURN_GENERATED_KEYS\", rs);assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));assertRowCount(1,rs);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":40,"lastLine":45},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":25,"lastLine":30},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":55,"lastLine":60}],"window":6},{"content":"wasNull = expr.isNull();return expr.getLong();}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getLong(int)","rawLines":"public long getLong(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getDouble(int)","rawLines":"public double getDouble(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getLong(int)","rawLines":"public long getLong(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8}],"window":6},{"content":"oldValue = newValue;count++;}rs.close();assertEquals( valueCount, count );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_char()","rawLines":"public void testOrderBy_char() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by c\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"c\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":25},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_asc()","rawLines":"public void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":25}],"window":6},{"content":"wasNull = obj == null;return obj;}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBytes(int)","rawLines":"public byte[] getBytes(int i) throws SQLException {\r\n        try{\r\n            byte[] obj = getValue(i).getBytes();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getString(int)","rawLines":"public String getString(int i) throws SQLException {\r\n        try{\r\n            String obj = getValue(i).getString();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getObject(int)","rawLines":"public Object getObject(int i) throws SQLException {\r\n        try{\r\n            Object obj = getValue(i).getObject();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getBytes(int)","rawLines":"public byte[] getBytes(int columnIndex) throws SQLException {\r\n        try{\r\n            byte[] obj = getValue(columnIndex).getBytes();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getObject(int)","rawLines":"public Object getObject(int columnIndex) throws SQLException {\r\n        try{\r\n            Object obj = getValue(columnIndex).getApiObject();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8}],"window":6},{"content":"public void runTest() throws Exception{Connection con = AllTests.getConnection();Statement st = con.createStatement();ResultSet rs;rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");assertFalse( \"To many rows\", rs.next() );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestJoins/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        assertRowCount( 7, \"Select * from \" + table);\r\n        assertRowCount( 49, \"Select * from \" + table + \" t1, \" + table2 + \" t2\");\r\n        assertRowCount( 0, \"Select * from \" + table + \", \" + table3);\r\n        assertRowCount( 49, \"Select * from (\"+ table +\"), \" + table2);\r\n        assertRowCount( 49, \"Select * from \" + table + \" Cross Join \" + table2);\r\n        assertRowCount( 13, \"Select * from \" + table + \" INNER JOIN \" + table2 + \" ON \" + table + \".a = \" + table2 + \".c\");\r\n        assertRowCount( 13, \"Select * from \" + table + \"       JOIN \" + table2 + \" ON \" + table2 + \".c = \" + table + \".a\");\r\n        assertRowCount( 13, \"Select * from {oj \" + table + \" INNER JOIN \" + table2 + \" ON \" + table + \".a = \" + table2 + \".c}\");\r\n        assertRowCount( 13, \"Select * from \" + table + \" AS t1 INNER JOIN \" + table2 + \" t2 ON t1.a = t2.c\");\r\n        assertRowCount( 13, \"Select * from {oj \" + table + \" t1 INNER JOIN \" + table2 + \" t2 ON t1.a = t2.c}\");\r\n        assertRowCount( 4, \"Select * from \" + table + \" t1 INNER JOIN \" + table2 + \" t2 ON t1.a = t2.c and t1.b=t2.d\");\r\n        assertRowCount( 4, \"Select * from \" + table + \" t1       JOIN \" + table2 + \" t2 ON t1.a = t2.c and t2.d=t1.b\");\r\n        assertRowCount( 7, \"Select * from \" + table + \" t1 LEFT OUTER JOIN \" + table2 + \" t2 ON t1.a = t2.c and t1.b=t2.d\");\r\n        assertRowCount( 7, \"Select * from \" + table + \" t1 LEFT       JOIN \" + table2 + \" t2 ON t1.a = t2.c and t1.b=t2.d\");\r\n        assertRowCount( 15, \"Select * from \" + table + \" t1 LEFT OUTER JOIN \" + table2 + \" t2 ON t1.a = t2.c\");\r\n        assertRowCount( 7, \"Select * from \" + table + \" t1 LEFT OUTER JOIN \" + table3 + \" t2 ON t1.a = t2.c\");\r\n        assertRowCount( 7, \"Select * from \" + table + \" t1 RIGHT OUTER JOIN \" + table2 + \" t2 ON t1.a = t2.c and t1.b=t2.d\");\r\n        assertRowCount( 7, \"Select * from \" + table + \" t1 RIGHT OUTER JOIN \" + table2 + \" t2 ON false\");\r\n        assertRowCount( 15, \"Select * from \" + table + \" t1 RIGHT OUTER JOIN \" + table2 + \" t2 ON t1.a = t2.c\");\r\n        assertRowCount( 0, \"Select * from \" + table + \" t1 RIGHT OUTER JOIN \" + table3 + \" t2 ON t1.a = t2.c\");\r\n        assertRowCount( 14, \"Select * from \" + table + \" t1 FULL OUTER JOIN \" + table2 + \" t2 ON 1=0\");\r\n        assertRowCount( 17, \"Select * from \" + table + \" t1 FULL OUTER JOIN \" + table2 + \" t2 ON t1.a = t2.c\");\r\n\t\tassertRowCount( 7, \"Select * from \" + table + \" t1 FULL OUTER JOIN \" + table3 + \" t2 ON t1.a = t2.c\");\r\n\t\tassertRowCount( 7, \"Select * from \" + table3 + \" t1 FULL OUTER JOIN \" + table + \" t2 ON t1.c = t2.a\");\r\n        assertRowCount( 5, \"Select * from \" + table + \" INNER JOIN (SELECT DISTINCT c FROM \" + table2 + \") t1 ON \" + table + \".a = t1.c\");\r\n        \r\n        st.close();\r\n    }","startLine":0,"lastLine":6},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":0,"lastLine":6}],"window":6},{"content":"byte[] buffer = new byte[length];System.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );return buffer;}return bytes;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionConvert/getObject()","rawLines":"Object getObject() throws Exception {\r\n\t\tif(param1.isNull()) return null;\r\n\t\tfinal int dataType = getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\treturn convertToString();\r\n\t\t\tcase SQLTokenizer.VARCHAR:{\r\n\t\t\t\tString str = convertToString();\r\n\t\t\t\tint length = datatype.getDisplaySize();\r\n\t\t\t\tif(length > str.length())\r\n\t\t\t\t\treturn str;\r\n\t\t\t\treturn str.substring(0,length);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.CHAR:{\r\n\t\t\t\tString str = convertToString();\r\n\t\t\t\tint length = datatype.getDisplaySize();\r\n\t\t\t\tif(length > str.length()){\r\n\t\t\t\t\tchar[] buffer = new char[length-str.length()];\r\n\t\t\t\t\tArrays.fill(buffer, ' ');\r\n\t\t\t\t\treturn str + new String(buffer);\r\n\t\t\t\t}\r\n\t\t\t\treturn str.substring(0,length);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn param1.getBytes();\r\n\t\t\tcase SQLTokenizer.VARBINARY:{\r\n\t\t\t\tbyte[] bytes = param1.getBytes();\r\n\t\t\t\tint length = datatype.getPrecision();\r\n\t\t\t\tif(length < bytes.length){\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}\r\n\t\t\t\treturn bytes;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.BINARY:{\r\n\t\t\t\tbyte[] bytes = param1.getBytes();\r\n\t\t\t\tint length = datatype.getPrecision();\r\n\t\t\t\tif(length != bytes.length){\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}\r\n\t\t\t\treturn bytes;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn param1.getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn Utils.getInteger(param1.getInt() & 0xFF);\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn Utils.getInteger((short)param1.getInt());\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn Utils.getInteger(param1.getInt());\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\treturn new Long(param1.getLong());\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn new Float(param1.getFloat());\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn new Double(param1.getDouble());\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getDateTimeLong(), dataType );\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tMutableNumeric num = param1.getNumeric();\r\n\t\t\t\tif(num != null && (dataType == SQLTokenizer.NUMERIC || dataType == SQLTokenizer.DECIMAL))\r\n\t\t\t\t\tnum.setScale(getScale());\r\n\t\t\t\treturn num;\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn Money.createFromUnscaledValue(param1.getMoney());\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\tswitch(param1.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\treturn Utils.bytes2unique( Utils.unique2bytes(param1.getString()), 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn Utils.bytes2unique(param1.getBytes(), 0);\r\n\t\t}\r\n\t\tObject[] param = { SQLTokenizer.getKeyWord(dataType) };\r\n\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_CONV, param);\r\n\t}","startLine":40,"lastLine":46},{"locFile":"java+method:///smallsql/database/ExpressionFunctionConvert/getObject()","rawLines":"Object getObject() throws Exception {\r\n\t\tif(param1.isNull()) return null;\r\n\t\tfinal int dataType = getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\treturn convertToString();\r\n\t\t\tcase SQLTokenizer.VARCHAR:{\r\n\t\t\t\tString str = convertToString();\r\n\t\t\t\tint length = datatype.getDisplaySize();\r\n\t\t\t\tif(length > str.length())\r\n\t\t\t\t\treturn str;\r\n\t\t\t\treturn str.substring(0,length);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.CHAR:{\r\n\t\t\t\tString str = convertToString();\r\n\t\t\t\tint length = datatype.getDisplaySize();\r\n\t\t\t\tif(length > str.length()){\r\n\t\t\t\t\tchar[] buffer = new char[length-str.length()];\r\n\t\t\t\t\tArrays.fill(buffer, ' ');\r\n\t\t\t\t\treturn str + new String(buffer);\r\n\t\t\t\t}\r\n\t\t\t\treturn str.substring(0,length);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn param1.getBytes();\r\n\t\t\tcase SQLTokenizer.VARBINARY:{\r\n\t\t\t\tbyte[] bytes = param1.getBytes();\r\n\t\t\t\tint length = datatype.getPrecision();\r\n\t\t\t\tif(length < bytes.length){\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}\r\n\t\t\t\treturn bytes;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.BINARY:{\r\n\t\t\t\tbyte[] bytes = param1.getBytes();\r\n\t\t\t\tint length = datatype.getPrecision();\r\n\t\t\t\tif(length != bytes.length){\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}\r\n\t\t\t\treturn bytes;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn param1.getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn Utils.getInteger(param1.getInt() & 0xFF);\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn Utils.getInteger((short)param1.getInt());\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn Utils.getInteger(param1.getInt());\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\treturn new Long(param1.getLong());\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn new Float(param1.getFloat());\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn new Double(param1.getDouble());\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getDateTimeLong(), dataType );\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tMutableNumeric num = param1.getNumeric();\r\n\t\t\t\tif(num != null && (dataType == SQLTokenizer.NUMERIC || dataType == SQLTokenizer.DECIMAL))\r\n\t\t\t\t\tnum.setScale(getScale());\r\n\t\t\t\treturn num;\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn Money.createFromUnscaledValue(param1.getMoney());\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\tswitch(param1.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\treturn Utils.bytes2unique( Utils.unique2bytes(param1.getString()), 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn Utils.bytes2unique(param1.getBytes(), 0);\r\n\t\t}\r\n\t\tObject[] param = { SQLTokenizer.getKeyWord(dataType) };\r\n\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_CONV, param);\r\n\t}","startLine":29,"lastLine":35}],"window":6},{"content":"if(num.scale < scale){num.setScale(scale);}elseif(num.scale > scale){setScale(num.scale);}","cloneLocs":[{"locFile":"java+method:///smallsql/database/MutableNumeric/sub(smallsql.database.MutableNumeric)","rawLines":"/**\r\n     * Subtract the value to the current MutableNumeric Object and change it.\r\n     * @param num the subtracted  value\r\n     */\r\n    void sub(MutableNumeric num){\r\n\t\tif(num.scale < scale){\r\n\t\t\tnum.setScale(scale);\r\n\t\t}else\r\n\t\tif(num.scale > scale){\r\n\t\t\tsetScale(num.scale);\r\n\t\t}\r\n        add( -num.signum, num.value );\r\n    }","startLine":5,"lastLine":10},{"locFile":"java+method:///smallsql/database/MutableNumeric/add(smallsql.database.MutableNumeric)","rawLines":"/**\r\n     * Add the value to the current MutableNumeric Object and change it.\r\n     * @param num the added value\r\n     */\r\n    void add(MutableNumeric num){\r\n\t\tif(num.scale < scale){\r\n\t\t\tnum.setScale(scale);\r\n\t\t}else\r\n\t\tif(num.scale > scale){\r\n\t\t\tsetScale(num.scale);\r\n\t\t}\r\n        add( num.signum, num.value );\r\n    }","startLine":5,"lastLine":10}],"window":6},{"content":"keyColumnNames.add(column.getName());keys.add(valueExpress.getObject());break;}}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/CommandInsert/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception {\r\n        // on first time and on change of the table we need to recompile\r\n        if(table == null || tableTimestamp != table.getTimestamp()) compile( con );\r\n\r\n\t\tfinal IndexDescriptions indexes = table.indexes;\r\n\t\t\r\n\t\tupdateCount = 0;\r\n\t\tcmdSel.from.execute();\r\n\t\tcmdSel.beforeFirst();\r\n        \r\n        //Variables for GeneratedKeys\r\n        Strings keyColumnNames = null;\r\n        ArrayList keys = null;\r\n        boolean needGeneratedKeys = st.needGeneratedKeys();\r\n        int generatedKeysType = 0;\r\n\r\n        while(cmdSel.next()){\r\n            if(needGeneratedKeys){\r\n                keyColumnNames = new Strings();\r\n                keys = new ArrayList();\r\n                if(st.getGeneratedKeyNames() != null)\r\n                    generatedKeysType = 1;\r\n                if(st.getGeneratedKeyIndexes() != null)\r\n                    generatedKeysType = 2;\r\n            }\r\n\t        StoreImpl store = table.getStoreInsert( con );\r\n\t        for(int c=0; c<matrix.length; c++){\r\n\t            Column column = table.columns.get(c);\r\n\t            int idx = matrix[c];\r\n\t            Expression valueExpress;\r\n                if(idx >= 0){\r\n                    valueExpress = cmdSel.columnExpressions.get(idx);\r\n                }else{\r\n                    valueExpress = column.getDefaultValue(con);\r\n                    if(needGeneratedKeys && generatedKeysType == 0 && valueExpress != Expression.NULL){\r\n                        keyColumnNames.add(column.getName());\r\n                        keys.add(valueExpress.getObject());\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 1){\r\n                    String[] keyNames = st.getGeneratedKeyNames();\r\n                    for(int i=0; i<keyNames.length; i++){\r\n                        if(column.getName().equalsIgnoreCase(keyNames[i])){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 2){\r\n                    int[] keyIndexes = st.getGeneratedKeyIndexes();\r\n                    for(int i=0; i<keyIndexes.length; i++){\r\n                        if(c+1 == keyIndexes[i]){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\t            store.writeExpression( valueExpress, column );\r\n\t\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\t\tindexes.get(i).writeExpression( c, valueExpress );\r\n\t\t\t\t}\r\n\t        }\r\n\t        store.writeFinsh( con );\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tindexes.get(i).writeFinish( con );\r\n\t\t\t}\r\n\t        updateCount++;\r\n            if(needGeneratedKeys){\r\n                Object[][] data = new Object[1][keys.size()];\r\n                keys.toArray(data[0]);\r\n                st.setGeneratedKeys(new SSResultSet( st, Utils.createMemoryCommandSelect( con, keyColumnNames.toArray(), data)));\r\n            }\r\n        }\r\n    }","startLine":53,"lastLine":58},{"locFile":"java+method:///smallsql/database/CommandInsert/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception {\r\n        // on first time and on change of the table we need to recompile\r\n        if(table == null || tableTimestamp != table.getTimestamp()) compile( con );\r\n\r\n\t\tfinal IndexDescriptions indexes = table.indexes;\r\n\t\t\r\n\t\tupdateCount = 0;\r\n\t\tcmdSel.from.execute();\r\n\t\tcmdSel.beforeFirst();\r\n        \r\n        //Variables for GeneratedKeys\r\n        Strings keyColumnNames = null;\r\n        ArrayList keys = null;\r\n        boolean needGeneratedKeys = st.needGeneratedKeys();\r\n        int generatedKeysType = 0;\r\n\r\n        while(cmdSel.next()){\r\n            if(needGeneratedKeys){\r\n                keyColumnNames = new Strings();\r\n                keys = new ArrayList();\r\n                if(st.getGeneratedKeyNames() != null)\r\n                    generatedKeysType = 1;\r\n                if(st.getGeneratedKeyIndexes() != null)\r\n                    generatedKeysType = 2;\r\n            }\r\n\t        StoreImpl store = table.getStoreInsert( con );\r\n\t        for(int c=0; c<matrix.length; c++){\r\n\t            Column column = table.columns.get(c);\r\n\t            int idx = matrix[c];\r\n\t            Expression valueExpress;\r\n                if(idx >= 0){\r\n                    valueExpress = cmdSel.columnExpressions.get(idx);\r\n                }else{\r\n                    valueExpress = column.getDefaultValue(con);\r\n                    if(needGeneratedKeys && generatedKeysType == 0 && valueExpress != Expression.NULL){\r\n                        keyColumnNames.add(column.getName());\r\n                        keys.add(valueExpress.getObject());\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 1){\r\n                    String[] keyNames = st.getGeneratedKeyNames();\r\n                    for(int i=0; i<keyNames.length; i++){\r\n                        if(column.getName().equalsIgnoreCase(keyNames[i])){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 2){\r\n                    int[] keyIndexes = st.getGeneratedKeyIndexes();\r\n                    for(int i=0; i<keyIndexes.length; i++){\r\n                        if(c+1 == keyIndexes[i]){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\t            store.writeExpression( valueExpress, column );\r\n\t\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\t\tindexes.get(i).writeExpression( c, valueExpress );\r\n\t\t\t\t}\r\n\t        }\r\n\t        store.writeFinsh( con );\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tindexes.get(i).writeFinish( con );\r\n\t\t\t}\r\n\t        updateCount++;\r\n            if(needGeneratedKeys){\r\n                Object[][] data = new Object[1][keys.size()];\r\n                keys.toArray(data[0]);\r\n                st.setGeneratedKeys(new SSResultSet( st, Utils.createMemoryCommandSelect( con, keyColumnNames.toArray(), data)));\r\n            }\r\n        }\r\n    }","startLine":43,"lastLine":48}],"window":6},{"content":"con1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");assertRowCount( 0, \"Select * from transactions\");con1.setAutoCommit(false);con1.createStatement().execute(\"Insert Into transactions(v) Values('qwert2')\");ResultSet rs2 = con2.createStatement().executeQuery(\"Select count(*) from transactions\");assertTrue( rs2.next() );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testReadCommited()","rawLines":"public void testReadCommited() throws Exception{\r\n\t\tConnection con1 = AllTests.getConnection();\r\n\t\tConnection con2 = AllTests.createConnection();\r\n\t\ttry{\t\t\r\n\t\t\tcon2.setTransactionIsolation( Connection.TRANSACTION_READ_COMMITTED );\r\n\t\t\tcon1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon1.setAutoCommit(false);\r\n\t\t\tcon1.createStatement().execute(\"Insert Into transactions(v) Values('qwert2')\");\r\n\r\n\t\t\tResultSet rs2 = con2.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n\t\t\tassertTrue( rs2.next() );\r\n\t\t\tassertEquals( 0, rs2.getInt(1) );\r\n\t\t}finally{\r\n            dropTable(con1, \"transactions\");\r\n\t\t\tcon1.setAutoCommit(true);\r\n\t\t\tcon2.close();\r\n\t\t}\r\n\t}","startLine":5,"lastLine":12},{"locFile":"java+method:///smallsql/junit/TestTransactions/testReadUncommited()","rawLines":"public void testReadUncommited() throws Exception{\r\n\t\tConnection con1 = AllTests.getConnection();\r\n\t\tConnection con2 = AllTests.createConnection();\r\n\t\ttry{\t\t\r\n\t\t\tcon2.setTransactionIsolation( Connection.TRANSACTION_READ_UNCOMMITTED );\r\n\t\t\tcon1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon1.setAutoCommit(false);\r\n\t\t\tcon1.createStatement().execute(\"Insert Into transactions(v) Values('qwert2')\");\r\n\r\n\t\t\tResultSet rs2 = con2.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n\t\t\tassertTrue( rs2.next() );\r\n\t\t\tassertEquals( 1, rs2.getInt(1) );\r\n\t\t}finally{\r\n\t\t    dropTable(con1, \"transactions\");\r\n\t\t\tcon1.setAutoCommit(true);\r\n\t\t\tcon2.close();\r\n\t\t}\r\n\t}","startLine":5,"lastLine":12}],"window":6},{"content":"try{con.createStatement().execute(\"Drop Table transactions\");}catch(Throwable e){e.printStackTrace();}con.setAutoCommit(true);}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testCommitWithOneCommitRow()","rawLines":"/**\r\n\t * In the table there is already one row that is committed.\r\n\t */\r\n\tpublic void testCommitWithOneCommitRow() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions (Select * From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":23,"lastLine":28},{"locFile":"java+method:///smallsql/junit/TestTransactions/testCommit()","rawLines":"public void testCommit() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions Select * From transactions\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":20,"lastLine":25},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_withWrongWhere()","rawLines":"/**\r\n     * If there was insert a row within the ResultSet that not map WHERE than you scroll to this row. If there an Insert\r\n     * outsite the ResultSet that not map the WHERE then you can't scroll this row.\r\n     * \r\n     * @throws Exception\r\n     */\r\n\tpublic void testInsertRow_withWrongWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":27,"lastLine":32},{"locFile":"java+method:///smallsql/junit/TestTransactions/testRollback()","rawLines":"public void testRollback() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t    con.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) (Select v From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.rollback();\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":20,"lastLine":25},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertAndUpdate()","rawLines":"/**\r\n     * Insert a row and update the inserted row in the same transaction. Then make a partial rollback. Test the correct\r\n     * status after of the table after every change of the database.\r\n     * \r\n     * @throws Exception\r\n     *             if an error occur\r\n     */\r\n\tpublic void testInsertAndUpdate() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions ( v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Insert Into transactions(v) Values('qwert')\") );\r\n\t\t\tassertEqualsRsValue(\"qwert\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t\t\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert1'\") );\r\n\t\t\tassertEqualsRsValue(\"qwert1\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t\t\r\n            assertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert2'\") );\r\n            assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n            \r\n\t\t\tSavepoint savepoint = con.setSavepoint();\r\n\t\t\t\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 3'\") );\r\n\t\t\tassertEqualsRsValue(\"qwert 3\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n\t\t\tcon.rollback( savepoint );\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":38,"lastLine":43},{"locFile":"java+method:///smallsql/junit/TestTransactions/testCreateTable()","rawLines":"public void testCreateTable() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n        Connection con2 = AllTests.createConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"create table transactions (ID  INTEGER NOT NULL, Name VARCHAR(100), FirstName VARCHAR(100), Points INTEGER, LicenseID INTEGER, PRIMARY KEY(ID))\");\r\n\t\t\tcon.commit();\r\n\r\n\t\t\tcon2.setAutoCommit(false);\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con2.prepareStatement(\"insert into transactions (id,Name,FirstName,Points,LicenseID) values (?,?,?,?,?)\");\r\n\t\t\tpr.setInt( \t\t1, 0 );\r\n\t\t\tpr.setString( \t2, \"Pilot_1\" );\r\n\t\t\tpr.setString( \t3, \"Herkules\" );\r\n\t\t\tpr.setInt( \t\t4, 1 );\r\n\t\t\tpr.setInt( \t\t5, 1 );\r\n\t\t\tpr.addBatch();\r\n\t\t\tpr.executeBatch();\r\n\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\t\t\tcon2.commit();\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n            con2.close();\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":26,"lastLine":31},{"locFile":"java+method:///smallsql/junit/TestTransactions/testRollbackWithOneCommitRow()","rawLines":"/**\r\n\t * In the table there is already one row that is commited.\r\n\t */\r\n\tpublic void testRollbackWithOneCommitRow() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) (Select v From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.rollback();\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":23,"lastLine":28}],"window":6},{"content":"wasNull = expr.isNull();return expr.getBoolean();}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getBoolean(int)","rawLines":"public boolean getBoolean(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getBoolean();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBoolean(int)","rawLines":"public boolean getBoolean(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getBoolean();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8}],"window":6},{"content":"}finally{dropTable(con1, \"transactions\");con1.setAutoCommit(true);con2.close();}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testReadUncommited()","rawLines":"public void testReadUncommited() throws Exception{\r\n\t\tConnection con1 = AllTests.getConnection();\r\n\t\tConnection con2 = AllTests.createConnection();\r\n\t\ttry{\t\t\r\n\t\t\tcon2.setTransactionIsolation( Connection.TRANSACTION_READ_UNCOMMITTED );\r\n\t\t\tcon1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon1.setAutoCommit(false);\r\n\t\t\tcon1.createStatement().execute(\"Insert Into transactions(v) Values('qwert2')\");\r\n\r\n\t\t\tResultSet rs2 = con2.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n\t\t\tassertTrue( rs2.next() );\r\n\t\t\tassertEquals( 1, rs2.getInt(1) );\r\n\t\t}finally{\r\n\t\t    dropTable(con1, \"transactions\");\r\n\t\t\tcon1.setAutoCommit(true);\r\n\t\t\tcon2.close();\r\n\t\t}\r\n\t}","startLine":14,"lastLine":19},{"locFile":"java+method:///smallsql/junit/TestTransactions/testReadCommited()","rawLines":"public void testReadCommited() throws Exception{\r\n\t\tConnection con1 = AllTests.getConnection();\r\n\t\tConnection con2 = AllTests.createConnection();\r\n\t\ttry{\t\t\r\n\t\t\tcon2.setTransactionIsolation( Connection.TRANSACTION_READ_COMMITTED );\r\n\t\t\tcon1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon1.setAutoCommit(false);\r\n\t\t\tcon1.createStatement().execute(\"Insert Into transactions(v) Values('qwert2')\");\r\n\r\n\t\t\tResultSet rs2 = con2.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n\t\t\tassertTrue( rs2.next() );\r\n\t\t\tassertEquals( 0, rs2.getInt(1) );\r\n\t\t}finally{\r\n            dropTable(con1, \"transactions\");\r\n\t\t\tcon1.setAutoCommit(true);\r\n\t\t\tcon2.close();\r\n\t\t}\r\n\t}","startLine":14,"lastLine":19}],"window":6},{"content":"formatNumber( details.hour, 2, buf);buf.append(':');formatNumber( details.minute, 2, buf);buf.append(':');formatNumber( details.second, 2, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":219,"lastLine":224},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":124,"lastLine":129}],"window":6},{"content":"formatNumber( details.day, 2, buf);buf.append(' ');buf.append( SHORT_MONTHS[ details.month ]);buf.append(' ');formatNumber( details.year, 4, buf);buf.append(' ');","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":187,"lastLine":192},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":258,"lastLine":263}],"window":6},{"content":"rs.beforeFirst();assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );assertFalse(\"isAfterLast\", rs.isAfterLast() );assertEquals(\"getRow\", 0, rs.getRow() );assertTrue(\"next\", rs.next() );assertTrue(\"isFirst\", rs.isFirst() );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestResultSet/testScrollStatesGroupBy()","rawLines":"public void testScrollStatesGroupBy() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs = st.executeQuery(\"Select i,max(c) From ResultSet Group By i HAVING i=1\");\r\n        \r\n        assertEquals(\"getConcurrency\",ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        \r\n        rs.beforeFirst();\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        assertTrue(\"next\", rs.next() );\r\n        assertTrue(\"isFirst\", rs.isFirst() );\r\n        assertFalse(\"rowInserted\", rs.rowInserted() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        assertTrue(\"isLast\", rs.isLast() );\r\n        assertFalse(\"next\", rs.next() );\r\n        assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        \r\n        assertTrue(\"first\", rs.first() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        \r\n        assertFalse(\"previous\", rs.previous() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        \r\n        assertTrue(\"last\", rs.last() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        assertTrue(\"isLast\", rs.isLast() );\r\n        \r\n        rs.afterLast();\r\n        assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n    }","startLine":10,"lastLine":15},{"locFile":"java+method:///smallsql/junit/TestResultSet/testScrollStates()","rawLines":"public void testScrollStates() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs = st.executeQuery(\"Select * From ResultSet Where 1=0\");\r\n        \r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        \r\n        rs.moveToInsertRow();\r\n        rs.insertRow();\r\n        \r\n        rs.beforeFirst();\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        assertTrue(\"next\", rs.next() );\r\n        assertTrue(\"isFirst\", rs.isFirst() );\r\n        assertTrue(\"rowInserted\", rs.rowInserted() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        assertTrue(\"isLast\", rs.isLast() );\r\n        assertFalse(\"next\", rs.next() );\r\n        assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        \r\n        assertTrue(\"first\", rs.first() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        \r\n        assertFalse(\"previous\", rs.previous() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n        assertTrue(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertFalse(\"isAfterLast\", rs.isAfterLast() );\r\n        \r\n        assertTrue(\"last\", rs.last() );\r\n        assertEquals(\"getRow\", 1, rs.getRow() );\r\n        assertTrue(\"isLast\", rs.isLast() );\r\n        \r\n        rs.afterLast();\r\n        assertFalse(\"isBeforeFirst\", rs.isBeforeFirst() );\r\n        assertTrue(\"isAfterLast\", rs.isAfterLast() );\r\n        assertEquals(\"getRow\", 0, rs.getRow() );\r\n    }","startLine":12,"lastLine":17}],"window":6},{"content":"case SQLTokenizer.FLOAT:case SQLTokenizer.DOUBLE:case SQLTokenizer.MONEY:case SQLTokenizer.SMALLMONEY:case SQLTokenizer.NUMERIC:case SQLTokenizer.DECIMAL:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getDouble()","rawLines":"double getDouble() throws java.lang.Exception {\r\n        if(isNull()) return 0;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return getDoubleImpl();\r\n        }\r\n\t\tthrow createUnspportedConversion( SQLTokenizer.DOUBLE);\r\n    }","startLine":15,"lastLine":20},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getInt()","rawLines":"int getInt() throws java.lang.Exception {\r\n        if(isNull()) return 0;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return (int)getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return (int)getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t// FIXME: bug! if get returns a number outside of\r\n            \t// integer interval, it's not rounded to max/min, \r\n            \t// instead it returns a wrong value\r\n                return (int)getDoubleImpl();\r\n        }\r\n        throw createUnspportedConversion( SQLTokenizer.INT);\r\n    }","startLine":15,"lastLine":20},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getLong()","rawLines":"long getLong() throws java.lang.Exception {\r\n        if(isNull()) return 0;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return (long)getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return (long)getDoubleImpl();\r\n        }\r\n\t\tthrow createUnspportedConversion( SQLTokenizer.LONG);\r\n    }","startLine":15,"lastLine":20},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getFloat()","rawLines":"float getFloat() throws java.lang.Exception {\r\n        if(isNull()) return 0;\r\n        int dataType = getDataType();\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return (float)getDoubleImpl();\r\n        }\r\n\t\tthrow createUnspportedConversion( SQLTokenizer.DOUBLE);\r\n    }","startLine":15,"lastLine":20}],"window":6},{"content":"}}Object[][] result = new Object[rows.size()][];rows.toArray(result);return result;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Database/getBestRowIdentifier(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getBestRowIdentifier(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isUnique()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tString columnName = columns.get(c);\r\n\t\t\t\t\t\tColumn column = tab.findColumn(columnName);\r\n\t\t\t\t\t\tObject[] row = new Object[8];\r\n\t\t\t\t\t\trow[0] = Utils.getShort(DatabaseMetaData.bestRowSession);//SCOPE\r\n\t\t\t\t\t\trow[1] = columnName;\t\t\t//COLUMN_NAME\r\n\t\t\t\t\t\tfinal int dataType = column.getDataType();\r\n\t\t\t\t\t\trow[2] = Utils.getInteger(dataType);//DATA_TYPE\r\n\t\t\t\t\t\trow[3] = SQLTokenizer.getKeyWord(dataType);//TYPE_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getInteger(column.getPrecision());\t//COLUMN_SIZE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//BUFFER_LENGTH\r\n\t\t\t\t\t\trow[6] = Utils.getShort(column.getScale());\t\t//DECIMAL_DIGITS\r\n\t\t\t\t\t\trow[7] = Utils.getShort(DatabaseMetaData.bestRowNotPseudo);//PSEUDO_COLUMN\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":28,"lastLine":33},{"locFile":"java+method:///smallsql/database/Database/getIndexInfo(smallsql.database.SSConnection,java.lang.String,boolean)","rawLines":"Object[][] getIndexInfo( SSConnection con, String table, boolean unique) throws SQLException {\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tShort type = Utils.getShort( DatabaseMetaData.tableIndexOther );\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\tObject[] row = new Object[13];\r\n\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\trow[3] = Boolean.valueOf(!index.isUnique());//NON_UNIQUE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//INDEX_QUALIFIER\r\n\t\t\t\t\trow[5] = index.getName();\t\t//INDEX_NAME\r\n\t\t\t\t\trow[6] = type;\t\t\t\t\t//TYPE\r\n\t\t\t\t\trow[7] = Utils.getShort(c+1);\t//ORDINAL_POSITION\r\n\t\t\t\t\trow[8] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//ASC_OR_DESC\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//CARDINALITY\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//PAGES\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//FILTER_CONDITION\r\n\t\t\t\t\trows.add(row);\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\r\n\t}","startLine":29,"lastLine":34},{"locFile":"java+method:///smallsql/database/Database/getReferenceKeys(smallsql.database.SSConnection,java.lang.String,java.lang.String)","rawLines":"Object[][] getReferenceKeys(SSConnection con, String pkTable, String fkTable) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = (pkTable != null) ? getTables(pkTable) : getTables(fkTable);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tForeignKeys references = ((Table)tab).references;\r\n\t\t\tfor(int i=0; i<references.size(); i++){\r\n\t\t\t\tForeignKey foreignKey = references.get(i);\r\n\t\t\t\tIndexDescription pk = foreignKey.pk;\r\n\t\t\t\tIndexDescription fk = foreignKey.fk;\r\n\t\t\t\tif((pkTable == null || pkTable.equals(foreignKey.pkTable)) &&\r\n\t\t\t\t   (fkTable == null || fkTable.equals(foreignKey.fkTable))){\r\n\t\t\t\t\tStrings columnsPk = pk.getColumns();\r\n\t\t\t\t\tStrings columnsFk = fk.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columnsPk.size(); c++){\r\n\t\t\t\t\t\tObject[] row = new Object[14];\r\n\t\t\t\t\t\trow[0] = getName();\t\t\t\t//PKTABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//PKTABLE_SCHEM\r\n\t\t\t\t\t\trow[2] = foreignKey.pkTable;\t//PKTABLE_NAME\r\n\t\t\t\t\t\trow[3] = columnsPk.get(c);\t\t//PKCOLUMN_NAME\r\n\t\t\t\t\t\trow[4] = getName();\t\t\t\t//FKTABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//FKTABLE_SCHEM\r\n\t\t\t\t\t\trow[6] = foreignKey.fkTable;\t//FKTABLE_NAME\r\n\t\t\t\t\t\trow[7] = columnsFk.get(c);\t\t//FKCOLUMN_NAME\r\n\t\t\t\t\t\trow[8] = Utils.getShort(c+1);\t//KEY_SEQ\r\n\t\t\t\t\t\trow[9] = Utils.getShort(foreignKey.updateRule);//UPDATE_RULE\r\n\t\t\t\t\t\trow[10]= Utils.getShort(foreignKey.deleteRule); //DELETE_RULE\r\n\t\t\t\t\t\trow[11]= fk.getName();\t//FK_NAME\r\n\t\t\t\t\t\trow[12]= pk.getName();\t//PK_NAME\r\n\t\t\t\t\t\trow[13]= Utils.getShort(DatabaseMetaData.importedKeyNotDeferrable); //DEFERRABILITY\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":35,"lastLine":40},{"locFile":"java+method:///smallsql/database/Database/getPrimaryKeys(smallsql.database.SSConnection,java.lang.String)","rawLines":"Object[][] getPrimaryKeys(SSConnection con, String table) throws SQLException{\r\n\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isPrimary()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tObject[] row = new Object[6];\r\n\t\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\t\trow[3] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getShort(c+1);\t//KEY_SEQ\r\n\t\t\t\t\t\trow[5] = index.getName();\t\t//PK_NAME\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\t\t\r\n\t}","startLine":23,"lastLine":28},{"locFile":"java+method:///smallsql/database/Database/getColumns(smallsql.database.SSConnection,java.lang.String,java.lang.String)","rawLines":"Object[][] getColumns( SSConnection con, String tablePattern, String colPattern) throws Exception{\r\n    \tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(tablePattern);\r\n    \tfor(int i=0; i<tables.size(); i++){\r\n    \t\tString tableName = tables.get(i);\r\n\t\t\ttry{\r\n\t    \t\tTableView tab = getTableView( con, tableName);\r\n\t    \t\tColumns cols = tab.columns;\r\n\t    \t\tfor(int c=0; c<cols.size(); c++){\r\n\t    \t\t\tColumn col = cols.get(c);\r\n\t\t\t\t\tObject[] row = new Object[18];\r\n\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t   \t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\t\r\n\t\t\t\t\trow[3] = col.getName();\t\t\t//COLUMN_NAME\t\r\n\t\t\t\t\trow[4] = Utils.getShort( SQLTokenizer.getSQLDataType( col.getDataType() )); //DATA_TYPE  \r\n\t\t\t\t\trow[5] = SQLTokenizer.getKeyWord( col.getDataType() );\t//TYPE_NAME\r\n\t\t\t\t\trow[6] = Utils.getInteger(col.getColumnSize());//COLUMN_SIZE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//BUFFER_LENGTH\r\n\t\t\t\t\trow[8] = Utils.getInteger(col.getScale());//DECIMAL_DIGITS\r\n\t\t\t\t\trow[9] = Utils.getInteger(10);\t\t//NUM_PREC_RADIX\r\n\t\t\t\t\trow[10]= Utils.getInteger(col.isNullable() ? DatabaseMetaData.columnNullable : DatabaseMetaData.columnNoNulls); //NULLABLE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//REMARKS\r\n\t\t\t\t\trow[12]= col.getDefaultDefinition(); //COLUMN_DEF\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//SQL_DATA_TYPE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//SQL_DATETIME_SUB\r\n\t\t\t\t\trow[15]= row[6];\t\t\t\t//CHAR_OCTET_LENGTH\r\n\t\t\t\t\trow[16]= Utils.getInteger(i); \t//ORDINAL_POSITION\t\t\r\n\t\t\t\t\trow[17]= col.isNullable() ? \"YES\" : \"NO\"; //IS_NULLABLE\t\t\t\t\t\r\n\t\t\t\t\trows.add(row);\r\n\t    \t\t}\r\n\t\t\t}catch(Exception e){\r\n\t\t\t\t//invalid Tables and View will not show \r\n\t\t\t}\r\n    \t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\r\n    }","startLine":33,"lastLine":38}],"window":6},{"content":"try{int maxRows = Integer.parseInt(token.getName(sql));selCmd.setMaxRows(maxRows);}catch(NumberFormatException e){throw createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/singleSelect()","rawLines":"/**\r\n     * A single SELECT of a UNION or only a simple single SELECT.\r\n     * @return\r\n     * @throws SQLException\r\n     */\r\n    private CommandSelect singleSelect() throws SQLException{\r\n        CommandSelect selCmd = new CommandSelect(con.log);\r\n\t\tSQLToken token;\r\n        // scan for prefix like DISTINCT, ALL and the TOP clause; sample: SELECT TOP 15 ...\r\nSwitch: while(true){\r\n\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.TOP:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tint maxRows = Integer.parseInt(token.getName(sql));\r\n\t\t\t\t\t\tselCmd.setMaxRows(maxRows);\r\n\t\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ALL:\r\n\t\t\t\t\tselCmd.setDistinct(false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.DISTINCT:\r\n\t\t\t\t\tselCmd.setDistinct(true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\tbreak Switch;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        while(true){\r\n            Expression column = expression(selCmd, 0);\r\n            selCmd.addColumnExpression( column );\r\n\r\n            token = nextToken();\r\n            if(token == null) return selCmd; // SELECT without FROM\r\n\r\n            boolean as = false;\r\n            if(token.value == SQLTokenizer.AS){\r\n                token = nextToken(MISSING_EXPRESSION);\r\n                as = true;\r\n            }\r\n\r\n            if(as || (!isKeyword(token))){\r\n            \tString alias = getIdentifier( token);\r\n                column.setAlias( alias );\r\n                token = nextToken();\r\n                if(token == null) return selCmd; // SELECT without FROM\r\n            }\r\n\r\n            switch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        break;\r\n                case SQLTokenizer.FROM:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        from(selCmd);\r\n                        return selCmd;\r\n\r\n                default:\r\n                        if(!isKeyword(token))\r\n                \t\t\tthrow createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.FROM} );\r\n                        previousToken();\r\n                        return selCmd;\r\n            }\r\n        }\r\n    }","startLine":14,"lastLine":19},{"locFile":"java+method:///smallsql/database/SQLParser/limit(smallsql.database.CommandSelect)","rawLines":"private void limit(CommandSelect selCmd) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        try{\r\n            int maxRows = Integer.parseInt(token.getName(sql));\r\n            selCmd.setMaxRows(maxRows);\r\n        }catch(NumberFormatException e){\r\n            throw createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n        }\r\n    }","startLine":2,"lastLine":7}],"window":6},{"content":"break;case SQLTokenizer.VARBINARY:case SQLTokenizer.BINARY:case SQLTokenizer.LONGVARBINARY:case SQLTokenizer.BLOB:case SQLTokenizer.UNIQUEIDENTIFIER:","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":49,"lastLine":54},{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.IndexNode,smallsql.database.Expression,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}","startLine":56,"lastLine":61}],"window":6},{"content":"rs.insertRow();}time += System.currentTimeMillis();rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);rs.next();int count = rs.getInt(1);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertEmptyRows(java.sql.Connection)","rawLines":"/**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":14,"lastLine":19},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertRows(java.sql.Connection)","rawLines":"/**\r\n      *  5. Test\r\n      *  Insert rows with the method insertRow().\r\n      */  \r\n    static void test_InsertRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n\t            rs.updateBytes (  \"bi\", byteArray );\r\n\t            rs.updateString(  \"c\" , \"Test\" );\r\n\t            rs.updateDate  (  \"d\" , new Date( System.currentTimeMillis() ) );\r\n\t            rs.updateFloat (  \"de\", (float)1234.56789 );\r\n\t            rs.updateFloat (  \"f\" , (float)9876.54321 );\r\n\t            rs.updateBytes (  \"im\", largeByteArray );\r\n\t            rs.updateInt   (  \"i\" , i );\r\n\t            rs.updateDouble(  \"m\" , 23.45 );\r\n\t            rs.updateDouble(  \"n\" , 567.45 );\r\n\t            rs.updateFloat (  \"r\" , (float)78.89 );\r\n\t            rs.updateTime  (  \"sd\", new Time( System.currentTimeMillis() ) );\r\n\t            rs.updateShort (  \"si\", (short)i );\r\n\t            rs.updateFloat (  \"sm\", (float)34.56 );\r\n\t            rs.updateString(  \"sy\", \"sysname (30) NULL\" );\r\n\t            rs.updateString(  \"t\" , \"ntext NULL, sample to save in the field\" );\r\n\t            rs.updateByte  (  \"ti\", (byte)i );\r\n\t            rs.updateBytes (  \"vb\", byteArray );\r\n\t            rs.updateString(  \"vc\", \"nvarchar (255) NULL\" );\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                  st.execute(\"DELETE FROM \" + tableName);\r\n                  System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            }else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n        \te.printStackTrace();\r\n            try{\r\n                // reset for the next test\r\n                Statement st = con.createStatement();\r\n                st.execute(\"DELETE FROM \" + tableName);\r\n                st.close();\r\n            }catch(Exception ee){/* ignore it */}\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":32,"lastLine":37}],"window":6},{"content":"Connection con = AllTests.getConnection();try{con.setAutoCommit(false);con.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");assertRowCount( 0, \"Select * from transactions\");con.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testCommit()","rawLines":"public void testCommit() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions Select * From transactions\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":1,"lastLine":7},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_withWrongWhere()","rawLines":"/**\r\n     * If there was insert a row within the ResultSet that not map WHERE than you scroll to this row. If there an Insert\r\n     * outsite the ResultSet that not map the WHERE then you can't scroll this row.\r\n     * \r\n     * @throws Exception\r\n     */\r\n\tpublic void testInsertRow_withWrongWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":7,"lastLine":13}],"window":6},{"content":"while(rs.next()){String newValue = rs.getString(\"v\");assertTrue( oldValue.compareTo( newValue ) < 0 );oldValue = newValue;count++;}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_asc()","rawLines":"public void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":17,"lastLine":22},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testUnion()","rawLines":"public void testUnion() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT v, 5 as Const FROM \" + table1 + \" Union All Select vc, 6 From \" + table3 + \" ORDER by v\");\r\n\t\t\r\n\t\tassertRSMetaData(rs, new String[]{\"v\", \"Const\"}, new int[]{Types.VARCHAR, Types.INTEGER});\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 3;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+4, count );\r\n\t}","startLine":23,"lastLine":28}],"window":6},{"content":"final byte[] getBytes() throws Exception{if(isNull()) return null;byte[] bytes = param1.getBytes();int length = param2.getInt();if(bytes.length <= length) return bytes;byte[] b = new byte[length];","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionLeft/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint length = param2.getInt();\r\n\t\tif(bytes.length <= length) return bytes;\r\n\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, 0, b, 0, length);\r\n\t\treturn b;\t\t\r\n\t}","startLine":0,"lastLine":6},{"locFile":"java+method:///smallsql/database/ExpressionFunctionRight/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint length = param2.getInt();\r\n\t\tif(bytes.length <= length) return bytes;\r\n\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, bytes.length -length, b, 0, length);\r\n\t\treturn b;\t\t\r\n\t}","startLine":0,"lastLine":6}],"window":6},{"content":"wasNull = expr.isNull();return expr.getFloat();}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getFloat(int)","rawLines":"public float getFloat(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getFloat();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getFloat(int)","rawLines":"public float getFloat(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getFloat();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8}],"window":6},{"content":"wasNull = expr.isNull();return expr.getInt();}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getInt(int)","rawLines":"public int getInt(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getInt();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getInt(int)","rawLines":"public int getInt(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getInt();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":3,"lastLine":8}],"window":6},{"content":"buf.append(' ');formatNumber( details.hour, 2, buf);buf.append(':');formatNumber( details.minute, 2, buf);buf.append(':');formatNumber( details.second, 2, buf);","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":218,"lastLine":223},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":279,"lastLine":284},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":232,"lastLine":237}],"window":6},{"content":"}}finally {conn.close();}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestLanguage/testLocalizedErrors()","rawLines":"public void testLocalizedErrors() throws Exception {\r\n\t\tConnection conn = AllTests.createConnection(\"?locale=it\", null);\r\n\t\tStatement stat = conn.createStatement();\r\n\t\t\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\trecreateTestTab(stat);\r\n\t\r\n\t\t\t\tstat.execute(\"CREATE TABLE \" + TABLE_NAME + \" (id_test INT)\");\r\n\t\t\t\tfail();\r\n\t\t\t}\r\n\t\t\tcatch(SQLException e) {\r\n\t\t\t\tassertMessage(e, \"La tabella/vista '\" + TABLE_NAME + \"' è già esistente.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"DROP TABLE \" + TABLE_NAME);\r\n\t\t\t\tstat.execute(\"DROP TABLE \" + TABLE_NAME);\r\n\t\t\t}\r\n\t\t\tcatch (SQLException e) {\r\n\t\t\t\tassertMessage(e, \"Non si può effettuare DROP della tabella\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"CREATE TABLE foo\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException e) {\r\n\t\t\t\tassertMessage(e, \"Errore di sintassi, fine inattesa\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tconn.close();\r\n\t\t}\r\n\t}","startLine":28,"lastLine":33},{"locFile":"java+method:///smallsql/junit/TestLanguage/testSyntaxErrors()","rawLines":"public void testSyntaxErrors() throws SQLException {\r\n\t\tConnection conn = AllTests.createConnection(\"?locale=it\", null);\r\n\t\tStatement stat = conn.createStatement();\r\n\t\t\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"CREATE TABLE\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi, fine inattesa della stringa SQL. Le parole chiave richieste sono: <identifier>\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"Some nonsensical sentence.\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi alla posizione 0 in 'Some'. Le parole chiave richieste sono\");\r\n\t\t\t}\r\n\r\n\t\t\trecreateTestTab(stat);\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"SELECT bar() FROM foo\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi alla posizione 7 in 'bar'. Funzione sconosciuta\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"SELECT UCASE('a', '');\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi alla posizione 7 in 'UCASE'. Totale parametri non valido.\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tconn.close();\r\n\t\t}\r\n\t}","startLine":33,"lastLine":38}],"window":6},{"content":"raFile = Utils.openRaFile( file, database.isReadOnly() );ByteBuffer buffer = ByteBuffer.allocate(8);raFile.read(buffer);buffer.position(0);int magic   = buffer.getInt();int version = buffer.getInt();","cloneLocs":[{"locFile":"java+method:///smallsql/database/TableView/load(smallsql.database.SSConnection,smallsql.database.Database,java.lang.String)","rawLines":"/**\r\n\t * Load a Table or View object. \r\n\t */\r\n\tstatic TableView load(SSConnection con, Database database, String name) throws SQLException{\r\n\t    FileChannel raFile = null;\r\n\t\ttry{\r\n\t\t\tString fileName = Utils.createTableViewFileName( database, name );\r\n\t\t\tFile file = new File( fileName );\r\n\t\t\tif(!file.exists())\r\n\t\t\t\tthrow SmallSQLException.create(Language.TABLE_OR_VIEW_MISSING, name);\r\n\t\t\traFile = Utils.openRaFile( file, database.isReadOnly() );\r\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(8);\r\n\t\t\traFile.read(buffer);\r\n\t\t\tbuffer.position(0);\r\n\t\t\tint magic   = buffer.getInt();\r\n\t\t\tint version = buffer.getInt();\r\n\t\t\tswitch(magic){\r\n\t\t\t\tcase MAGIC_TABLE:\r\n\t\t\t\tcase MAGIC_VIEW:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.TABLE_OR_VIEW_FILE_INVALID, fileName);\r\n\t\t\t}\r\n\t\t\tif(version > TABLE_VIEW_VERSION)\r\n\t\t\t\tthrow SmallSQLException.create(Language.FILE_TOONEW, new Object[] { new Integer(version), fileName });\r\n\t\t\tif(version < TABLE_VIEW_OLD_VERSION)\r\n\t\t\t\tthrow SmallSQLException.create(Language.FILE_TOOOLD, new Object[] { new Integer(version), fileName });\r\n\t\t\tif(magic == MAGIC_TABLE)\r\n\t\t\t\treturn new Table( database, con, name, raFile, raFile.position(), version);\r\n\t\t\t\treturn new View ( con, name, raFile, raFile.position());\r\n\t\t}catch(Throwable e){\r\n\t\t\tif(raFile != null)\r\n\t\t\t\ttry{\r\n\t\t\t\t\traFile.close();\r\n\t\t\t\t}catch(Exception e2){\r\n\t\t\t\t\tDriverManager.println(e2.toString());\r\n\t\t\t\t}\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}","startLine":10,"lastLine":15},{"locFile":"java+method:///smallsql/database/IndexDescription/load(smallsql.database.Database)","rawLines":"private void load(Database database) throws SQLException{\r\n        try{\r\n            File file = getFile( database, name );\r\n            if(!file.exists())\r\n                throw SmallSQLException.create(Language.INDEX_MISSING, name);\r\n            raFile = Utils.openRaFile( file, database.isReadOnly() );\r\n            ByteBuffer buffer = ByteBuffer.allocate(8);\r\n            raFile.read(buffer);\r\n            buffer.position(0);\r\n            int magic   = buffer.getInt();\r\n            int version = buffer.getInt();\r\n            if(magic != MAGIC_INDEX){\r\n                throw SmallSQLException.create(Language.INDEX_FILE_INVALID, file.getName());\r\n            }\r\n            if(version > INDEX_VERSION){\r\n            \tObject[] params = { new Integer(version), file.getName() };\r\n                throw SmallSQLException.create(Language.FILE_TOONEW, params);\r\n            }\r\n        }catch(Throwable e){\r\n            if(raFile != null)\r\n                try{\r\n                    raFile.close();\r\n                }catch(Exception e2){\r\n                    DriverManager.println(e2.toString());\r\n                }\r\n            throw SmallSQLException.createFromException(e);\r\n        }\r\n    }","startLine":5,"lastLine":10}],"window":6},{"content":"case OR:case AND:case NOT:case LIKE:case ISNULL:case ISNOTNULL:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/isNull()","rawLines":"boolean isNull() throws Exception{\r\n        switch(operation){\r\n\t        case OR:\r\n\t        case AND:\r\n\t        case NOT:\r\n\t        case LIKE:\r\n\t        case ISNULL:\r\n\t\t\tcase ISNOTNULL:\r\n\t\t\tcase IN:\r\n\t\t\t\t\t\t\treturn false; //Boolean operations return ever a result ???, but at least ISNULL and ISNOTNULL\r\n            case NEGATIVE: \r\n            case BIT_NOT:\r\n                           return                  left.isNull();\r\n            default:       return left.isNull() || right.isNull();\r\n        }\r\n    }","startLine":2,"lastLine":7},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getDataType()","rawLines":"int getDataType() {\r\n        switch(operation){\r\n            case NEGATIVE:\r\n            case BIT_NOT:\r\n            \treturn left.getDataType();\r\n\t\t\tcase EQUALS:\r\n\t\t\tcase EQUALS_NULL:\r\n\t\t\tcase GREATER:\r\n\t\t\tcase GRE_EQU:\r\n\t\t\tcase LESSER:\r\n\t\t\tcase LES_EQU:\r\n\t\t\tcase UNEQUALS:\r\n\t\t\tcase BETWEEN:\r\n\t\t\tcase OR:\r\n\t\t\tcase AND:\r\n\t\t\tcase NOT:\r\n\t\t\tcase LIKE:\r\n\t\t\tcase ISNULL:\r\n\t\t\tcase ISNOTNULL:\r\n\t\t\t \treturn SQLTokenizer.BOOLEAN;\r\n            default:\r\n            \treturn getDataType(left, right);\r\n        }\r\n    }","startLine":13,"lastLine":18}],"window":6},{"content":"pr.setBytes (  1, byteArray );pr.setString(  2 , \"Test\" );pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );pr.setFloat (  4, (float)1234.56789 );pr.setFloat (  5 , (float)9876.54321 );pr.setBytes (  6, largeByteArray );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepare(java.sql.Connection)","rawLines":"/**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":11,"lastLine":16},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepareBatch(java.sql.Connection)","rawLines":"/**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":15,"lastLine":20}],"window":6},{"content":"int type;while((type = store.readInt()) != 0){int offsetInPage = store.getCurrentOffsetInPage();int size = store.readInt();switch(type){","cloneLocs":[{"locFile":"java+constructor:///smallsql/database/Table/Table(smallsql.database.Database,smallsql.database.SSConnection,java.lang.String,java.nio.channels.FileChannel,long,int)","rawLines":"/**\r\n\t * Constructor for read existing tables.\r\n\t */\r\n    Table( Database database, SSConnection con, String name, FileChannel raFile, long offset, int tableFormatVersion) throws Exception{\r\n        super( name, new Columns() );\r\n        this.database = database;\r\n        this.raFile   = raFile;\r\n\t\tthis.firstPage = offset;\r\n\t\tStoreImpl store = getStore(con, firstPage, SQLTokenizer.SELECT);\r\n        if(store == null){\r\n            throw SmallSQLException.create(Language.TABLE_FILE_INVALID, getFile(database));\r\n        }\r\n\t\tint count = store.readInt();\r\n\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tcolumns.add( store.readColumn(tableFormatVersion) );\r\n\t\t}\r\n\t\tindexes = new IndexDescriptions();\r\n        references = new ForeignKeys();\r\n\t\t\r\n\t\t// read additional informations\r\n\t\tint type;\r\n\t\twhile((type = store.readInt()) != 0){\r\n\t\t\tint offsetInPage = store.getCurrentOffsetInPage();\r\n\t\t\tint size = store.readInt();\r\n\t\t\tswitch(type){\r\n\t\t\t\tcase INDEX:\r\n\t\t\t\t\tindexes.add( IndexDescription.load( database, this, store) );\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tstore.setCurrentOffsetInPage(offsetInPage + size);\r\n\t\t}\r\n\t\t\r\n\t\tfirstPage = store.getNextPagePos();\r\n    }","startLine":21,"lastLine":25},{"locFile":"java+constructor:///smallsql/database/View/View(smallsql.database.SSConnection,java.lang.String,java.nio.channels.FileChannel,long)","rawLines":"/**\r\n\t * Constructor for loading an existing view. \r\n\t */\r\n\tView(SSConnection con, String name, FileChannel raFile, long offset) throws Exception{\r\n\t\tsuper( name, new Columns() );\r\n\t\tStorePage storePage = new StorePage( null, -1, raFile, offset);\r\n\t\tStoreImpl store = StoreImpl.createStore( null, storePage, SQLTokenizer.SELECT, offset);\r\n\t\tsql = store.readString();\r\n\t\t\r\n\t\t// read additional informations\r\n\t\tint type;\r\n\t\twhile((type = store.readInt()) != 0){\r\n\t\t\tint offsetInPage = store.getCurrentOffsetInPage();\r\n\t\t\tint size = store.readInt();\r\n\t\t\tswitch(type){\r\n\t\t\t\t//currently there are no additinal informations, see write()\r\n\t\t\t}\r\n\t\t\tstore.setCurrentOffsetInPage(offsetInPage + size);\r\n\t\t}\r\n\t\t\r\n\t\traFile.close();\r\n\t\tcommandSelect = (CommandSelect)new SQLParser().parse(con, sql);\r\n\t\tcreateColumns(con);\r\n\t}","startLine":10,"lastLine":14}],"window":5},{"content":"int length = key.length;int i=-1;while(true){char digit = (i<0) ? (length == 0 ? (char)1 : 2): (key[i]);","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/find(smallsql.database.IndexNode,char%5B%5D,java.util.ArrayList)","rawLines":"final private IndexNode find(IndexNode node, char[] key, ArrayList nodeList){\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tnode = node.getChildNode(digit);\r\n\r\n\t\t\tif(node == null) return null;\r\n\t\t\tif(nodeList != null) nodeList.add(node);\r\n\t\t\tif(++i == length){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":1,"lastLine":6},{"locFile":"java+method:///smallsql/database/Index/add(smallsql.database.IndexNode,long,char%5B%5D,boolean)","rawLines":"/**\r\n\t * Add a byte array to the Index.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, char[] key, boolean isLast) throws SQLException{\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tif(++i == length){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i );\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.saveValue(rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":4,"lastLine":9}],"window":5},{"content":"init();Connection con = AllTests.getConnection();Statement st = con.createStatement();ResultSet rs;int oldValue;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_functionAscDesc()","rawLines":"public void test_functionAscDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\tint oldValue2;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i) Asc, i desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\toldValue2 = rs.getInt(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue2 = rs.getInt(\"i\");\r\n\t\t\tint newValue = Math.abs( newValue2 );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\tif(oldValue == newValue){\r\n\t\t\t\tassertTrue( oldValue2 > newValue2 );\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t\toldValue2 = newValue2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_function()","rawLines":"public void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5}],"window":5},{"content":"pr.execute();rs = pr.getGeneratedKeys();assertNotNull(\"RETURN_GENERATED_KEYS\", rs);assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());assertRowCount(1,rs);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":33,"lastLine":37},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":48,"lastLine":52}],"window":5},{"content":"page[ offset++ ] = (byte)(value >> 24);page[ offset++ ] = (byte)(value >> 16);page[ offset++ ] = (byte)(value >> 8);page[ offset++ ] = (byte)(value);}","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/writeInt(int)","rawLines":"void writeInt( int value ){\r\n    \tint newSize = offset + 4;\r\n        if(newSize > page.length) resizePage(newSize);\r\n\r\n        page[ offset++ ] = (byte)(value >> 24);\r\n        page[ offset++ ] = (byte)(value >> 16);\r\n        page[ offset++ ] = (byte)(value >> 8);\r\n        page[ offset++ ] = (byte)(value);\r\n    }","startLine":4,"lastLine":8},{"locFile":"java+method:///smallsql/database/StoreImpl/writeLong(long)","rawLines":"void writeLong( long value ){\r\n    \tint newSize = offset + 8;\r\n        if(newSize > page.length) resizePage(newSize);\r\n\r\n        page[ offset++ ] = (byte)(value >> 56);\r\n        page[ offset++ ] = (byte)(value >> 48);\r\n        page[ offset++ ] = (byte)(value >> 40);\r\n        page[ offset++ ] = (byte)(value >> 32);\r\n        page[ offset++ ] = (byte)(value >> 24);\r\n        page[ offset++ ] = (byte)(value >> 16);\r\n        page[ offset++ ] = (byte)(value >> 8);\r\n        page[ offset++ ] = (byte)(value);\r\n    }","startLine":8,"lastLine":12}],"window":5},{"content":"cal.execute();}cal.close();checkValues( st, values, needTrim);st.execute(\"Delete From \"+ table);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestDataTypes/runTest()","rawLines":"public void runTest() throws Throwable {\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table \" + table +\"(abc \" + datatype + \")\");\r\n        String name = \"abc\";\r\n\r\n        Object[] values = null;\r\n        String   quote = \"\";\r\n        String escape1 = \"\";\r\n        String escape2 = \"\";\r\n        boolean needTrim = false;\r\n\r\n        ResultSet rs = st.executeQuery(\"SELECT * From \" + table);\r\n\t\tResultSetMetaData md = rs.getMetaData();\r\n        switch(md.getColumnType(1)){\r\n            case Types.CHAR:\r\n                needTrim = true;\r\n            case Types.VARCHAR:\r\n            case Types.LONGVARCHAR:\r\n            case Types.CLOB:\r\n                values = new Object[]{null,\"qwert\", \"asdfg\", \"hjhjhj\", \"1234567890 qwertzuiop 1234567890 asdfghjklö 1234567890 yxcvbnm,.- 1234567890 \"};\r\n                quote  = \"\\'\";\r\n                break;\r\n            case Types.BIGINT:\r\n                values = new Object[]{null,new Long(123), new Long(-2123), new Long(392839283)};\r\n                break;\r\n            case Types.INTEGER:\r\n                values = new Object[]{null,new Integer(123), new Integer(-2123), new Integer(392839283)};\r\n                break;\r\n            case Types.SMALLINT:\r\n                values = new Object[]{null,new Integer(123), new Integer(-2123), new Integer(32000)};\r\n                break;\r\n            case Types.TINYINT:\r\n                values = new Object[]{null,new Integer(0), new Integer(12), new Integer(228)};\r\n                break;\r\n            case Types.REAL:\r\n                values = new Object[]{null,new Float(0.0), new Float(-12.123), new Float(22812345234.9)};\r\n                break;\r\n            case Types.FLOAT:\r\n            case Types.DOUBLE:\r\n                values = new Object[]{null,new Double(0.0), new Double(-12.123), new Double(22812345234.9)};\r\n                break;\r\n            case Types.NUMERIC:\r\n            case Types.DECIMAL:\r\n                needTrim = true;\r\n            \tif(md.getPrecision(1)<16){//smallmoney\r\n\t\t\t\t\tvalues = new Object[]{null,new BigDecimal(\"0.0\"), new BigDecimal(\"-2\"), new BigDecimal(\"-12.123\")};\r\n                /*if(rs.getMetaData().isCurrency(1)){\r\n                    values = new Object[]{null, new Money(0.0), new Money(-12.123), new Money(202812.9)};*/\r\n                }else{\r\n                    values = new Object[]{null,new BigDecimal(\"0.0\"), new BigDecimal(\"-2\"), new BigDecimal(\"-12.123\"), new BigDecimal(\"22812345234.9\")};\r\n                }\r\n                break;\r\n            case Types.BIT:\r\n            case Types.BOOLEAN:\r\n                values = new Object[]{null, Boolean.TRUE, Boolean.FALSE};\r\n                break;\r\n            case Types.TIME:\r\n                values = new Object[]{null, new Time(10,17,56), new Time(0,0,0),new Time(23,59,59)};\r\n                escape1 = \"{t '\";\r\n                escape2 = \"'}\";\r\n                break;\r\n\t\t\tcase Types.DATE:\r\n\t\t\t\tvalues = new Object[]{null, new java.sql.Date(10,10,1), new java.sql.Date(0,0,1),new java.sql.Date(70,0,1)};\r\n\t\t\t\tescape1 = \"{d '\";\r\n\t\t\t\tescape2 = \"'}\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase Types.TIMESTAMP:\r\n\t\t\t\tif(md.getPrecision(1) >16)\r\n\t\t\t\t\tvalues = new Object[]{null, new Timestamp(10,10,1, 10,17,56, 0), new Timestamp(0,0,1, 0,0,0, 0),new Timestamp( 120,1,1, 23,59,59, 500000000),new Timestamp(0),new Timestamp( -120,1,1, 23,59,59, 500000000)};\r\n\t\t\t\telse//smalldatetime\r\n\t\t\t\t\tvalues = new Object[]{null, new Timestamp(10,10,1, 10,17,0, 0), new Timestamp(0,0,1, 0,0,0, 0),new Timestamp(0)};\r\n\t\t\t\tescape1 = \"{ts '\";\r\n\t\t\t\tescape2 = \"'}\";\r\n\t\t\t\tbreak;\r\n            case Types.BINARY:\r\n                needTrim = true;\r\n            case Types.VARBINARY:\r\n            case Types.LONGVARBINARY:\r\n            case Types.BLOB:\r\n                values = new Object[]{null, new byte[]{1, 127, -23}};\r\n                break;\r\n            case Types.JAVA_OBJECT:\r\n                values = new Object[]{null, new Integer(-123), new Double(1.2), new byte[]{1, 127, -23}};\r\n                break;\r\n            case -11: //UNIQUEIDENTIFER\r\n                values = new Object[]{null, \"342734E3-D9AC-408F-8724-B7A257C4529E\", \"342734E3-D9AC-408F-8724-B7A257C4529E\"};\r\n                quote  = \"\\'\";\r\n                break;\r\n            default: fail(\"Unknown column type: \" + rs.getMetaData().getColumnType(1));\r\n        }\r\n        rs.close();\r\n\t\t\r\n\t\t// remove all resource for reloading the tables from file\r\n\t\tcon.close();\r\n\t\tcon = AllTests.getConnection();\r\n\t\tst = con.createStatement();\r\n\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n            String q = (val == null) ? \"\" : quote;\r\n            String e1 = (val == null) ? \"\" : escape1;\r\n            String e2 = (val == null) ? \"\" : escape2;\r\n            if(val instanceof byte[]){\r\n                StringBuffer buf = new StringBuffer( \"0x\" );\r\n                for(int k=0; k<((byte[])val).length; k++){\r\n                    String digit = \"0\" + Integer.toHexString( ((byte[])val)[k] );\r\n                    buf.append( digit.substring( digit.length()-2 ) );\r\n                }\r\n                val = buf.toString();\r\n            }\r\n            st.execute(\"Insert into \" + table + \"(abc) Values(\" + e1 + q + val + q + e2 + \")\");\r\n        }\r\n\t\tcheckValues( st, values, needTrim);\r\n\t\t\r\n\t\tst.execute(\"Delete From \"+ table);\r\n\t\tCallableStatement cal = con.prepareCall(\"Insert Into \" + table + \"(abc) Values(?)\");\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n\t\t\tcal.setObject( 1, val);\r\n\t\t\tcal.execute();\r\n        }\r\n\t\tcal.close();\r\n\t\tcheckValues( st, values, needTrim);\r\n\t\t\r\n\t\tst.execute(\"Delete From \"+ table);\r\n\t\tcal = con.prepareCall(\"Insert Into \" + table + \"(abc) Values(?)\");\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n\t\t\tif(val == null){\r\n\t\t\t\tcal.setNull( 1, Types.NULL );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Time){\r\n\t\t\t\tcal.setTime( 1, (Time)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Timestamp){\r\n\t\t\t\tcal.setTimestamp( 1, (Timestamp)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Date){\r\n\t\t\t\tcal.setDate( 1, (Date)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof String){\r\n\t\t\t\tcal.setString( 1, (String)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Boolean){\r\n\t\t\t\tcal.setBoolean( 1, ((Boolean)val).booleanValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Byte){\r\n\t\t\t\tcal.setByte( 1, ((Byte)val).byteValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Short){\r\n\t\t\t\tcal.setShort( 1, ((Short)val).shortValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Integer){\r\n\t\t\t\tcal.setInt( 1, ((Integer)val).intValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Long){\r\n\t\t\t\tcal.setLong( 1, ((Long)val).longValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Float){\r\n\t\t\t\tcal.setFloat( 1, ((Float)val).floatValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Double){\r\n\t\t\t\tcal.setDouble( 1, ((Double)val).doubleValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof BigDecimal){\r\n\t\t\t\tcal.setBigDecimal( 1, (BigDecimal)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof byte[]){\r\n\t\t\t\tcal.setBytes( 1, (byte[])val );\r\n\t\t\t}\r\n\t\t\tcal.execute();\r\n        }\r\n\t\tcal.close();\r\n\t\tcheckValues( st, values, needTrim);\r\n\r\n        \r\n        st.execute(\"Delete From \"+ table);\r\n        Statement st2 = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs2 = st2.executeQuery(\"SELECT * From \" + table);\r\n        for(int i=0; i<values.length; i++){\r\n            rs2.moveToInsertRow();\r\n            Object val = values[i];\r\n            if(val == null){\r\n                rs2.updateNull( name );\r\n            }else\r\n            if(val instanceof Time){\r\n                rs2.updateTime( name, (Time)val );\r\n            }else\r\n            if(val instanceof Timestamp){\r\n                rs2.updateTimestamp( name, (Timestamp)val );\r\n            }else\r\n            if(val instanceof Date){\r\n                rs2.updateDate( name, (Date)val );\r\n            }else\r\n            if(val instanceof String){\r\n                rs2.updateString( name, (String)val );\r\n            }else\r\n            if(val instanceof Boolean){\r\n                rs2.updateBoolean( name, ((Boolean)val).booleanValue() );\r\n            }else\r\n            if(val instanceof Byte){\r\n                rs2.updateByte( name, ((Byte)val).byteValue() );\r\n            }else\r\n            if(val instanceof Short){\r\n                rs2.updateShort( name, ((Short)val).shortValue() );\r\n            }else\r\n            if(val instanceof Integer){\r\n                rs2.updateInt( name, ((Integer)val).intValue() );\r\n            }else\r\n            if(val instanceof Long){\r\n                rs2.updateLong( name, ((Long)val).longValue() );\r\n            }else\r\n            if(val instanceof Float){\r\n                rs2.updateFloat( name, ((Float)val).floatValue() );\r\n            }else\r\n            if(val instanceof Double){\r\n                rs2.updateDouble( name, ((Double)val).doubleValue() );\r\n            }else\r\n            if(val instanceof BigDecimal){\r\n                rs2.updateBigDecimal( name, (BigDecimal)val );\r\n            }else\r\n            if(val instanceof byte[]){\r\n                rs2.updateBytes( name, (byte[])val );\r\n            }\r\n            rs2.insertRow();\r\n        }\r\n        st2.close();\r\n        checkValues( st, values, needTrim);\r\n    }","startLine":171,"lastLine":177},{"locFile":"java+method:///smallsql/junit/TestDataTypes/runTest()","rawLines":"public void runTest() throws Throwable {\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table \" + table +\"(abc \" + datatype + \")\");\r\n        String name = \"abc\";\r\n\r\n        Object[] values = null;\r\n        String   quote = \"\";\r\n        String escape1 = \"\";\r\n        String escape2 = \"\";\r\n        boolean needTrim = false;\r\n\r\n        ResultSet rs = st.executeQuery(\"SELECT * From \" + table);\r\n\t\tResultSetMetaData md = rs.getMetaData();\r\n        switch(md.getColumnType(1)){\r\n            case Types.CHAR:\r\n                needTrim = true;\r\n            case Types.VARCHAR:\r\n            case Types.LONGVARCHAR:\r\n            case Types.CLOB:\r\n                values = new Object[]{null,\"qwert\", \"asdfg\", \"hjhjhj\", \"1234567890 qwertzuiop 1234567890 asdfghjklö 1234567890 yxcvbnm,.- 1234567890 \"};\r\n                quote  = \"\\'\";\r\n                break;\r\n            case Types.BIGINT:\r\n                values = new Object[]{null,new Long(123), new Long(-2123), new Long(392839283)};\r\n                break;\r\n            case Types.INTEGER:\r\n                values = new Object[]{null,new Integer(123), new Integer(-2123), new Integer(392839283)};\r\n                break;\r\n            case Types.SMALLINT:\r\n                values = new Object[]{null,new Integer(123), new Integer(-2123), new Integer(32000)};\r\n                break;\r\n            case Types.TINYINT:\r\n                values = new Object[]{null,new Integer(0), new Integer(12), new Integer(228)};\r\n                break;\r\n            case Types.REAL:\r\n                values = new Object[]{null,new Float(0.0), new Float(-12.123), new Float(22812345234.9)};\r\n                break;\r\n            case Types.FLOAT:\r\n            case Types.DOUBLE:\r\n                values = new Object[]{null,new Double(0.0), new Double(-12.123), new Double(22812345234.9)};\r\n                break;\r\n            case Types.NUMERIC:\r\n            case Types.DECIMAL:\r\n                needTrim = true;\r\n            \tif(md.getPrecision(1)<16){//smallmoney\r\n\t\t\t\t\tvalues = new Object[]{null,new BigDecimal(\"0.0\"), new BigDecimal(\"-2\"), new BigDecimal(\"-12.123\")};\r\n                /*if(rs.getMetaData().isCurrency(1)){\r\n                    values = new Object[]{null, new Money(0.0), new Money(-12.123), new Money(202812.9)};*/\r\n                }else{\r\n                    values = new Object[]{null,new BigDecimal(\"0.0\"), new BigDecimal(\"-2\"), new BigDecimal(\"-12.123\"), new BigDecimal(\"22812345234.9\")};\r\n                }\r\n                break;\r\n            case Types.BIT:\r\n            case Types.BOOLEAN:\r\n                values = new Object[]{null, Boolean.TRUE, Boolean.FALSE};\r\n                break;\r\n            case Types.TIME:\r\n                values = new Object[]{null, new Time(10,17,56), new Time(0,0,0),new Time(23,59,59)};\r\n                escape1 = \"{t '\";\r\n                escape2 = \"'}\";\r\n                break;\r\n\t\t\tcase Types.DATE:\r\n\t\t\t\tvalues = new Object[]{null, new java.sql.Date(10,10,1), new java.sql.Date(0,0,1),new java.sql.Date(70,0,1)};\r\n\t\t\t\tescape1 = \"{d '\";\r\n\t\t\t\tescape2 = \"'}\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase Types.TIMESTAMP:\r\n\t\t\t\tif(md.getPrecision(1) >16)\r\n\t\t\t\t\tvalues = new Object[]{null, new Timestamp(10,10,1, 10,17,56, 0), new Timestamp(0,0,1, 0,0,0, 0),new Timestamp( 120,1,1, 23,59,59, 500000000),new Timestamp(0),new Timestamp( -120,1,1, 23,59,59, 500000000)};\r\n\t\t\t\telse//smalldatetime\r\n\t\t\t\t\tvalues = new Object[]{null, new Timestamp(10,10,1, 10,17,0, 0), new Timestamp(0,0,1, 0,0,0, 0),new Timestamp(0)};\r\n\t\t\t\tescape1 = \"{ts '\";\r\n\t\t\t\tescape2 = \"'}\";\r\n\t\t\t\tbreak;\r\n            case Types.BINARY:\r\n                needTrim = true;\r\n            case Types.VARBINARY:\r\n            case Types.LONGVARBINARY:\r\n            case Types.BLOB:\r\n                values = new Object[]{null, new byte[]{1, 127, -23}};\r\n                break;\r\n            case Types.JAVA_OBJECT:\r\n                values = new Object[]{null, new Integer(-123), new Double(1.2), new byte[]{1, 127, -23}};\r\n                break;\r\n            case -11: //UNIQUEIDENTIFER\r\n                values = new Object[]{null, \"342734E3-D9AC-408F-8724-B7A257C4529E\", \"342734E3-D9AC-408F-8724-B7A257C4529E\"};\r\n                quote  = \"\\'\";\r\n                break;\r\n            default: fail(\"Unknown column type: \" + rs.getMetaData().getColumnType(1));\r\n        }\r\n        rs.close();\r\n\t\t\r\n\t\t// remove all resource for reloading the tables from file\r\n\t\tcon.close();\r\n\t\tcon = AllTests.getConnection();\r\n\t\tst = con.createStatement();\r\n\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n            String q = (val == null) ? \"\" : quote;\r\n            String e1 = (val == null) ? \"\" : escape1;\r\n            String e2 = (val == null) ? \"\" : escape2;\r\n            if(val instanceof byte[]){\r\n                StringBuffer buf = new StringBuffer( \"0x\" );\r\n                for(int k=0; k<((byte[])val).length; k++){\r\n                    String digit = \"0\" + Integer.toHexString( ((byte[])val)[k] );\r\n                    buf.append( digit.substring( digit.length()-2 ) );\r\n                }\r\n                val = buf.toString();\r\n            }\r\n            st.execute(\"Insert into \" + table + \"(abc) Values(\" + e1 + q + val + q + e2 + \")\");\r\n        }\r\n\t\tcheckValues( st, values, needTrim);\r\n\t\t\r\n\t\tst.execute(\"Delete From \"+ table);\r\n\t\tCallableStatement cal = con.prepareCall(\"Insert Into \" + table + \"(abc) Values(?)\");\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n\t\t\tcal.setObject( 1, val);\r\n\t\t\tcal.execute();\r\n        }\r\n\t\tcal.close();\r\n\t\tcheckValues( st, values, needTrim);\r\n\t\t\r\n\t\tst.execute(\"Delete From \"+ table);\r\n\t\tcal = con.prepareCall(\"Insert Into \" + table + \"(abc) Values(?)\");\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n\t\t\tif(val == null){\r\n\t\t\t\tcal.setNull( 1, Types.NULL );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Time){\r\n\t\t\t\tcal.setTime( 1, (Time)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Timestamp){\r\n\t\t\t\tcal.setTimestamp( 1, (Timestamp)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Date){\r\n\t\t\t\tcal.setDate( 1, (Date)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof String){\r\n\t\t\t\tcal.setString( 1, (String)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Boolean){\r\n\t\t\t\tcal.setBoolean( 1, ((Boolean)val).booleanValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Byte){\r\n\t\t\t\tcal.setByte( 1, ((Byte)val).byteValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Short){\r\n\t\t\t\tcal.setShort( 1, ((Short)val).shortValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Integer){\r\n\t\t\t\tcal.setInt( 1, ((Integer)val).intValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Long){\r\n\t\t\t\tcal.setLong( 1, ((Long)val).longValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Float){\r\n\t\t\t\tcal.setFloat( 1, ((Float)val).floatValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Double){\r\n\t\t\t\tcal.setDouble( 1, ((Double)val).doubleValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof BigDecimal){\r\n\t\t\t\tcal.setBigDecimal( 1, (BigDecimal)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof byte[]){\r\n\t\t\t\tcal.setBytes( 1, (byte[])val );\r\n\t\t\t}\r\n\t\t\tcal.execute();\r\n        }\r\n\t\tcal.close();\r\n\t\tcheckValues( st, values, needTrim);\r\n\r\n        \r\n        st.execute(\"Delete From \"+ table);\r\n        Statement st2 = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs2 = st2.executeQuery(\"SELECT * From \" + table);\r\n        for(int i=0; i<values.length; i++){\r\n            rs2.moveToInsertRow();\r\n            Object val = values[i];\r\n            if(val == null){\r\n                rs2.updateNull( name );\r\n            }else\r\n            if(val instanceof Time){\r\n                rs2.updateTime( name, (Time)val );\r\n            }else\r\n            if(val instanceof Timestamp){\r\n                rs2.updateTimestamp( name, (Timestamp)val );\r\n            }else\r\n            if(val instanceof Date){\r\n                rs2.updateDate( name, (Date)val );\r\n            }else\r\n            if(val instanceof String){\r\n                rs2.updateString( name, (String)val );\r\n            }else\r\n            if(val instanceof Boolean){\r\n                rs2.updateBoolean( name, ((Boolean)val).booleanValue() );\r\n            }else\r\n            if(val instanceof Byte){\r\n                rs2.updateByte( name, ((Byte)val).byteValue() );\r\n            }else\r\n            if(val instanceof Short){\r\n                rs2.updateShort( name, ((Short)val).shortValue() );\r\n            }else\r\n            if(val instanceof Integer){\r\n                rs2.updateInt( name, ((Integer)val).intValue() );\r\n            }else\r\n            if(val instanceof Long){\r\n                rs2.updateLong( name, ((Long)val).longValue() );\r\n            }else\r\n            if(val instanceof Float){\r\n                rs2.updateFloat( name, ((Float)val).floatValue() );\r\n            }else\r\n            if(val instanceof Double){\r\n                rs2.updateDouble( name, ((Double)val).doubleValue() );\r\n            }else\r\n            if(val instanceof BigDecimal){\r\n                rs2.updateBigDecimal( name, (BigDecimal)val );\r\n            }else\r\n            if(val instanceof byte[]){\r\n                rs2.updateBytes( name, (byte[])val );\r\n            }\r\n            rs2.insertRow();\r\n        }\r\n        st2.close();\r\n        checkValues( st, values, needTrim);\r\n    }","startLine":120,"lastLine":125}],"window":5},{"content":"return -1;}}IndexNode node = status.nodes[idx];nodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );","cloneLocs":[{"locFile":"java+method:///smallsql/database/IndexScrollStatus/getRowOffset(boolean)","rawLines":"/**\r\n\t * Return the next rowOffset of this index. You need to call reset() before the first use. \r\n\t * @param next if true the next rowOffset else the previous rowOffset\r\n\t */\r\n\tfinal long getRowOffset( boolean scroll){\r\n\t\tif(longList != null){\r\n\t\t\tlong rowOffset = scroll ? \r\n\t\t\t\t\t\t\t\tlongList.getNext(longListEnum) : \r\n\t\t\t\t\t\t\t\tlongList.getPrevious(longListEnum);\r\n\t\t\tif(rowOffset < 0){\r\n\t\t\t\t// No more entries on this node\r\n\t\t\t\tlongList = null;\r\n\t\t\t}else{\r\n\t\t\t\treturn rowOffset;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\tIndexNodeScrollStatus status = (IndexNodeScrollStatus)nodeStack.peek();\r\n\t\t\tint level = status.level;\r\n\t\t\tif(!status.asc ^ scroll){\r\n\t\t\t\t//ASC order\r\n\t\t\t\tint idx = ++status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t\tidx = ++status.idx;\r\n\t\t\t\t}\r\n\t\t\t\tif(idx >= status.nodes.length){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n                        status.idx = status.nodes.length; //to prevent problems with scroll back after multiple calls after the end.\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}else{\r\n\t\t\t\t//DESC order\r\n\t\t\t\tint idx = --status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t}\r\n\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":45,"lastLine":49},{"locFile":"java+method:///smallsql/database/IndexScrollStatus/getRowOffset(boolean)","rawLines":"/**\r\n\t * Return the next rowOffset of this index. You need to call reset() before the first use. \r\n\t * @param next if true the next rowOffset else the previous rowOffset\r\n\t */\r\n\tfinal long getRowOffset( boolean scroll){\r\n\t\tif(longList != null){\r\n\t\t\tlong rowOffset = scroll ? \r\n\t\t\t\t\t\t\t\tlongList.getNext(longListEnum) : \r\n\t\t\t\t\t\t\t\tlongList.getPrevious(longListEnum);\r\n\t\t\tif(rowOffset < 0){\r\n\t\t\t\t// No more entries on this node\r\n\t\t\t\tlongList = null;\r\n\t\t\t}else{\r\n\t\t\t\treturn rowOffset;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\tIndexNodeScrollStatus status = (IndexNodeScrollStatus)nodeStack.peek();\r\n\t\t\tint level = status.level;\r\n\t\t\tif(!status.asc ^ scroll){\r\n\t\t\t\t//ASC order\r\n\t\t\t\tint idx = ++status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t\tidx = ++status.idx;\r\n\t\t\t\t}\r\n\t\t\t\tif(idx >= status.nodes.length){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n                        status.idx = status.nodes.length; //to prevent problems with scroll back after multiple calls after the end.\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}else{\r\n\t\t\t\t//DESC order\r\n\t\t\t\tint idx = --status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t}\r\n\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":74,"lastLine":78}],"window":5},{"content":"init();Connection con = AllTests.getConnection();Statement st = con.createStatement();ResultSet rs;Long oldValue;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_bigint()","rawLines":"public void test_bigint() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by bi\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Long)rs.getObject(\"bi\") ) < 0 );\r\n\t\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_bigint_withDoublicateValues()","rawLines":"public void test_bigint_withDoublicateValues() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT bi/2 bi_2 FROM \" + table1 + \" ORDER  by (bi/2)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tLong newValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\tassertTrue( oldValue + \"<=\"+newValue, oldValue.compareTo( newValue ) <= 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5}],"window":5},{"content":"public void setUp(){tearDown();try{Connection con = AllTests.getConnection();Statement st = con.createStatement();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestFunctions/setUp()","rawLines":"public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(aInt int, aVarchar varchar(100))\");\r\n            st.execute(\"Insert into \" + table + \"(aInt, aVarchar) Values(-120,'qwert')\");\r\n            st.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }","startLine":0,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOperatoren/setUp()","rawLines":"public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(a \" + testValue.dataType +\", b \" + testValue.dataType + \")\");\r\n            st.close();\r\n            PreparedStatement pr = con.prepareStatement(\"INSERT into \" + table + \"(a,b) Values(?,?)\");\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n            pr.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }","startLine":0,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestAlterTable/setUp()","rawLines":"public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(i int, v varchar(100))\");\r\n            st.execute(\"Insert into \" + table + \" Values(1,'abc')\");\r\n            st.execute(\"Insert into \" + table + \" Values(2,'bcd')\");\r\n            st.execute(\"Insert into \" + table + \" Values(3,'cde')\");\r\n            st.execute(\"Insert into \" + table + \" Values(4,'def')\");\r\n            st.execute(\"Insert into \" + table + \" Values(5,'efg')\");\r\n            st.execute(\"Insert into \" + table + \" Values(6,'fgh')\");\r\n            st.execute(\"Insert into \" + table + \" Values(7,'ghi')\");\r\n            st.execute(\"Insert into \" + table + \" Values(8,'hij')\");\r\n            st.execute(\"Insert into \" + table + \" Values(9,'ijk')\");\r\n            st.execute(\"Insert into \" + table + \" Values(10,'jkl')\");\r\n            st.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }","startLine":0,"lastLine":4}],"window":5},{"content":"Connection con = AllTests.getConnection();try{Statement st = con.createStatement();st.execute(\"Create Table DuplicatedColumn(col INT)\");try{","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testDuplicatedColumnInsert()","rawLines":"public void testDuplicatedColumnInsert() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"Create Table DuplicatedColumn(col INT)\");\r\n            try{\r\n                st.execute(\"INSERT INTO DuplicatedColumn(col,Col) Values(1,2)\");\r\n                fail(\"SQLException 'Duplicated Column' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"DuplicatedColumn\");\r\n        }\r\n    }","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testDuplicatedColumnAlter()","rawLines":"public void testDuplicatedColumnAlter() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"Create Table DuplicatedColumn(col INT)\");\r\n            try{\r\n                st.execute(\"ALTER TABLE DuplicatedColumn Add Col INT\");\r\n                fail(\"SQLException 'Duplicated Column' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"DuplicatedColumn\");\r\n        }\r\n    }","startLine":1,"lastLine":5}],"window":5},{"content":"con.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");assertRowCount( 2, \"Select * from transactions\");con.createStatement().execute(\"Insert Into transactions(v) (Select v From transactions)\");assertRowCount( 4, \"Select * from transactions\");con.rollback();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testRollback()","rawLines":"public void testRollback() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t    con.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) (Select v From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.rollback();\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":10,"lastLine":16},{"locFile":"java+method:///smallsql/junit/TestTransactions/testRollbackWithOneCommitRow()","rawLines":"/**\r\n\t * In the table there is already one row that is commited.\r\n\t */\r\n\tpublic void testRollbackWithOneCommitRow() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) (Select v From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.rollback();\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":13,"lastLine":19}],"window":5},{"content":"init();Connection con = AllTests.getConnection();Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);ResultSet rs;int count;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_Scollable()","rawLines":"public void testOrderBy_Scollable() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_ScollableDesc()","rawLines":"public void testOrderBy_ScollableDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i desc, d\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5}],"window":5},{"content":"try {recreateTestTab(stat);stat.execute(\"CREATE TABLE \" + TABLE_NAME + \" (id_test INT)\");fail();}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestLanguage/testLocalizedErrors()","rawLines":"public void testLocalizedErrors() throws Exception {\r\n\t\tConnection conn = AllTests.createConnection(\"?locale=it\", null);\r\n\t\tStatement stat = conn.createStatement();\r\n\t\t\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\trecreateTestTab(stat);\r\n\t\r\n\t\t\t\tstat.execute(\"CREATE TABLE \" + TABLE_NAME + \" (id_test INT)\");\r\n\t\t\t\tfail();\r\n\t\t\t}\r\n\t\t\tcatch(SQLException e) {\r\n\t\t\t\tassertMessage(e, \"La tabella/vista '\" + TABLE_NAME + \"' è già esistente.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"DROP TABLE \" + TABLE_NAME);\r\n\t\t\t\tstat.execute(\"DROP TABLE \" + TABLE_NAME);\r\n\t\t\t}\r\n\t\t\tcatch (SQLException e) {\r\n\t\t\t\tassertMessage(e, \"Non si può effettuare DROP della tabella\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"CREATE TABLE foo\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException e) {\r\n\t\t\t\tassertMessage(e, \"Errore di sintassi, fine inattesa\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tconn.close();\r\n\t\t}\r\n\t}","startLine":5,"lastLine":10},{"locFile":"java+method:///smallsql/junit/TestLanguage/testBogusLocale()","rawLines":"/**\r\n\t * In case of wrong Locale, Language picks up the one corresponding to the\r\n\t * the current Locale.<br>\r\n\t */\r\n\tpublic void testBogusLocale() throws SQLException {\r\n\t\tLocale origLocale = Locale.getDefault();\r\n\t\tLocale.setDefault(Locale.ITALY);\r\n\t\t\r\n\t\tConnection conn = AllTests.createConnection(\"?locale=XXX\", null);\r\n\t\tStatement stat = conn.createStatement();\r\n\r\n\t\ttry {\r\n\t\t\trecreateTestTab(stat);\r\n\t\t\t\r\n\t\t\tstat.execute(\"CREATE TABLE \" + TABLE_NAME + \" (id_test INT)\");\r\n\t\t\tfail();\r\n\t\t}\r\n\t\tcatch (SQLException e) {\r\n\t\t\tassertMessage(e, \"La tabella/vista '\" + TABLE_NAME + \"' è già esistente.\");\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tLocale.setDefault(origLocale);\r\n\t\t\tconn.close();\r\n\t\t}\r\n\t}","startLine":11,"lastLine":16}],"window":5},{"content":"try{value = Integer.parseInt(token.getName(sql) );}catch(Exception e){throw createSyntaxError(token, MISSING_NUMBERVALUE );}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/datatype(boolean)","rawLines":"/**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }","startLine":91,"lastLine":95},{"locFile":"java+method:///smallsql/database/SQLParser/datatype(boolean)","rawLines":"/**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }","startLine":101,"lastLine":105}],"window":5},{"content":"buf.append('/');formatNumber( details.month+1, 2, buf);buf.append('/');formatNumber( details.day, 2, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":170,"lastLine":174},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":163,"lastLine":167}],"window":5},{"content":"if(token2 != null && token2.value == SQLTokenizer.POINT){expr.setNameAfterTableAlias( nextIdentifier() );}else{previousToken();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/expressionSingle(smallsql.database.Command,smallsql.database.SQLToken)","rawLines":"/**\r\n     * This method parse a single expression like 12, 'qwert', 0x3F or a column name.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     */\r\n    private Expression expressionSingle(Command cmd, SQLToken token) throws SQLException{\r\n        boolean isMinus = false;\r\n        if(token != null){\r\n            switch(token.value){\r\n                case SQLTokenizer.NULL:\r\n                        return new ExpressionValue( null, SQLTokenizer.NULL );\r\n                case SQLTokenizer.STRING:\r\n                        return new ExpressionValue( token.getName(null), SQLTokenizer.VARCHAR );\r\n                case SQLTokenizer.IDENTIFIER:\r\n                        {\r\n                        String name = getIdentifier( token );\r\n                        ExpressionName expr =  new ExpressionName( name );\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                            expr.setNameAfterTableAlias( nextIdentifier() );\r\n                        }else{\r\n                            previousToken();\r\n                        }\r\n                        return expr;\r\n                        }\r\n                case SQLTokenizer.TRUE:\r\n                        return new ExpressionValue( Boolean.TRUE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.FALSE:\r\n                        return new ExpressionValue( Boolean.FALSE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.ESCAPE_L:{\r\n                        token = nextToken(COMMANDS_ESCAPE);\r\n                        SQLToken para = nextToken(MISSING_EXPRESSION);\r\n                        Expression expr;\r\n                        switch(token.value){\r\n                            case SQLTokenizer.D: // date escape sequence\r\n                            \texpr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.DATE), SQLTokenizer.DATE );\r\n                            \tbreak;\r\n                            case SQLTokenizer.T: // time escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIME), SQLTokenizer.TIME );\r\n                            \tbreak;\r\n                            case SQLTokenizer.TS: // timestamp escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP );\r\n                            \tbreak;\r\n                            case SQLTokenizer.FN: // function escape sequence\r\n                            \tnextToken(MISSING_PARENTHESIS_L);\r\n                            \texpr = function(cmd, para, true);\r\n                            \tbreak;\r\n                            case SQLTokenizer.CALL: // call escape sequence\r\n                                throw new java.lang.UnsupportedOperationException(\"call escape sequence\");\r\n                            default: throw new Error();\r\n                        }\r\n                        token = nextToken( ESCAPE_MISSING_CLOSE );\r\n                        return expr;\r\n                }\r\n                case SQLTokenizer.QUESTION:\r\n                        ExpressionValue param = new ExpressionValue();\r\n                        cmd.addParameter( param );\r\n                        return param;\r\n                case SQLTokenizer.CASE:\r\n                \t\treturn caseExpr(cmd);\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.PLUS:\r\n                        // sign detection\r\n                        do{\r\n                            if(token.value == SQLTokenizer.MINUS)\r\n                                    isMinus = !isMinus;\r\n                            token = nextToken();\r\n                            if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        }while(token.value == SQLTokenizer.MINUS || token.value == SQLTokenizer.PLUS);\r\n                        // no Break\r\n                default:\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.PARENTHESIS_L){\r\n                            if(isMinus)\r\n                                return new ExpressionArithmetic( function( cmd, token, false ),  ExpressionArithmetic.NEGATIVE );\r\n                            return function( cmd, token, false );\r\n                        }else{\r\n                            // constant expression or identifier\r\n                            char chr1 = sql[ token.offset ];\r\n\t\t\t\t\t\t\tif(chr1 == '$'){\r\n\t\t\t\t\t\t\t\tpreviousToken();\r\n\t                            String tok = new String(sql, token.offset+1, token.length-1);\r\n                                if(isMinus) tok = \"-\" + tok;\r\n\t\t\t\t\t\t\t\treturn new ExpressionValue( new Money(Double.parseDouble(tok)), SQLTokenizer.MONEY );\r\n\t\t\t\t\t\t\t}\r\n                            String tok = new String(sql, token.offset, token.length);\r\n                            if((chr1 >= '0' && '9' >= chr1) || chr1 == '.'){\r\n                                previousToken();\r\n                                // first character is a digit\r\n                                if(token.length>1 && (sql[ token.offset +1 ] | 0x20) == 'x'){\r\n                                    // binary data as hex\r\n                                    if(isMinus) {\r\n                \t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_OPER_MINUS);\r\n                                    }\r\n                                    return new ExpressionValue( Utils.hex2bytes( sql, token.offset+2, token.length-2), SQLTokenizer.VARBINARY );\r\n                                }\r\n                                if(isMinus) tok = \"-\" + tok;\r\n                                if(Utils.indexOf( '.', sql, token.offset, token.length ) >= 0 ||\r\n                                   Utils.indexOf( 'e', sql, token.offset, token.length ) >= 0){\r\n                                    return new ExpressionValue( new Double(tok), SQLTokenizer.DOUBLE );\r\n                                }else{\r\n                                    try{\r\n                                        return new ExpressionValue( new Integer(tok), SQLTokenizer.INT );\r\n                                    }catch(NumberFormatException e){\r\n                                        return new ExpressionValue( new Long(tok), SQLTokenizer.BIGINT );\r\n                                    }\r\n                                }\r\n                            }else{\r\n                                // identifier\r\n                                checkValidIdentifier( tok, token );\r\n                                ExpressionName expr = new ExpressionName(tok);\r\n                                if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                                    expr.setNameAfterTableAlias( nextIdentifier() );\r\n                                }else{\r\n                                    previousToken();\r\n                                }\r\n                                if(isMinus)\r\n                                    return new ExpressionArithmetic( expr,  ExpressionArithmetic.NEGATIVE );\r\n                                return expr;\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return null;\r\n    }","startLine":111,"lastLine":115},{"locFile":"java+method:///smallsql/database/SQLParser/expressionSingle(smallsql.database.Command,smallsql.database.SQLToken)","rawLines":"/**\r\n     * This method parse a single expression like 12, 'qwert', 0x3F or a column name.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     */\r\n    private Expression expressionSingle(Command cmd, SQLToken token) throws SQLException{\r\n        boolean isMinus = false;\r\n        if(token != null){\r\n            switch(token.value){\r\n                case SQLTokenizer.NULL:\r\n                        return new ExpressionValue( null, SQLTokenizer.NULL );\r\n                case SQLTokenizer.STRING:\r\n                        return new ExpressionValue( token.getName(null), SQLTokenizer.VARCHAR );\r\n                case SQLTokenizer.IDENTIFIER:\r\n                        {\r\n                        String name = getIdentifier( token );\r\n                        ExpressionName expr =  new ExpressionName( name );\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                            expr.setNameAfterTableAlias( nextIdentifier() );\r\n                        }else{\r\n                            previousToken();\r\n                        }\r\n                        return expr;\r\n                        }\r\n                case SQLTokenizer.TRUE:\r\n                        return new ExpressionValue( Boolean.TRUE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.FALSE:\r\n                        return new ExpressionValue( Boolean.FALSE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.ESCAPE_L:{\r\n                        token = nextToken(COMMANDS_ESCAPE);\r\n                        SQLToken para = nextToken(MISSING_EXPRESSION);\r\n                        Expression expr;\r\n                        switch(token.value){\r\n                            case SQLTokenizer.D: // date escape sequence\r\n                            \texpr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.DATE), SQLTokenizer.DATE );\r\n                            \tbreak;\r\n                            case SQLTokenizer.T: // time escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIME), SQLTokenizer.TIME );\r\n                            \tbreak;\r\n                            case SQLTokenizer.TS: // timestamp escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP );\r\n                            \tbreak;\r\n                            case SQLTokenizer.FN: // function escape sequence\r\n                            \tnextToken(MISSING_PARENTHESIS_L);\r\n                            \texpr = function(cmd, para, true);\r\n                            \tbreak;\r\n                            case SQLTokenizer.CALL: // call escape sequence\r\n                                throw new java.lang.UnsupportedOperationException(\"call escape sequence\");\r\n                            default: throw new Error();\r\n                        }\r\n                        token = nextToken( ESCAPE_MISSING_CLOSE );\r\n                        return expr;\r\n                }\r\n                case SQLTokenizer.QUESTION:\r\n                        ExpressionValue param = new ExpressionValue();\r\n                        cmd.addParameter( param );\r\n                        return param;\r\n                case SQLTokenizer.CASE:\r\n                \t\treturn caseExpr(cmd);\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.PLUS:\r\n                        // sign detection\r\n                        do{\r\n                            if(token.value == SQLTokenizer.MINUS)\r\n                                    isMinus = !isMinus;\r\n                            token = nextToken();\r\n                            if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        }while(token.value == SQLTokenizer.MINUS || token.value == SQLTokenizer.PLUS);\r\n                        // no Break\r\n                default:\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.PARENTHESIS_L){\r\n                            if(isMinus)\r\n                                return new ExpressionArithmetic( function( cmd, token, false ),  ExpressionArithmetic.NEGATIVE );\r\n                            return function( cmd, token, false );\r\n                        }else{\r\n                            // constant expression or identifier\r\n                            char chr1 = sql[ token.offset ];\r\n\t\t\t\t\t\t\tif(chr1 == '$'){\r\n\t\t\t\t\t\t\t\tpreviousToken();\r\n\t                            String tok = new String(sql, token.offset+1, token.length-1);\r\n                                if(isMinus) tok = \"-\" + tok;\r\n\t\t\t\t\t\t\t\treturn new ExpressionValue( new Money(Double.parseDouble(tok)), SQLTokenizer.MONEY );\r\n\t\t\t\t\t\t\t}\r\n                            String tok = new String(sql, token.offset, token.length);\r\n                            if((chr1 >= '0' && '9' >= chr1) || chr1 == '.'){\r\n                                previousToken();\r\n                                // first character is a digit\r\n                                if(token.length>1 && (sql[ token.offset +1 ] | 0x20) == 'x'){\r\n                                    // binary data as hex\r\n                                    if(isMinus) {\r\n                \t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_OPER_MINUS);\r\n                                    }\r\n                                    return new ExpressionValue( Utils.hex2bytes( sql, token.offset+2, token.length-2), SQLTokenizer.VARBINARY );\r\n                                }\r\n                                if(isMinus) tok = \"-\" + tok;\r\n                                if(Utils.indexOf( '.', sql, token.offset, token.length ) >= 0 ||\r\n                                   Utils.indexOf( 'e', sql, token.offset, token.length ) >= 0){\r\n                                    return new ExpressionValue( new Double(tok), SQLTokenizer.DOUBLE );\r\n                                }else{\r\n                                    try{\r\n                                        return new ExpressionValue( new Integer(tok), SQLTokenizer.INT );\r\n                                    }catch(NumberFormatException e){\r\n                                        return new ExpressionValue( new Long(tok), SQLTokenizer.BIGINT );\r\n                                    }\r\n                                }\r\n                            }else{\r\n                                // identifier\r\n                                checkValidIdentifier( tok, token );\r\n                                ExpressionName expr = new ExpressionName(tok);\r\n                                if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                                    expr.setNameAfterTableAlias( nextIdentifier() );\r\n                                }else{\r\n                                    previousToken();\r\n                                }\r\n                                if(isMinus)\r\n                                    return new ExpressionArithmetic( expr,  ExpressionArithmetic.NEGATIVE );\r\n                                return expr;\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return null;\r\n    }","startLine":18,"lastLine":22}],"window":5},{"content":"con.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");assertRowCount( 0, \"Select * from transactions\");con.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");ResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE).executeQuery(\"Select * from transactions Where 1=0\");","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_Last(java.sql.Connection,boolean)","rawLines":"private void testInsertRow_Last(Connection con, boolean callLastBefore) throws Exception{\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\tif(callLastBefore) rs.last();\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.last();\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t\tassertTrue( rs.previous() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t}\r\n\t}","startLine":2,"lastLine":8},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_withWrongWhere()","rawLines":"/**\r\n     * If there was insert a row within the ResultSet that not map WHERE than you scroll to this row. If there an Insert\r\n     * outsite the ResultSet that not map the WHERE then you can't scroll this row.\r\n     * \r\n     * @throws Exception\r\n     */\r\n\tpublic void testInsertRow_withWrongWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":10,"lastLine":16}],"window":5},{"content":"break;case SQLTokenizer.TIMESTAMP:case SQLTokenizer.SMALLDATETIME:case SQLTokenizer.DATE:case SQLTokenizer.TIME:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":147,"lastLine":151},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":90,"lastLine":94},{"locFile":"java+method:///smallsql/database/ExpressionValue/initValue(smallsql.database.Expression)","rawLines":"/**\r\n     * Init a summary field with a Mutable \r\n     * @param expr the expression that produce the values which should be summary\r\n     * @throws Exception\r\n     */\r\n\tprivate void initValue(Expression expr) throws Exception{\r\n\t\tdataType = expr.getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tvalue = new MutableInteger(expr.getInt());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tvalue = new MutableLong(expr.getLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\tvalue = new MutableFloat(expr.getFloat());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tvalue = new MutableDouble(expr.getDouble());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tvalue = Money.createFromUnscaledValue(expr.getMoney());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tvalue = new MutableNumeric(expr.getNumeric());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\tvalue = new DateTime(expr.getLong(), dataType);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\t// is used for MAX and MIN\r\n\t\t\t\tvalue = expr.getObject();\r\n\t\t}\r\n\t}","startLine":30,"lastLine":34}],"window":5},{"content":"}else{shift += 16;listEnum.stack--;if(listEnum.stack<0) return -1; // no more entriesresult = listEnum.resultStack[listEnum.stack];","cloneLocs":[{"locFile":"java+method:///smallsql/database/LongTreeList/getPrevious(smallsql.database.LongTreeListEnum)","rawLines":"/**\r\n\t * Get the next long value from this list.\r\n     * If there are no more values then it return -1.\r\n\t * @return\r\n\t */\r\n\tfinal long getPrevious(LongTreeListEnum listEnum){\r\n\t\tint shift = (3-listEnum.stack) << 4;\r\n\t\tif(shift >= 64){ //a previous call of getNext() has return -1\r\n\t\t\tshift = 48;\r\n\t\t\toffset = 0;\r\n\t\t\tlistEnum.stack = 0;\r\n\t\t\tlistEnum.offsetStack[0] = 2 + pointerSize;\r\n\t\t\tloopToEndOfNode(listEnum);\r\n\t\t}else{\r\n\t\t\tsetPreviousOffset(listEnum);\r\n\t\t}\r\n\t\tlong result = listEnum.resultStack[listEnum.stack];\r\n\t\twhile(true){\r\n\t\t\tint nextEntry = (offset < 0) ? -1 : getUnsignedShort();\r\n\t\t\tif(nextEntry >= 0){\r\n\t\t\t\t// there are more entries in this node\r\n\t\t\t\tresult |= (((long)nextEntry) << shift);\r\n\t\t\t\tif(listEnum.stack>=3){\r\n\t\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset+pointerSize;\r\n\t\t\t\toffset = getPointer();\r\n\t\t\t\tshift -= 16;\r\n\t\t\t\tlistEnum.stack++;\r\n\t\t\t\tlistEnum.resultStack[listEnum.stack] = result;\r\n\t\t\t\tloopToEndOfNode(listEnum);\r\n\t\t\t}else{\r\n\t\t\t\t//no more entries in this node\r\n\t\t\t\tshift += 16;\r\n\t\t\t\tlistEnum.stack--;\r\n\t\t\t\tif(listEnum.stack<0) return -1; // no more entries\r\n\t\t\t\tresult = listEnum.resultStack[listEnum.stack];\r\n\t\t\t\tsetPreviousOffset(listEnum);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":32,"lastLine":37},{"locFile":"java+method:///smallsql/database/LongTreeList/getNext(smallsql.database.LongTreeListEnum)","rawLines":"/**\r\n\t * Get the next long value from this list. \r\n     * If there are no more values then it return -1.\r\n\t * @return\r\n\t */\r\n\tfinal long getNext(LongTreeListEnum listEnum){\r\n\t\tint shift = (3-listEnum.stack) << 4;\r\n\t\tif(shift >= 64) return -1; //a previous call has return -1\r\n\t\toffset \t\t= listEnum.offsetStack[listEnum.stack];\r\n\t\tlong result = listEnum.resultStack[listEnum.stack];\r\n\t\tboolean firstNode = (offset == 0); // true if it the first entry in a level\r\n\t\twhile(true){\r\n\t\t\tint nextEntry = getUnsignedShort();\r\n\t\t\tif(nextEntry != 0 || firstNode){\r\n\t\t\t\t//there are more entries in this node\r\n\t\t\t\tresult |= (((long)nextEntry) << shift);\r\n\t\t\t\tif(listEnum.stack>=3){\r\n\t\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset+pointerSize;\r\n\t\t\t\toffset = getPointer();\r\n\t\t\t\tshift -= 16;\r\n\t\t\t\tlistEnum.stack++;\r\n\t\t\t\tlistEnum.resultStack[listEnum.stack] = result;\r\n\t\t\t\tfirstNode = true;\r\n\t\t\t}else{\r\n\t\t\t\t//no more entries in this node\r\n\t\t\t\tshift += 16;\r\n\t\t\t\tlistEnum.stack--;\r\n\t\t\t\tif(listEnum.stack<0) return -1; // no more entries\r\n\t\t\t\tresult = listEnum.resultStack[listEnum.stack];\r\n\t\t\t\toffset = listEnum.offsetStack[listEnum.stack];\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":26,"lastLine":31}],"window":5},{"content":"rs = pr.getGeneratedKeys();assertNotNull(\"RETURN_GENERATED_KEYS\", rs);assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));assertRowCount(1,rs);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":18,"lastLine":22},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":41,"lastLine":45},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":26,"lastLine":30},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":56,"lastLine":60}],"window":5},{"content":"return null;}return node.addRoot();}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/add(smallsql.database.IndexNode,long,long,boolean,int)","rawLines":"/**\r\n\t * The key has a binary sort order. This means the most significant byte is in the high byte.\r\n\t * @param digitCount The count of 16Bit digits.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, long key, boolean isLastValue, int digitCount) throws SQLException{\r\n\t\tfor(int i=digitCount-1; i>=0; i--){\r\n\t\t\tchar digit = (char)(key >> (i<<4));\r\n\t\t\tif(i == 0){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i);\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.saveValue( rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\tthrow new Error();\r\n\t}","startLine":25,"lastLine":29},{"locFile":"java+method:///smallsql/database/Index/add(smallsql.database.IndexNode,long,char%5B%5D,boolean)","rawLines":"/**\r\n\t * Add a byte array to the Index.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, char[] key, boolean isLast) throws SQLException{\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tif(++i == length){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i );\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.saveValue(rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":28,"lastLine":32}],"window":5},{"content":"assertNotNull(\"RETURN_GENERATED_KEYS\", rs);assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));assertRowCount(1,rs);}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":53,"lastLine":57},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":57,"lastLine":61}],"window":5},{"content":"assertEquals(0, rs.getRow());assertFalse(rs.isLast());assertFalse(rs.isFirst());assertFalse(rs.isBeforeFirst());assertTrue(rs.isAfterLast());","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelativeAssert(java.sql.ResultSet)","rawLines":"private void testAbsoluteRelativeAssert(ResultSet rs) throws SQLException{\r\n        assertEquals(0, rs.getRow());\r\n        \r\n        assertTrue(rs.absolute(2));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n\r\n        assertTrue(rs.relative(-1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n\r\n        assertTrue(rs.absolute(1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n        assertTrue(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(1));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.absolute(-1));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(0));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertTrue(rs.last());\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n    }","startLine":35,"lastLine":39},{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelativeAssert(java.sql.ResultSet)","rawLines":"private void testAbsoluteRelativeAssert(ResultSet rs) throws SQLException{\r\n        assertEquals(0, rs.getRow());\r\n        \r\n        assertTrue(rs.absolute(2));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n\r\n        assertTrue(rs.relative(-1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n\r\n        assertTrue(rs.absolute(1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n        assertTrue(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(1));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.absolute(-1));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(0));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertTrue(rs.last());\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n    }","startLine":54,"lastLine":58}],"window":5},{"content":"assertRowCount( 0, \"Select * from transactions\");con.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");assertRowCount( 1, \"Select * from transactions\");con.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");assertRowCount( 2, \"Select * from transactions\");","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testRollback()","rawLines":"public void testRollback() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t    con.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) (Select v From transactions)\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.rollback();\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":5,"lastLine":11},{"locFile":"java+method:///smallsql/junit/TestTransactions/testCommit()","rawLines":"public void testCommit() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Select v From transactions\");\r\n\t\t\tassertRowCount( 2, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions Select * From transactions\");\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertRowCount( 4, \"Select * from transactions\");\r\n\t\t\t\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":5,"lastLine":11}],"window":5},{"content":"this.offset = valueOffset;if(readBoolean()) return null;switch(dataType){case SQLTokenizer.BIT:case SQLTokenizer.BOOLEAN:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getNumeric(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBigDecimal()\r\n     */\r\n    @Override\r\n    MutableNumeric getNumeric(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":5,"lastLine":9},{"locFile":"java+method:///smallsql/database/StoreImpl/getObject(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getObject()\r\n     */\r\n    @Override\r\n    Object getObject(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n                    return Utils.getInteger( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return Utils.getInteger( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return Utils.getInteger(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue(readLong());\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME );\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE );\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":5,"lastLine":9}],"window":5},{"content":"for(int i=0; i<length; i++){result = (result << 8) | (bytes[i] & 0xFF);}return result;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Utils/bytes2int(byte%5B%5D)","rawLines":"static int bytes2int( byte[] bytes ){\r\n        int result = 0;\r\n        int length = Math.min( 4, bytes.length);\r\n        for(int i=0; i<length; i++){\r\n            result = (result << 8) | (bytes[i] & 0xFF);\r\n        }\r\n        return result;\r\n    }","startLine":3,"lastLine":7},{"locFile":"java+method:///smallsql/database/Utils/bytes2long(byte%5B%5D)","rawLines":"static long bytes2long( byte[] bytes ){\r\n        long result = 0;\r\n        int length = Math.min( 8, bytes.length);\r\n        for(int i=0; i<length; i++){\r\n            result = (result << 8) | (bytes[i] & 0xFF);\r\n        }\r\n        return result;\r\n    }","startLine":3,"lastLine":7}],"window":5},{"content":"break;case SQLTokenizer.VARCHAR:case SQLTokenizer.NVARCHAR:case SQLTokenizer.LONGVARCHAR:case SQLTokenizer.LONGNVARCHAR:","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.IndexNode,smallsql.database.Expression,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}","startLine":45,"lastLine":49},{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":39,"lastLine":43}],"window":5},{"content":"public void init(){if(init) return;try{Connection con = AllTests.getConnection();dropTable( con, table1 );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestGroupBy/init()","rawLines":"public void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(name varchar(30), id int )\");\r\n\t\t\t//st.execute(\"create table \" + table2 + \"(c \" + testValue.dataType +\", d \" + testValue.dataType + \")\");\r\n\t\t\t//st.execute(\"create table \" + table3 + \"(c \" + testValue.dataType +\", d \" + testValue.dataType + \")\");\r\n\t\t\tst.close();\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(name, id) Values(?,?)\");\r\n\t\t\tpr.setString( 1, STR_VALUE1);\r\n\t\t\tpr.setInt( 2, 1 );\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, STR_VALUE1);\r\n\t\t\tpr.setInt( 2, 2 );\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, STR_VALUE1);\r\n\t\t\tpr.setNull( 2, Types.INTEGER );\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, STR_VALUE2);\r\n\t\t\tpr.setInt( 2, 1 );\r\n\t\t\tpr.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}","startLine":0,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/init()","rawLines":"public void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tdropTable( con, table2 );\r\n\t\t\tdropTable( con, table3 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(v varchar(30), c char(30), nv nvarchar(30),i int, d float, r real, bi bigint, b boolean)\");\r\n\t\t\tst.execute(\"create table \" + table2 + \"(c2 char(30))\");\r\n\t\t\tst.execute(\"create table \" + table3 + \"(vc varchar(30), vb varbinary(30))\");\r\n\t\t\tst.close();\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(v,c,nv,i,d,r,bi,b) Values(?,?,?,?,?,?,?,?)\");\r\n\t\t\tPreparedStatement pr2= con.prepareStatement(\"INSERT into \" + table2 + \"(c2) Values(?)\");\r\n\t\t\tfor(int i=150; i>-10; i--){\r\n\t\t\t\tpr.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr.setString( 2, String.valueOf(i));\r\n\t\t\t\tpr.setString( 3, String.valueOf( (char)i ));\r\n\t\t\t\tpr.setInt   ( 4, i );\r\n\t\t\t\tpr.setDouble( 5, i );\r\n\t\t\t\tpr.setFloat ( 6, i );\r\n\t\t\t\tpr.setInt   ( 7, i );\r\n\t\t\t\tpr.setBoolean( 8, i == 0 );\r\n\t\t\t\tpr.execute();\r\n\t\t\t\tpr2.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr2.execute();\r\n\t\t\t\tvalueCount++;\r\n\t\t\t}\r\n\t\t\tpr.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 2, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 3, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 4, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 5, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 6, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 7, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 8, null, Types.VARCHAR);\r\n\t\t\tpr.execute();\r\n\t\t\tpr2.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr2.execute();\r\n\t\t\tpr2.setString( 1, \"\");\r\n\t\t\tpr2.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tpr = con.prepareStatement(\"INSERT into \" + table3 + \"(vc, vb) Values(?,?)\");\r\n\t\t\tpr.setString( 1, table3);\r\n\t\t\tpr.setBytes( 2, table3.getBytes());\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, \"\");\r\n\t\t\tpr.setBytes( 2, new byte[0]);\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, null);\r\n\t\t\tpr.setBytes( 2, null);\r\n\t\t\tpr.execute();\r\n\t\t\t\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}","startLine":0,"lastLine":4}],"window":5},{"content":"init();Connection con = AllTests.getConnection();Statement st = con.createStatement();ResultSet rs;Integer oldValue;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_int_desc()","rawLines":"public void testOrderBy_int_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tInteger newValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_int()","rawLines":"public void testOrderBy_int() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_int_asc()","rawLines":"public void testOrderBy_int_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5}],"window":5},{"content":"st.close();}catch(Throwable e){e.printStackTrace();}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestAlterTable/setUp()","rawLines":"public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(i int, v varchar(100))\");\r\n            st.execute(\"Insert into \" + table + \" Values(1,'abc')\");\r\n            st.execute(\"Insert into \" + table + \" Values(2,'bcd')\");\r\n            st.execute(\"Insert into \" + table + \" Values(3,'cde')\");\r\n            st.execute(\"Insert into \" + table + \" Values(4,'def')\");\r\n            st.execute(\"Insert into \" + table + \" Values(5,'efg')\");\r\n            st.execute(\"Insert into \" + table + \" Values(6,'fgh')\");\r\n            st.execute(\"Insert into \" + table + \" Values(7,'ghi')\");\r\n            st.execute(\"Insert into \" + table + \" Values(8,'hij')\");\r\n            st.execute(\"Insert into \" + table + \" Values(9,'ijk')\");\r\n            st.execute(\"Insert into \" + table + \" Values(10,'jkl')\");\r\n            st.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }","startLine":16,"lastLine":20},{"locFile":"java+method:///smallsql/junit/TestFunctions/setUp()","rawLines":"public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(aInt int, aVarchar varchar(100))\");\r\n            st.execute(\"Insert into \" + table + \"(aInt, aVarchar) Values(-120,'qwert')\");\r\n            st.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }","startLine":7,"lastLine":11}],"window":5},{"content":"Connection con = AllTests.getConnection();Statement st = con.createStatement();int isolation = con.getTransactionIsolation();con.setAutoCommit(false);try{","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestAlterTable/testAddWithTableLock_REPEATABLE_READ()","rawLines":"public void testAddWithTableLock_REPEATABLE_READ() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        int isolation = con.getTransactionIsolation();\r\n        con.setAutoCommit(false);\r\n        try{\r\n            con.setTransactionIsolation( Connection.TRANSACTION_REPEATABLE_READ );\r\n            ResultSet rs = st.executeQuery(\"Select * From \" + table);\r\n            rs.next();\r\n            try {\r\n                st.execute(\"Alter Table \" + table + \" Add a Varchar(20)\");\r\n                fail(\"Alter Table should not work on a table with a lock.\");\r\n            } catch (SQLException ex) {\r\n                assertSQLException( \"01000\", 0, ex );\r\n            }\r\n            rs.next();\r\n        }finally{\r\n            con.setTransactionIsolation(isolation);\r\n            con.setAutoCommit(true);\r\n        }\r\n    }","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestAlterTable/testAddWithTableLock_READ_COMMITTED()","rawLines":"public void testAddWithTableLock_READ_COMMITTED() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        int isolation = con.getTransactionIsolation();\r\n        con.setAutoCommit(false);\r\n        try{\r\n            con.setTransactionIsolation( Connection.TRANSACTION_READ_COMMITTED );\r\n            ResultSet rs = st.executeQuery(\"Select * From \" + table);\r\n            rs.next();\r\n            st.execute(\"Alter Table \" + table + \" Add a Varchar(20)\");\r\n            try {\r\n                rs.next();\r\n                fail(\"Alter Table should not work on a table with a lock.\");\r\n            } catch (SQLException ex) {\r\n                assertSQLException( \"01000\", 0, ex );\r\n            }\r\n        }finally{\r\n            con.setTransactionIsolation(isolation);\r\n            con.setAutoCommit(true);\r\n        }\r\n    }","startLine":1,"lastLine":5}],"window":5},{"content":"fail(\"Exception should throw\");}catch(SQLException ex){assertSQLException(\"HY010\", 0, ex);}try{","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testClosedPreparedStatement()","rawLines":"public void testClosedPreparedStatement() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        PreparedStatement pr = con.prepareStatement(\"Select ?\");\r\n        pr.setInt(1, 1);\r\n        pr.close();\r\n        try{\r\n            pr.setInt(1, 1);\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.execute();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.executeQuery();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.executeUpdate();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n    }","startLine":19,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testClosedStatement()","rawLines":"public void testClosedStatement() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        st.close();\r\n        try{\r\n            st.execute(\"Select 1\");\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            st.executeQuery(\"Select 1\");\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            st.executeUpdate(\"Select 1\");\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n    }","startLine":6,"lastLine":10},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testClosedPreparedStatement()","rawLines":"public void testClosedPreparedStatement() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        PreparedStatement pr = con.prepareStatement(\"Select ?\");\r\n        pr.setInt(1, 1);\r\n        pr.close();\r\n        try{\r\n            pr.setInt(1, 1);\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.execute();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.executeQuery();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.executeUpdate();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n    }","startLine":7,"lastLine":11},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testClosedPreparedStatement()","rawLines":"public void testClosedPreparedStatement() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        PreparedStatement pr = con.prepareStatement(\"Select ?\");\r\n        pr.setInt(1, 1);\r\n        pr.close();\r\n        try{\r\n            pr.setInt(1, 1);\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.execute();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.executeQuery();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.executeUpdate();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n    }","startLine":13,"lastLine":17},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testClosedStatement()","rawLines":"public void testClosedStatement() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        st.close();\r\n        try{\r\n            st.execute(\"Select 1\");\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            st.executeQuery(\"Select 1\");\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            st.executeUpdate(\"Select 1\");\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n    }","startLine":12,"lastLine":16}],"window":5},{"content":"}finally{System.out.println();System.out.println(\"===================================================================\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepare(java.sql.Connection)","rawLines":"/**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":41,"lastLine":45},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRows(java.sql.Connection)","rawLines":"/**\r\n      *  7. Test\r\n      *  Update rows with the method updateRow().\r\n      */  \r\n    static void test_UpdateRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with updateRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            int colCount = rs.getMetaData().getColumnCount();\r\n            long time = -System.currentTimeMillis();\r\n            int count = 0;\r\n            while(rs.next()){\r\n                for (int i=2; i<=colCount; i++){\r\n                    rs.updateObject( i, rs.getObject(i) );\r\n                }\r\n                rs.updateRow();\r\n                count++;\r\n            }\r\n            time += System.currentTimeMillis();\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were updated.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\" + e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":28,"lastLine":32},{"locFile":"java+method:///smallsql/junit/BenchTest/test_RowRequestPages(java.sql.Connection)","rawLines":"/**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":53,"lastLine":57},{"locFile":"java+method:///smallsql/junit/BenchTest/test_Scroll_getXXX(java.sql.Connection)","rawLines":"/**\r\n      *  11. Test\r\n      *  Scroll and call the getXXX methods for every columns.\r\n      */  \r\n    static void test_Scroll_getXXX(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test scroll and call the getXXX methods for every columns: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            long time = -System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            for (int i=0; i<rowCount; i++){\r\n                    rs.next();\r\n\t                rs.getInt   (  1 );\r\n\t                rs.getBytes (  2 );\r\n\t                rs.getString(  3 );\r\n\t                rs.getDate  (  4 );\r\n\t                rs.getFloat (  5 );\r\n\t                rs.getFloat (  6 );\r\n\t                rs.getBytes (  7 );\r\n\t                rs.getInt   (  8 );\r\n\t                rs.getDouble(  9 );\r\n\t                rs.getDouble(  10 );\r\n\t                rs.getFloat (  11 );\r\n\t                rs.getTime  (  12 );\r\n\t                rs.getShort (  13 );\r\n\t                rs.getFloat (  14 );\r\n\t                rs.getString(  15 );\r\n\t                rs.getString(  16 );\r\n\t                rs.getByte  (  17 );\r\n\t                rs.getBytes (  18 );\r\n\t                rs.getString(  19 );\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":39,"lastLine":43},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateLargeBinary(java.sql.Connection)","rawLines":"/**\r\n      *  12. Test\r\n      *  Update large binary data.\r\n      */  \r\n    static void test_UpdateLargeBinary(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            PreparedStatement pr = con.prepareStatement(\"Update \" + tableName + \" set im=? WHERE pr=1\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":28,"lastLine":32},{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteRows(java.sql.Connection)","rawLines":"/**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":45,"lastLine":49},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertEmptyRows(java.sql.Connection)","rawLines":"/**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":26,"lastLine":30},{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteAll(java.sql.Connection)","rawLines":"/**\r\n      *  2. Test\r\n      *  Delete all rows with a single statement.\r\n      */  \r\n    static void test_DeleteAll(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete all rows: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":17,"lastLine":21},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertClassic(java.sql.Connection)","rawLines":"/**\r\n      *  1. Test\r\n      *  Insert rows with default values with a classic insert statement.\r\n      */  \r\n    static void test_InsertClassic(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with default values with a classic insert statement: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                st.execute(\"INSERT INTO \" + tableName + \"(i) VALUES(\" + i +\")\");\r\n            }\r\n            time += System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":24,"lastLine":28},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepareBatch(java.sql.Connection)","rawLines":"/**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":47,"lastLine":51},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateLargeBinaryWithSP(java.sql.Connection)","rawLines":"/**\r\n      *  12. Test\r\n      *  Update large binary data with a SP.\r\n      */  \r\n    static void test_UpdateLargeBinaryWithSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data with a SP: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"CREATE PROCEDURE #UpdateLargeBinary(@im image) as Update \" + tableName + \" set im=@im WHERE pr=2\");\r\n            PreparedStatement pr = con.prepareStatement(\"exec #UpdateLargeBinary ?\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            st.execute(\"DROP PROCEDURE #UpdateLargeBinary\");\r\n            st.close();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":32,"lastLine":36}],"window":5},{"content":"oldValue = newValue;count++;}assertEquals( valueCount, count );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar()","rawLines":"public void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":24},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_function()","rawLines":"public void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":19,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_bigint_withDoublicateValues()","rawLines":"public void test_bigint_withDoublicateValues() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT bi/2 bi_2 FROM \" + table1 + \" ORDER  by (bi/2)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tLong newValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\tassertTrue( oldValue + \"<=\"+newValue, oldValue.compareTo( newValue ) <= 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":24}],"window":5},{"content":"if(!next()){return false;}}}else{","cloneLocs":[{"locFile":"java+method:///smallsql/database/SortedResult/absolute(int)","rawLines":"boolean absolute(int newRow) throws Exception{\r\n        if(newRow == 0) throw SmallSQLException.create(Language.ROW_0_ABSOLUTE);\r\n        if(newRow > 0){\r\n            beforeFirst();\r\n            while(newRow-- > 0){\r\n                if(!next()){\r\n                    return false;\r\n                }\r\n            }\r\n        }else{\r\n            afterLast();\r\n            while(newRow++ < 0){\r\n                if(!previous()){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","startLine":5,"lastLine":9},{"locFile":"java+method:///smallsql/database/SortedResult/relative(int)","rawLines":"boolean relative(int rows) throws Exception{\r\n        if(rows == 0) return (row != 0);\r\n        if(rows > 0){\r\n            while(rows-- > 0){\r\n                if(!next()){\r\n                    return false;\r\n                }\r\n            }\r\n        }else{\r\n            while(rows++ < 0){\r\n                if(!previous()){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","startLine":4,"lastLine":8}],"window":5},{"content":"puffer[ offset++ ] = (byte)(value >> 24);puffer[ offset++ ] = (byte)(value >> 16);puffer[ offset++ ] = (byte)(value >> 8);puffer[ offset++ ] = (byte)(value);}","cloneLocs":[{"locFile":"java+method:///smallsql/database/MemoryStream/writeInt(int)","rawLines":"void writeInt(int value){\r\n\t\tverifyFreePufferSize(4);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 24);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 16);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 8);\r\n\t\tpuffer[ offset++ ] = (byte)(value);\r\n\t}","startLine":2,"lastLine":6},{"locFile":"java+method:///smallsql/database/MemoryStream/writeLong(long)","rawLines":"void writeLong(long value){\r\n\t\tverifyFreePufferSize(8);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 56);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 48);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 40);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 32);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 24);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 16);\r\n\t\tpuffer[ offset++ ] = (byte)(value >> 8);\r\n\t\tpuffer[ offset++ ] = (byte)(value);\r\n\t}","startLine":6,"lastLine":10}],"window":5},{"content":"buf.append( SHORT_MONTHS[ details.month ]);buf.append(' ');formatNumber( details.day, 2, buf);buf.append(',');buf.append(' ');","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":107,"lastLine":111},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":115,"lastLine":119}],"window":5},{"content":"return 10;case SQLTokenizer.BIGINT:case SQLTokenizer.MONEY:return 19;case SQLTokenizer.REAL:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/getDisplaySize(int,int,int)","rawLines":"static int getDisplaySize(int dataType, int precision, int scale){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn 1; // 1 and 0\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 5; //true and false\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 6;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n            case SQLTokenizer.REAL:\r\n                return 13;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 17;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.BLOB:\r\n            case SQLTokenizer.CLOB:\r\n            case SQLTokenizer.NCLOB:\r\n\t\t\t\treturn Integer.MAX_VALUE;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\treturn precision + (scale>0 ? 2 : 1);\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\treturn 2 + precision*2;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                return 21;\r\n\t\t\tdefault:\r\n\t\t\t\treturn precision;\r\n\t\t}\r\n\t}","startLine":11,"lastLine":15},{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/getDataTypePrecision(int,int)","rawLines":"static int getDataTypePrecision(int dataType, int defaultValue){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.NULL:\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 1;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 5;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn 7;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 15;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\tif(defaultValue == -1)\r\n\t\t\t\t\treturn 0xFFFF;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                if(defaultValue == -1)\r\n                    return 38;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\treturn 23;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\treturn 8;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn 16;\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\treturn 36;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn Integer.MAX_VALUE;\r\n\t\t}\r\n\t\tif(defaultValue == -1)\r\n\t\t\tthrow new Error(\"Precision:\"+SQLTokenizer.getKeyWord(dataType));\r\n\t\treturn defaultValue;\r\n\t}","startLine":13,"lastLine":17}],"window":5},{"content":"break;default:throw new Error(String.valueOf(expr.getDataType()));}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.IndexNode,smallsql.database.Expression,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}","startLine":71,"lastLine":76},{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":64,"lastLine":69}],"window":5},{"content":"if(longValue < 0)return -1;if(longValue > 0)return 1;return 0;","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionSign/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(param1.isNull()) return 0;\r\n\t\tswitch(ExpressionArithmetic.getBestNumberDataType(param1.getDataType())){\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tint intValue = param1.getInt();\r\n\t\t\t\tif(intValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(intValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tlong longValue = param1.getLong();\r\n\t\t\t\tif(longValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(longValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tlongValue = param1.getMoney();\r\n\t\t\t\tif(longValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(longValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\treturn param1.getNumeric().getSignum();\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tdouble doubleValue = param1.getDouble();\r\n\t\t\t\tif(doubleValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(doubleValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error();\r\n\t\t}\r\n\t}","startLine":12,"lastLine":16},{"locFile":"java+method:///smallsql/database/ExpressionFunctionSign/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(param1.isNull()) return 0;\r\n\t\tswitch(ExpressionArithmetic.getBestNumberDataType(param1.getDataType())){\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tint intValue = param1.getInt();\r\n\t\t\t\tif(intValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(intValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tlong longValue = param1.getLong();\r\n\t\t\t\tif(longValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(longValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tlongValue = param1.getMoney();\r\n\t\t\t\tif(longValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(longValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\treturn param1.getNumeric().getSignum();\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tdouble doubleValue = param1.getDouble();\r\n\t\t\t\tif(doubleValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(doubleValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error();\r\n\t\t}\r\n\t}","startLine":19,"lastLine":23}],"window":5},{"content":"init();Connection con = AllTests.getConnection();Statement st = con.createStatement();ResultSet rs;String oldValue;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar()","rawLines":"public void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_nvarchar()","rawLines":"public void testOrderBy_nvarchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by nv\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( String.CASE_INSENSITIVE_ORDER.compare( oldValue, rs.getString(\"nv\") ) <= 0 );\r\n\t\t\toldValue = rs.getString(\"nv\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_asc()","rawLines":"public void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_Join()","rawLines":"public void testOrderBy_varchar_Join() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" t1 Inner join \"+table2+\" t2 on t1.c=t2.c2  ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"v\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"v\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testUnion()","rawLines":"public void testUnion() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT v, 5 as Const FROM \" + table1 + \" Union All Select vc, 6 From \" + table3 + \" ORDER by v\");\r\n\t\t\r\n\t\tassertRSMetaData(rs, new String[]{\"v\", \"Const\"}, new int[]{Types.VARCHAR, Types.INTEGER});\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 3;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+4, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_GroupBy()","rawLines":"public void testOrderBy_varchar_GroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT first(v) cc FROM \" + table1 + \" Group By i ORDER  by first(V)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"cc\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"cc\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_DescAsc()","rawLines":"public void testOrderBy_varchar_DescAsc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc, i asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_char()","rawLines":"public void testOrderBy_char() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by c\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"c\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_desc()","rawLines":"public void testOrderBy_varchar_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":5}],"window":5},{"content":"value = str;break;case SQLTokenizer.NUMERIC:case SQLTokenizer.DECIMAL:MutableNumeric newValue = expr.getNumeric();","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":137,"lastLine":141},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":80,"lastLine":84}],"window":5},{"content":"return new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));} catch (Exception e) {throw SmallSQLException.createFromException(e);}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getIndexInfo(java.lang.String,java.lang.String,java.lang.String,boolean,boolean)","rawLines":"public ResultSet getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"NON_UNIQUE\", \"INDEX_QUALIFIER\", \"INDEX_NAME\", \"TYPE\", \"ORDINAL_POSITION\", \"COLUMN_NAME\", \"ASC_OR_DESC\", \"CARDINALITY\", \"PAGES\", \"FILTER_CONDITION\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getIndexInfo(con, table, unique);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":4,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getCrossReference(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)","rawLines":"public ResultSet getCrossReference(String primaryCatalog, String primarySchema, String primaryTable, String foreignCatalog, String foreignSchema, String foreignTable) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"PKTABLE_CAT\", \"PKTABLE_SCHEM\", \"PKTABLE_NAME\", \"PKCOLUMN_NAME\", \"FKTABLE_CAT\", \"FKTABLE_SCHEM\", \"FKTABLE_NAME\", \"FKCOLUMN_NAME\", \"KEY_SEQ\", \"UPDATE_RULE\", \"DELETE_RULE\", \"FK_NAME\", \"PK_NAME\", \"DEFERRABILITY\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getReferenceKeys(con, primaryTable, foreignTable);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":4,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getColumns(java.lang.String,java.lang.String,java.lang.String,java.lang.String)","rawLines":"public ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getColumns(con, tableNamePattern, columnNamePattern);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":4,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getBestRowIdentifier(java.lang.String,java.lang.String,java.lang.String,int,boolean)","rawLines":"public ResultSet getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getBestRowIdentifier(con, table);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":4,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getVersionColumns(java.lang.String,java.lang.String,java.lang.String)","rawLines":"public ResultSet getVersionColumns(String catalog, String schema, String table) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n\t\t\tObject[][] data   = new Object[0][0];\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":4,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getPrimaryKeys(java.lang.String,java.lang.String,java.lang.String)","rawLines":"public ResultSet getPrimaryKeys(String catalog, String schema, String table) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"KEY_SEQ\", \"PK_NAME\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getPrimaryKeys(con, table);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":4,"lastLine":8}],"window":5},{"content":"fail(\"SQLException 'ResultSet is forward only' should be throw\");}catch(SQLException e){assertSQLException(\"01000\", 0, e);}try{","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testForwardOnly()","rawLines":"public void testForwardOnly() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table ExceptionMethods(v varchar(30))\");\r\n\r\n            con.createStatement().execute(\"Insert Into ExceptionMethods(v) Values('qwert')\");\r\n\r\n            ResultSet rs = con.createStatement().executeQuery(\"Select * from ExceptionMethods\");\r\n            assertEquals(true, rs.next());\r\n\r\n            try{\r\n                rs.isBeforeFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.first();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.previous();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.last();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isAfterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.afterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.absolute(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.relative(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"ExceptionMethods\");\r\n        }\r\n    }","startLine":12,"lastLine":17},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testForwardOnly()","rawLines":"public void testForwardOnly() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table ExceptionMethods(v varchar(30))\");\r\n\r\n            con.createStatement().execute(\"Insert Into ExceptionMethods(v) Values('qwert')\");\r\n\r\n            ResultSet rs = con.createStatement().executeQuery(\"Select * from ExceptionMethods\");\r\n            assertEquals(true, rs.next());\r\n\r\n            try{\r\n                rs.isBeforeFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.first();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.previous();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.last();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isAfterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.afterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.absolute(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.relative(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"ExceptionMethods\");\r\n        }\r\n    }","startLine":40,"lastLine":45},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testForwardOnly()","rawLines":"public void testForwardOnly() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table ExceptionMethods(v varchar(30))\");\r\n\r\n            con.createStatement().execute(\"Insert Into ExceptionMethods(v) Values('qwert')\");\r\n\r\n            ResultSet rs = con.createStatement().executeQuery(\"Select * from ExceptionMethods\");\r\n            assertEquals(true, rs.next());\r\n\r\n            try{\r\n                rs.isBeforeFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.first();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.previous();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.last();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isAfterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.afterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.absolute(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.relative(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"ExceptionMethods\");\r\n        }\r\n    }","startLine":68,"lastLine":73},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testForwardOnly()","rawLines":"public void testForwardOnly() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table ExceptionMethods(v varchar(30))\");\r\n\r\n            con.createStatement().execute(\"Insert Into ExceptionMethods(v) Values('qwert')\");\r\n\r\n            ResultSet rs = con.createStatement().executeQuery(\"Select * from ExceptionMethods\");\r\n            assertEquals(true, rs.next());\r\n\r\n            try{\r\n                rs.isBeforeFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.first();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.previous();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.last();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isAfterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.afterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.absolute(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.relative(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"ExceptionMethods\");\r\n        }\r\n    }","startLine":54,"lastLine":59},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testForwardOnly()","rawLines":"public void testForwardOnly() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table ExceptionMethods(v varchar(30))\");\r\n\r\n            con.createStatement().execute(\"Insert Into ExceptionMethods(v) Values('qwert')\");\r\n\r\n            ResultSet rs = con.createStatement().executeQuery(\"Select * from ExceptionMethods\");\r\n            assertEquals(true, rs.next());\r\n\r\n            try{\r\n                rs.isBeforeFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.first();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.previous();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.last();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isAfterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.afterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.absolute(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.relative(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"ExceptionMethods\");\r\n        }\r\n    }","startLine":26,"lastLine":31},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testForwardOnly()","rawLines":"public void testForwardOnly() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table ExceptionMethods(v varchar(30))\");\r\n\r\n            con.createStatement().execute(\"Insert Into ExceptionMethods(v) Values('qwert')\");\r\n\r\n            ResultSet rs = con.createStatement().executeQuery(\"Select * from ExceptionMethods\");\r\n            assertEquals(true, rs.next());\r\n\r\n            try{\r\n                rs.isBeforeFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.first();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.previous();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.last();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isAfterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.afterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.absolute(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.relative(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"ExceptionMethods\");\r\n        }\r\n    }","startLine":33,"lastLine":38},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testForwardOnly()","rawLines":"public void testForwardOnly() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table ExceptionMethods(v varchar(30))\");\r\n\r\n            con.createStatement().execute(\"Insert Into ExceptionMethods(v) Values('qwert')\");\r\n\r\n            ResultSet rs = con.createStatement().executeQuery(\"Select * from ExceptionMethods\");\r\n            assertEquals(true, rs.next());\r\n\r\n            try{\r\n                rs.isBeforeFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.first();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.previous();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.last();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isAfterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.afterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.absolute(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.relative(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"ExceptionMethods\");\r\n        }\r\n    }","startLine":19,"lastLine":24},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testForwardOnly()","rawLines":"public void testForwardOnly() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table ExceptionMethods(v varchar(30))\");\r\n\r\n            con.createStatement().execute(\"Insert Into ExceptionMethods(v) Values('qwert')\");\r\n\r\n            ResultSet rs = con.createStatement().executeQuery(\"Select * from ExceptionMethods\");\r\n            assertEquals(true, rs.next());\r\n\r\n            try{\r\n                rs.isBeforeFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.first();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.previous();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.last();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isAfterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.afterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.absolute(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.relative(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"ExceptionMethods\");\r\n        }\r\n    }","startLine":61,"lastLine":66},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testForwardOnly()","rawLines":"public void testForwardOnly() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table ExceptionMethods(v varchar(30))\");\r\n\r\n            con.createStatement().execute(\"Insert Into ExceptionMethods(v) Values('qwert')\");\r\n\r\n            ResultSet rs = con.createStatement().executeQuery(\"Select * from ExceptionMethods\");\r\n            assertEquals(true, rs.next());\r\n\r\n            try{\r\n                rs.isBeforeFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isFirst();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.first();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.previous();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.last();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.isAfterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.afterLast();\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.absolute(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\r\n            try{\r\n                rs.relative(1);\r\n                fail(\"SQLException 'ResultSet is forward only' should be throw\");\r\n            }catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n        }finally{\r\n            dropTable(con, \"ExceptionMethods\");\r\n        }\r\n    }","startLine":47,"lastLine":52}],"window":5},{"content":"assertRSMetaData( rs, colNames, colTypes);assertTrue( \"No row\", rs.next() );assertEquals( \"a\", rs.getObject(\"COLUMN_NAME\") );assertEquals( \"INT\", rs.getObject(\"TYPE_NAME\") );assertEquals( \"5\", rs.getObject(\"COLUMN_Def\") );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestDBMetaData/testGetColumn()","rawLines":"public void testGetColumn() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tdropTable(con,\"tableColumns\");\r\n\t\tdropView( con, \"viewColumns\");\r\n\t\tcon.createStatement().execute(\"create table tableColumns(a int default 5)\");\r\n\t\tDatabaseMetaData md = con.getMetaData();\r\n\t\t\r\n\t\tResultSet rs = md.getColumns(null, null, \"tableColumns\", null);\r\n        String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.VARCHAR, Types.INTEGER, Types.NULL, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.NULL, Types.VARCHAR, Types.NULL, Types.NULL, Types.INTEGER, Types.INTEGER, Types.VARCHAR};\r\n\t\tassertRSMetaData( rs, colNames, colTypes);\t\t\r\n\t\tassertTrue( \"No row\", rs.next() );\r\n\t\tassertEquals( \"a\", rs.getObject(\"COLUMN_NAME\") ); \r\n\t\tassertEquals( \"INT\", rs.getObject(\"TYPE_NAME\") ); \r\n\t\tassertEquals( \"5\", rs.getObject(\"COLUMN_Def\") ); \r\n\t\t\r\n\t\tcon.createStatement().execute(\"create view viewColumns as Select * from tableColumns\");\r\n\t\t\r\n\t\trs = md.getColumns(null, null, \"viewColumns\", null);\r\n\t\tassertRSMetaData( rs, colNames, colTypes);\t\t\r\n\t\tassertTrue( \"No row\", rs.next() );\r\n\t\tassertEquals( \"a\", rs.getObject(\"COLUMN_NAME\") ); \r\n\t\tassertEquals( \"INT\", rs.getObject(\"TYPE_NAME\") ); \r\n\t\tassertEquals( \"5\", rs.getObject(\"COLUMN_Def\") ); \r\n\r\n\t\tdropView( con, \"viewColumns\");\r\n\t\tdropTable( con, \"tableColumns\");\r\n\t}","startLine":10,"lastLine":14},{"locFile":"java+method:///smallsql/junit/TestDBMetaData/testGetColumn()","rawLines":"public void testGetColumn() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tdropTable(con,\"tableColumns\");\r\n\t\tdropView( con, \"viewColumns\");\r\n\t\tcon.createStatement().execute(\"create table tableColumns(a int default 5)\");\r\n\t\tDatabaseMetaData md = con.getMetaData();\r\n\t\t\r\n\t\tResultSet rs = md.getColumns(null, null, \"tableColumns\", null);\r\n        String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.VARCHAR, Types.INTEGER, Types.NULL, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.NULL, Types.VARCHAR, Types.NULL, Types.NULL, Types.INTEGER, Types.INTEGER, Types.VARCHAR};\r\n\t\tassertRSMetaData( rs, colNames, colTypes);\t\t\r\n\t\tassertTrue( \"No row\", rs.next() );\r\n\t\tassertEquals( \"a\", rs.getObject(\"COLUMN_NAME\") ); \r\n\t\tassertEquals( \"INT\", rs.getObject(\"TYPE_NAME\") ); \r\n\t\tassertEquals( \"5\", rs.getObject(\"COLUMN_Def\") ); \r\n\t\t\r\n\t\tcon.createStatement().execute(\"create view viewColumns as Select * from tableColumns\");\r\n\t\t\r\n\t\trs = md.getColumns(null, null, \"viewColumns\", null);\r\n\t\tassertRSMetaData( rs, colNames, colTypes);\t\t\r\n\t\tassertTrue( \"No row\", rs.next() );\r\n\t\tassertEquals( \"a\", rs.getObject(\"COLUMN_NAME\") ); \r\n\t\tassertEquals( \"INT\", rs.getObject(\"TYPE_NAME\") ); \r\n\t\tassertEquals( \"5\", rs.getObject(\"COLUMN_Def\") ); \r\n\r\n\t\tdropView( con, \"viewColumns\");\r\n\t\tdropTable( con, \"tableColumns\");\r\n\t}","startLine":19,"lastLine":23}],"window":5},{"content":"assertEquals(0, rs.getRow());assertFalse(rs.isLast());assertFalse(rs.isFirst());assertTrue(rs.isBeforeFirst());assertFalse(rs.isAfterLast());","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelativeAssert(java.sql.ResultSet)","rawLines":"private void testAbsoluteRelativeAssert(ResultSet rs) throws SQLException{\r\n        assertEquals(0, rs.getRow());\r\n        \r\n        assertTrue(rs.absolute(2));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n\r\n        assertTrue(rs.relative(-1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n\r\n        assertTrue(rs.absolute(1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n        assertTrue(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(1));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.absolute(-1));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(0));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertTrue(rs.last());\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n    }","startLine":47,"lastLine":51},{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelativeAssert(java.sql.ResultSet)","rawLines":"private void testAbsoluteRelativeAssert(ResultSet rs) throws SQLException{\r\n        assertEquals(0, rs.getRow());\r\n        \r\n        assertTrue(rs.absolute(2));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n\r\n        assertTrue(rs.relative(-1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n\r\n        assertTrue(rs.absolute(1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n        assertTrue(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(1));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.absolute(-1));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(0));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertTrue(rs.last());\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n    }","startLine":61,"lastLine":65}],"window":5},{"content":"while(shift>=0){int octet = (int)(value >> shift) & 0xFFFF;while(true){int nextEntry = getUnsignedShort();if(nextEntry == octet){","cloneLocs":[{"locFile":"java+method:///smallsql/database/LongTreeList/remove(long)","rawLines":"/**\r\n\t * Remove a value from this list.\r\n\t * @param value\r\n\t * @throws SQLException\r\n\t */\r\n\tfinal void remove(long value) throws SQLException{\r\n\t\tif(size == 0) return;\r\n\t\tint offset1 = 0;\r\n\t\tint offset2 = 0;\r\n\t\tint offset3 = 0;\r\n\t\toffset = 0;\r\n\t\tint shift = 48;\r\n\t\tboolean firstNode = true; // if this the first node in this tree level (0 can be the first node and are the end of the level)\r\n\t\tboolean firstNode1 = true;\r\n\t\tboolean firstNode2 = true;\r\n\t\tboolean firstNode3 = true;\r\n\t\twhile(shift>=0){\r\n\t\t\tint octet = (int)(value >> shift) & 0xFFFF;\r\n\t\t\twhile(true){\r\n\t\t\t\tint nextEntry = getUnsignedShort();\r\n\t\t\t\tif(nextEntry == octet){\r\n\t\t\t\t\tif(shift == 0){\r\n\t\t\t\t\t\t//value find\r\n\t\t\t\t\t\toffset -= 2;\r\n\t\t\t\t\t\tremoveNodeLastLevel();\r\n\t\t\t\t\t\twhile(firstNode && getUnsignedShort() == 0){\r\n\t\t\t\t\t\t\toffset -= 2;\r\n\t\t\t\t\t\t\tremoveNodeLastLevel(); // the end 0 of a node\r\n\t\t\t\t\t\t\tif(shift >= 3) \r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\toffset = offset1;\r\n\t\t\t\t\t\t\toffset1 = offset2;\r\n\t\t\t\t\t\t\toffset2 = offset3;\r\n\t\t\t\t\t\t\tfirstNode = firstNode1;\r\n\t\t\t\t\t\t\tfirstNode1 = firstNode2;\r\n\t\t\t\t\t\t\tfirstNode2 = firstNode3;\r\n\t\t\t\t\t\t\tremoveNode();\r\n\t\t\t\t\t\t\tshift++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\toffset3 = offset2;\r\n\t\t\t\t\toffset2 = offset1;\r\n\t\t\t\t\toffset1 = offset -2;\r\n\t\t\t\t\toffset = getPointer();\r\n\t\t\t\t\tfirstNode3 = firstNode2;\r\n\t\t\t\t\tfirstNode2 = firstNode1;\r\n\t\t\t\t\tfirstNode1 = firstNode;\r\n\t\t\t\t\tfirstNode = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif((nextEntry == 0 && !firstNode) || nextEntry > octet){\r\n\t\t\t\t\t//value is not in the list, this should not occur\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t\tif(shift != 0) offset += pointerSize;\r\n\t\t\t}\r\n\t\t\tshift -= 16;\r\n\t\t}\r\n\t}","startLine":16,"lastLine":20},{"locFile":"java+method:///smallsql/database/LongTreeList/add(long)","rawLines":"/**\r\n\t * Add a value to this list.\r\n\t * @param value\r\n\t * @throws SQLException\r\n\t */\r\n\tfinal void add(long value) throws SQLException{\r\n\t\toffset = 0;\r\n\t\tif(size == 0){\r\n\t\t\twriteShort( (int)(value >> 48) );\r\n\t\t\twritePointer ( offset+pointerSize+2 );\r\n\t\t\twriteShort( 0 );\r\n\t\t\twriteShort( (int)(value >> 32) );\r\n\t\t\twritePointer ( offset+pointerSize+2 );\r\n\t\t\twriteShort( 0 );\r\n\t\t\twriteShort( (int)(value >> 16) );\r\n\t\t\twritePointer ( offset+pointerSize+2 );\r\n\t\t\twriteShort( 0 );\r\n\t\t\twriteShort( (int)(value) );\r\n\t\t\twriteShort( 0 );\r\n\t\t\tsize = offset;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint shift = 48;\r\n\t\tboolean firstNode = (size > 2); // if this the first node in this tree level (0 can be the first node and are the end of the level)\r\n\t\twhile(shift>=0){\r\n\t\t\tint octet = (int)(value >> shift) & 0xFFFF;\r\n\t\t\twhile(true){\r\n\t\t\t\tint nextEntry = getUnsignedShort();\r\n\t\t\t\tif(nextEntry == octet){\r\n\t\t\t\t\tif(shift == 0) return; //value exist already, this case should not occur\r\n\t\t\t\t\toffset = getPointer();\r\n\t\t\t\t\tfirstNode = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif((nextEntry == 0 && !firstNode) || nextEntry > octet){\r\n\t\t\t\t\toffset -= 2;\r\n\t\t\t\t\twhile(true){\r\n\t\t\t\t\t\tif(shift != 0){\r\n\t\t\t\t\t\t\toffset = insertNode(octet);\t\t\t\t\t\t\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tinsertNodeLastLevel(octet);\t\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tshift -= 16;\r\n\t\t\t\t\t\toctet = (int)(value >> shift) & 0xFFFF;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t\tif(shift != 0) offset += pointerSize;\r\n\t\t\t}\r\n\t\t\tshift -= 16;\r\n\t\t}\r\n\t}","startLine":24,"lastLine":28}],"window":5},{"content":"rs = st.getGeneratedKeys();assertNotNull(\"RETURN_GENERATED_KEYS\", rs);assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));assertRowCount(1,rs);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":39,"lastLine":43},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":26,"lastLine":30},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":52,"lastLine":56}],"window":5},{"content":"assertTrue( \"To few rows\", rs.next() );assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);assertTrue( \"To few rows\", rs.next() );assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);assertFalse( \"To many rows\", rs.next() );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":9,"lastLine":13},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":16,"lastLine":20}],"window":5},{"content":"int k=tmp.length-1;for(; k>= 0; k--) if(tmp[k] != 0) break;k++;byte[] tmp2 = new byte[k];System.arraycopy( tmp, 0, tmp2, 0, k);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BasicTestCase/assertEqualsObject(java.lang.String,java.lang.Object,java.lang.Object,boolean)","rawLines":"public void assertEqualsObject( String msg, Object obj1, Object obj2, boolean needTrim ){\r\n        if(needTrim && obj1 != null){\r\n            // trim for CHAR and BINARY\r\n            if(obj1 instanceof String) obj1 = ((String)obj1).trim();\r\n            if(obj1 instanceof byte[]){\r\n                byte[] tmp = (byte[])obj1;\r\n                int k=tmp.length-1;\r\n                for(; k>= 0; k--) if(tmp[k] != 0) break;\r\n                k++;\r\n                byte[] tmp2 = new byte[k];\r\n                System.arraycopy( tmp, 0, tmp2, 0, k);\r\n                obj1 = tmp2;\r\n            }\r\n        }\r\n\t\tif(needTrim && obj2 != null){\r\n\t\t\t// trim for CHAR and BINARY\r\n\t\t\tif(obj2 instanceof String) obj2 = ((String)obj2).trim();\r\n\t\t\tif(obj2 instanceof byte[]){\r\n\t\t\t\tbyte[] tmp = (byte[])obj2;\r\n\t\t\t\tint k=tmp.length-1;\r\n\t\t\t\tfor(; k>= 0; k--) if(tmp[k] != 0) break;\r\n\t\t\t\tk++;\r\n\t\t\t\tbyte[] tmp2 = new byte[k];\r\n\t\t\t\tSystem.arraycopy( tmp, 0, tmp2, 0, k);\r\n\t\t\t\tobj2 = tmp2;\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEqualsObject( msg, obj1, obj2);\r\n    }","startLine":6,"lastLine":10},{"locFile":"java+method:///smallsql/junit/BasicTestCase/assertEqualsObject(java.lang.String,java.lang.Object,java.lang.Object,boolean)","rawLines":"public void assertEqualsObject( String msg, Object obj1, Object obj2, boolean needTrim ){\r\n        if(needTrim && obj1 != null){\r\n            // trim for CHAR and BINARY\r\n            if(obj1 instanceof String) obj1 = ((String)obj1).trim();\r\n            if(obj1 instanceof byte[]){\r\n                byte[] tmp = (byte[])obj1;\r\n                int k=tmp.length-1;\r\n                for(; k>= 0; k--) if(tmp[k] != 0) break;\r\n                k++;\r\n                byte[] tmp2 = new byte[k];\r\n                System.arraycopy( tmp, 0, tmp2, 0, k);\r\n                obj1 = tmp2;\r\n            }\r\n        }\r\n\t\tif(needTrim && obj2 != null){\r\n\t\t\t// trim for CHAR and BINARY\r\n\t\t\tif(obj2 instanceof String) obj2 = ((String)obj2).trim();\r\n\t\t\tif(obj2 instanceof byte[]){\r\n\t\t\t\tbyte[] tmp = (byte[])obj2;\r\n\t\t\t\tint k=tmp.length-1;\r\n\t\t\t\tfor(; k>= 0; k--) if(tmp[k] != 0) break;\r\n\t\t\t\tk++;\r\n\t\t\t\tbyte[] tmp2 = new byte[k];\r\n\t\t\t\tSystem.arraycopy( tmp, 0, tmp2, 0, k);\r\n\t\t\t\tobj2 = tmp2;\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEqualsObject( msg, obj1, obj2);\r\n    }","startLine":19,"lastLine":23}],"window":5},{"content":"switch(token.value){case SQLTokenizer.PARENTHESIS_R:return cmdCreate;case SQLTokenizer.COMMA:continue nextCol;","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/createTable()","rawLines":"private CommandTable createTable() throws SQLException{\r\n        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmdCreate = new CommandTable( con.log, catalog, tableName, SQLTokenizer.CREATE );\r\n        SQLToken token = nextToken( MISSING_PARENTHESIS_L );\r\n\r\n        nextCol:\r\n        while(true){\r\n            token = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\r\n\t\t\tString constraintName;\r\n            if(token.value == SQLTokenizer.CONSTRAINT){\r\n            \t// reading a CONSTRAINT with name\r\n\t\t    \tconstraintName = nextIdentifier();\r\n\t\t\t\ttoken = nextToken( MISSING_KEYTYPE );\r\n            }else{\r\n\t\t\t\tconstraintName = null;\r\n            }\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\tcase SQLTokenizer.FOREIGN:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, tableName, constraintName, null);\r\n                    if(token.value == SQLTokenizer.FOREIGN){\r\n                        nextToken( MISSING_REFERENCES );\r\n                        String pk = nextIdentifier();\r\n                        Expressions expressions = new Expressions();\r\n                        Strings columns = new Strings();\r\n                        expressionDefList( cmdCreate, expressions, columns );\r\n                        IndexDescription pkIndex = new IndexDescription( null, pk, SQLTokenizer.UNIQUE, expressions, columns);\r\n                        ForeignKey foreignKey = new ForeignKey(pk, pkIndex, tableName, index);\r\n                        cmdCreate.addForeingnKey(foreignKey);\r\n                    }else{\r\n                        cmdCreate.addIndex( index );\r\n                    }\r\n\t\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tswitch(token.value){\r\n\t\t\t\t\t\tcase SQLTokenizer.PARENTHESIS_R:\r\n\t\t\t\t\t\t\treturn cmdCreate;\r\n\t\t\t\t\t\tcase SQLTokenizer.COMMA:\r\n\t\t\t\t\t\t\tcontinue nextCol;\r\n\t\t\t\t\t}\r\n            }\r\n            // the token is a column name\r\n\t\t\ttoken = addColumn( token, cmdCreate );\r\n            if(token == null){\r\n                throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    return cmdCreate;\r\n                case SQLTokenizer.COMMA:\r\n                    continue nextCol;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n        }\r\n    }","startLine":51,"lastLine":55},{"locFile":"java+method:///smallsql/database/SQLParser/createTable()","rawLines":"private CommandTable createTable() throws SQLException{\r\n        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmdCreate = new CommandTable( con.log, catalog, tableName, SQLTokenizer.CREATE );\r\n        SQLToken token = nextToken( MISSING_PARENTHESIS_L );\r\n\r\n        nextCol:\r\n        while(true){\r\n            token = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\r\n\t\t\tString constraintName;\r\n            if(token.value == SQLTokenizer.CONSTRAINT){\r\n            \t// reading a CONSTRAINT with name\r\n\t\t    \tconstraintName = nextIdentifier();\r\n\t\t\t\ttoken = nextToken( MISSING_KEYTYPE );\r\n            }else{\r\n\t\t\t\tconstraintName = null;\r\n            }\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\tcase SQLTokenizer.FOREIGN:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, tableName, constraintName, null);\r\n                    if(token.value == SQLTokenizer.FOREIGN){\r\n                        nextToken( MISSING_REFERENCES );\r\n                        String pk = nextIdentifier();\r\n                        Expressions expressions = new Expressions();\r\n                        Strings columns = new Strings();\r\n                        expressionDefList( cmdCreate, expressions, columns );\r\n                        IndexDescription pkIndex = new IndexDescription( null, pk, SQLTokenizer.UNIQUE, expressions, columns);\r\n                        ForeignKey foreignKey = new ForeignKey(pk, pkIndex, tableName, index);\r\n                        cmdCreate.addForeingnKey(foreignKey);\r\n                    }else{\r\n                        cmdCreate.addIndex( index );\r\n                    }\r\n\t\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tswitch(token.value){\r\n\t\t\t\t\t\tcase SQLTokenizer.PARENTHESIS_R:\r\n\t\t\t\t\t\t\treturn cmdCreate;\r\n\t\t\t\t\t\tcase SQLTokenizer.COMMA:\r\n\t\t\t\t\t\t\tcontinue nextCol;\r\n\t\t\t\t\t}\r\n            }\r\n            // the token is a column name\r\n\t\t\ttoken = addColumn( token, cmdCreate );\r\n            if(token == null){\r\n                throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    return cmdCreate;\r\n                case SQLTokenizer.COMMA:\r\n                    continue nextCol;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n        }\r\n    }","startLine":39,"lastLine":43}],"window":5},{"content":"buf.append('.');formatNumber( details.month+1, 2, buf);buf.append('.');formatNumber( details.day, 2, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":38,"lastLine":42},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":45,"lastLine":49}],"window":5},{"content":"try {stat.executeQuery(sql);fail(failureMessage);}catch (SQLException e) {","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTokenizer/failureTest(java.lang.String,java.lang.String,java.lang.String)","rawLines":"private void failureTest(String sql, String failureMessage, String expected) {\r\n\t\ttry {\r\n\t\t\tstat.executeQuery(sql);\r\n\t\t\tfail(failureMessage);\r\n\t\t}\r\n\t\tcatch (SQLException e) {\r\n\t\t\tString foundMsg = e.getMessage();\r\n\t\t\tString assertMsg = MessageFormat.format(\r\n\t\t\t\t\t\"Unexpected error: [{0}], expected: [{1}]\", \r\n\t\t\t\t\tnew Object[] { foundMsg, expected }); \r\n\t\t\t\r\n\t\t\tassertTrue(assertMsg, foundMsg.indexOf(expected) > -1);\r\n\t\t\t\r\n\t\t\t// just to check the error, if it happens, is the expected one\r\n\t\t\tout.println(\"REGULAR: \" + e.getMessage() + '\\n');\r\n\t\t}\r\n\t}\r\n\t//////////////////////////////////////////////////////////////////////\r\n\t// THE FOLLOWING TESTS NEED PACKAGE ACCESS, SO THEY ARE DISABLED. \r\n\t//////////////////////////////////////////////////////////////////////","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestTokenizer/failureTest(java.lang.String,java.lang.String)","rawLines":"private void failureTest(String sql, String failureMessage) {\r\n\t\ttry {\r\n\t\t\tstat.executeQuery(sql);\r\n\t\t\tfail(failureMessage);\r\n\t\t}\r\n\t\tcatch (SQLException e) {\r\n\t\t\t// just to check the error, if it happens, is the expected one\r\n\t\t\tout.println(\"REGULAR: \" + e.getMessage() + '\\n');\r\n\t\t}\r\n\t}","startLine":1,"lastLine":5}],"window":5},{"content":"break;default:throw new Error();}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/CommandTable/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception{\r\n        Database database = catalog == null ? \r\n                con.getDatabase(false) : \r\n                Database.getDatabase( catalog, con, false );\r\n        switch(tableCommandType){\r\n        case SQLTokenizer.CREATE:\r\n            database.createTable( con, name, columns, indexes, foreignKeys );\r\n            break;\r\n        case SQLTokenizer.ADD:\r\n            con = new SSConnection(con);\r\n            //TODO disable the transaction to reduce memory use.\r\n            Table oldTable = (Table)database.getTableView( con, name);\r\n            \r\n            // Request a TableLock and hold it for the completely ALTER TABLE command\r\n            TableStorePage tableLock = oldTable.requestLock( con, SQLTokenizer.ALTER, -1);\r\n            String newName = \"#\" + System.currentTimeMillis() + this.hashCode();\r\n            try{\r\n                Columns oldColumns = oldTable.columns;\r\n                Columns newColumns = oldColumns.copy();\r\n                for(int i = 0; i < columns.size(); i++){\r\n                    addColumn(newColumns, columns.get(i));\r\n                }\r\n                \r\n                Table newTable = database.createTable( con, newName, newColumns, oldTable.indexes, indexes, foreignKeys );\r\n                StringBuffer buffer = new StringBuffer(256);\r\n                buffer.append(\"INSERT INTO \").append( newName ).append( '(' );\r\n                for(int c=0; c<oldColumns.size(); c++){\r\n                    if(c != 0){\r\n                        buffer.append( ',' );\r\n                    }\r\n                    buffer.append( oldColumns.get(c).getName() );\r\n                }\r\n                buffer.append( \")  SELECT * FROM \" ).append( name );\r\n                con.createStatement().execute( buffer.toString() );\r\n                \r\n                database.replaceTable( oldTable, newTable );\r\n            }catch(Exception ex){\r\n                //Remove all from the new table\r\n                try {\r\n                    database.dropTable(con, newName);\r\n                } catch (Exception ex1) {/* ignore it */}\r\n                try{\r\n                    indexes.drop(database);\r\n                } catch (Exception ex1) {/* ignore it */}\r\n                throw ex;\r\n            }finally{\r\n                tableLock.freeLock();\r\n            }\r\n            break;\r\n        default:\r\n            throw new Error();\r\n        }\r\n    }","startLine":48,"lastLine":52},{"locFile":"java+method:///smallsql/database/CommandSet/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws java.sql.SQLException {\r\n        switch(type){\r\n            case SQLTokenizer.LEVEL:\r\n                con.isolationLevel = isolationLevel;\r\n                break;\r\n            case SQLTokenizer.USE:\r\n            \tcon.setCatalog(name);\r\n            \tbreak;\r\n            default:\r\n                throw new Error();\r\n        }\r\n    }","startLine":7,"lastLine":11}],"window":5},{"content":"break;case SQLTokenizer.CHAR:case SQLTokenizer.VARCHAR:case SQLTokenizer.LONGVARCHAR:String str = expr.getString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":74,"lastLine":78},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":131,"lastLine":135}],"window":5},{"content":"case SQLTokenizer.UNIQUEIDENTIFIER:return Utils.bytes2unique( page, this.offset);default: throw new Error();}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getString(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getString()\r\n     */\r\n    @Override\r\n    String getString( int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                    return readBoolean() ? \"1\" : \"0\";\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return String.valueOf( readBoolean() );\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2hex( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return String.valueOf( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return String.valueOf( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return String.valueOf( readInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return String.valueOf( readLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return String.valueOf( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return String.valueOf( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue( readLong() ).toString();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( readInt() ).toString();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toString();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject().toString();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2hex( readLongBinary() );\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME ).toString();\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE ).toString();\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":60,"lastLine":64},{"locFile":"java+method:///smallsql/database/StoreImpl/getObject(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getObject()\r\n     */\r\n    @Override\r\n    Object getObject(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n                    return Utils.getInteger( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return Utils.getInteger( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return Utils.getInteger(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue(readLong());\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME );\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE );\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":59,"lastLine":63}],"window":5},{"content":"formatNumber( details.day, 2, buf);buf.append('/');formatNumber( details.month+1, 2, buf);buf.append('/');formatNumber( details.year % 100, 2, buf);","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":51,"lastLine":55},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":274,"lastLine":278}],"window":5},{"content":"}finally{con.setTransactionIsolation(isolation);con.setAutoCommit(true);}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestAlterTable/testAddWithTableLock_READ_COMMITTED()","rawLines":"public void testAddWithTableLock_READ_COMMITTED() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        int isolation = con.getTransactionIsolation();\r\n        con.setAutoCommit(false);\r\n        try{\r\n            con.setTransactionIsolation( Connection.TRANSACTION_READ_COMMITTED );\r\n            ResultSet rs = st.executeQuery(\"Select * From \" + table);\r\n            rs.next();\r\n            st.execute(\"Alter Table \" + table + \" Add a Varchar(20)\");\r\n            try {\r\n                rs.next();\r\n                fail(\"Alter Table should not work on a table with a lock.\");\r\n            } catch (SQLException ex) {\r\n                assertSQLException( \"01000\", 0, ex );\r\n            }\r\n        }finally{\r\n            con.setTransactionIsolation(isolation);\r\n            con.setAutoCommit(true);\r\n        }\r\n    }","startLine":16,"lastLine":20},{"locFile":"java+method:///smallsql/junit/TestAlterTable/testAddWithTableLock_REPEATABLE_READ()","rawLines":"public void testAddWithTableLock_REPEATABLE_READ() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        int isolation = con.getTransactionIsolation();\r\n        con.setAutoCommit(false);\r\n        try{\r\n            con.setTransactionIsolation( Connection.TRANSACTION_REPEATABLE_READ );\r\n            ResultSet rs = st.executeQuery(\"Select * From \" + table);\r\n            rs.next();\r\n            try {\r\n                st.execute(\"Alter Table \" + table + \" Add a Varchar(20)\");\r\n                fail(\"Alter Table should not work on a table with a lock.\");\r\n            } catch (SQLException ex) {\r\n                assertSQLException( \"01000\", 0, ex );\r\n            }\r\n            rs.next();\r\n        }finally{\r\n            con.setTransactionIsolation(isolation);\r\n            con.setAutoCommit(true);\r\n        }\r\n    }","startLine":16,"lastLine":20}],"window":5},{"content":"init = true;}catch(Throwable e){e.printStackTrace();}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/init()","rawLines":"public void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tdropTable( con, table2 );\r\n\t\t\tdropTable( con, table3 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(v varchar(30), c char(30), nv nvarchar(30),i int, d float, r real, bi bigint, b boolean)\");\r\n\t\t\tst.execute(\"create table \" + table2 + \"(c2 char(30))\");\r\n\t\t\tst.execute(\"create table \" + table3 + \"(vc varchar(30), vb varbinary(30))\");\r\n\t\t\tst.close();\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(v,c,nv,i,d,r,bi,b) Values(?,?,?,?,?,?,?,?)\");\r\n\t\t\tPreparedStatement pr2= con.prepareStatement(\"INSERT into \" + table2 + \"(c2) Values(?)\");\r\n\t\t\tfor(int i=150; i>-10; i--){\r\n\t\t\t\tpr.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr.setString( 2, String.valueOf(i));\r\n\t\t\t\tpr.setString( 3, String.valueOf( (char)i ));\r\n\t\t\t\tpr.setInt   ( 4, i );\r\n\t\t\t\tpr.setDouble( 5, i );\r\n\t\t\t\tpr.setFloat ( 6, i );\r\n\t\t\t\tpr.setInt   ( 7, i );\r\n\t\t\t\tpr.setBoolean( 8, i == 0 );\r\n\t\t\t\tpr.execute();\r\n\t\t\t\tpr2.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr2.execute();\r\n\t\t\t\tvalueCount++;\r\n\t\t\t}\r\n\t\t\tpr.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 2, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 3, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 4, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 5, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 6, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 7, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 8, null, Types.VARCHAR);\r\n\t\t\tpr.execute();\r\n\t\t\tpr2.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr2.execute();\r\n\t\t\tpr2.setString( 1, \"\");\r\n\t\t\tpr2.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tpr = con.prepareStatement(\"INSERT into \" + table3 + \"(vc, vb) Values(?,?)\");\r\n\t\t\tpr.setString( 1, table3);\r\n\t\t\tpr.setBytes( 2, table3.getBytes());\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, \"\");\r\n\t\t\tpr.setBytes( 2, new byte[0]);\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, null);\r\n\t\t\tpr.setBytes( 2, null);\r\n\t\t\tpr.execute();\r\n\t\t\t\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}","startLine":56,"lastLine":60},{"locFile":"java+method:///smallsql/junit/TestGroupBy/init()","rawLines":"public void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(name varchar(30), id int )\");\r\n\t\t\t//st.execute(\"create table \" + table2 + \"(c \" + testValue.dataType +\", d \" + testValue.dataType + \")\");\r\n\t\t\t//st.execute(\"create table \" + table3 + \"(c \" + testValue.dataType +\", d \" + testValue.dataType + \")\");\r\n\t\t\tst.close();\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(name, id) Values(?,?)\");\r\n\t\t\tpr.setString( 1, STR_VALUE1);\r\n\t\t\tpr.setInt( 2, 1 );\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, STR_VALUE1);\r\n\t\t\tpr.setInt( 2, 2 );\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, STR_VALUE1);\r\n\t\t\tpr.setNull( 2, Types.INTEGER );\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, STR_VALUE2);\r\n\t\t\tpr.setInt( 2, 1 );\r\n\t\t\tpr.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}","startLine":26,"lastLine":30}],"window":5},{"content":"fail(\"Exception should throw\");}catch(SQLException ex){assertSQLException(\"HY010\", 0, ex);}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testClosedPreparedStatement()","rawLines":"public void testClosedPreparedStatement() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        PreparedStatement pr = con.prepareStatement(\"Select ?\");\r\n        pr.setInt(1, 1);\r\n        pr.close();\r\n        try{\r\n            pr.setInt(1, 1);\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.execute();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.executeQuery();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            pr.executeUpdate();\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n    }","startLine":25,"lastLine":29},{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testClosedStatement()","rawLines":"public void testClosedStatement() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        st.close();\r\n        try{\r\n            st.execute(\"Select 1\");\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            st.executeQuery(\"Select 1\");\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n        try{\r\n            st.executeUpdate(\"Select 1\");\r\n            fail(\"Exception should throw\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"HY010\", 0, ex);\r\n        }\r\n    }","startLine":18,"lastLine":22}],"window":5},{"content":"case SQLTokenizer.TIMESTAMP:case SQLTokenizer.TIME:case SQLTokenizer.DATE:case SQLTokenizer.SMALLDATETIME:return ((DateTime)obj).getTimeMillis();","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/getDouble(java.lang.Object,int)","rawLines":"static double getDouble(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: return Double.parseDouble( obj.toString() );\r\n        }\r\n    }","startLine":10,"lastLine":14},{"locFile":"java+method:///smallsql/database/ExpressionValue/getFloat(java.lang.Object,int)","rawLines":"static float getFloat(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).floatValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: return Float.parseFloat( obj.toString() );\r\n        }\r\n    }","startLine":12,"lastLine":16},{"locFile":"java+method:///smallsql/database/ExpressionValue/getLong(java.lang.Object,int)","rawLines":"static long getLong(Object obj, int dataType) throws Exception{\r\n       if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).longValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: \r\n            \tString str = obj.toString();\r\n            \tif(str.indexOf('-') > 0 || str.indexOf(':') > 0)\r\n            \t\treturn DateTime.parse(str);\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Long.parseLong( str );\r\n\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\treturn (long)Double.parseDouble( str );\r\n\t\t\t\t}\r\n        }\r\n    }","startLine":13,"lastLine":17}],"window":5},{"content":"String getString() throws Exception{Object obj = getObject();if(obj == null) return null;return obj.toString();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionFloor/getString()","rawLines":"String getString() throws Exception{\r\n        Object obj = getObject();\r\n        if(obj == null) return null;\r\n        return obj.toString();\r\n    }","startLine":0,"lastLine":4},{"locFile":"java+method:///smallsql/database/ExpressionFunctionAbs/getString()","rawLines":"String getString() throws Exception{\r\n        Object obj = getObject();\r\n        if(obj == null) return null;\r\n        return obj.toString();\r\n    }","startLine":0,"lastLine":4}],"window":5},{"content":"return false;}boolean isNext = next();previous();","cloneLocs":[{"locFile":"java+method:///smallsql/database/SortedResult/isLast()","rawLines":"final boolean isLast() throws Exception{\r\n        if(row == 0){\r\n            return false;\r\n        }\r\n        if(row > getRowCount()){\r\n            return false;\r\n        }\r\n        boolean isNext = next();\r\n        previous();\r\n        return !isNext;\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/Scrollable/isLast()","rawLines":"boolean isLast() throws Exception{\r\n        if(rowIdx+1 != rowList.size()){\r\n            // there are more rows after the current row (rowIdx+1 < rowList.size())\r\n            // or we are after the last row (rowIdx+1 > rowList.size())\r\n            return false; \r\n        }\r\n\t\tboolean isNext = next();\r\n        previous();\r\n        return !isNext && (rowIdx+1 == rowList.size() && rowList.size()>0);\r\n\t}","startLine":4,"lastLine":7}],"window":4},{"content":"assertEquals(\"qwert3\", rs.getString(\"v\"));assertEquals(3, rs.getRow());assertTrue(rs.isLast());assertFalse(rs.isFirst());","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelativeAssert(java.sql.ResultSet)","rawLines":"private void testAbsoluteRelativeAssert(ResultSet rs) throws SQLException{\r\n        assertEquals(0, rs.getRow());\r\n        \r\n        assertTrue(rs.absolute(2));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n\r\n        assertTrue(rs.relative(-1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n\r\n        assertTrue(rs.absolute(1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n        assertTrue(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(1));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.absolute(-1));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(0));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertTrue(rs.last());\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n    }","startLine":23,"lastLine":26},{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelativeAssert(java.sql.ResultSet)","rawLines":"private void testAbsoluteRelativeAssert(ResultSet rs) throws SQLException{\r\n        assertEquals(0, rs.getRow());\r\n        \r\n        assertTrue(rs.absolute(2));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n\r\n        assertTrue(rs.relative(-1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n\r\n        assertTrue(rs.absolute(1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n        assertTrue(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(1));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.absolute(-1));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(0));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertTrue(rs.last());\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n    }","startLine":29,"lastLine":32}],"window":4},{"content":"init();Connection con = AllTests.getConnection();Statement st = con.createStatement();ResultSet rs = null;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestExceptions/runTest()","rawLines":"public void runTest() throws Exception{\r\n    \tinit();\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n        try{\r\n            rs = st.executeQuery( testValue.sql );\r\n        }catch(SQLException sqle){\r\n            assertTrue( \"There should no syntax error:\"+sqle, SYNTAX == testValue.errorType);\r\n            assertSQLException( testValue.sqlstate, testValue.errorCode, sqle );\r\n        }\r\n        if(testValue.errorType == SYNTAX){\r\n            assertNull(\"There should be a syntax error\", rs);\r\n            return;\r\n        }\r\n        try{\r\n            while(rs.next()){\r\n                for(int i=1; i<=rs.getMetaData().getColumnCount(); i++){\r\n                    rs.getObject(i);\r\n                }\r\n            }\r\n            fail(\"There should be a runtime error\");\r\n        }catch(SQLException sqle){\r\n            assertSQLException( testValue.sqlstate, testValue.errorCode, sqle );\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test2Columns()","rawLines":"public void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}","startLine":1,"lastLine":4}],"window":4},{"content":"count++;}assertEquals( valueCount, count );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_functionAscDesc()","rawLines":"public void test_functionAscDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\tint oldValue2;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i) Asc, i desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\toldValue2 = rs.getInt(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue2 = rs.getInt(\"i\");\r\n\t\t\tint newValue = Math.abs( newValue2 );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\tif(oldValue == newValue){\r\n\t\t\t\tassertTrue( oldValue2 > newValue2 );\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t\toldValue2 = newValue2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":27,"lastLine":30},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_double()","rawLines":"public void testOrderBy_double() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tDouble oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by d\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Double)rs.getObject(\"d\") ) < 0 );\r\n\t\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_int_asc()","rawLines":"public void testOrderBy_int_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar()","rawLines":"public void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":21,"lastLine":24},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_function()","rawLines":"public void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_nvarchar()","rawLines":"public void testOrderBy_nvarchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by nv\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( String.CASE_INSENSITIVE_ORDER.compare( oldValue, rs.getString(\"nv\") ) <= 0 );\r\n\t\t\toldValue = rs.getString(\"nv\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_real()","rawLines":"public void testOrderBy_real() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tFloat oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by r\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Float)rs.getObject(\"r\") ) < 0 );\r\n\t\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_GroupBy()","rawLines":"public void testOrderBy_varchar_GroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT first(v) cc FROM \" + table1 + \" Group By i ORDER  by first(V)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"cc\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"cc\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_bigint()","rawLines":"public void test_bigint() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by bi\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Long)rs.getObject(\"bi\") ) < 0 );\r\n\t\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_int()","rawLines":"public void testOrderBy_int() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":20,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_bigint_withDoublicateValues()","rawLines":"public void test_bigint_withDoublicateValues() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT bi/2 bi_2 FROM \" + table1 + \" ORDER  by (bi/2)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tLong newValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\tassertTrue( oldValue + \"<=\"+newValue, oldValue.compareTo( newValue ) <= 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":21,"lastLine":24},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_Join()","rawLines":"public void testOrderBy_varchar_Join() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" t1 Inner join \"+table2+\" t2 on t1.c=t2.c2  ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"v\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"v\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":17,"lastLine":20}],"window":4},{"content":"oldValue = rs.getBoolean(\"b\");assertFalse(rs.wasNull());count++;}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_boolean()","rawLines":"public void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":26,"lastLine":29},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_boolean()","rawLines":"public void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":21,"lastLine":24}],"window":4},{"content":"rs = st.getGeneratedKeys();assertNotNull(\"RETURN_GENERATED_KEYS\", rs);assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());assertRowCount(1,rs);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":33,"lastLine":36},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":46,"lastLine":49}],"window":4},{"content":"Connection conn = AllTests.createConnection(\"?locale=it\", null);Statement stat = conn.createStatement();try {try {","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestLanguage/testSyntaxErrors()","rawLines":"public void testSyntaxErrors() throws SQLException {\r\n\t\tConnection conn = AllTests.createConnection(\"?locale=it\", null);\r\n\t\tStatement stat = conn.createStatement();\r\n\t\t\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"CREATE TABLE\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi, fine inattesa della stringa SQL. Le parole chiave richieste sono: <identifier>\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"Some nonsensical sentence.\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi alla posizione 0 in 'Some'. Le parole chiave richieste sono\");\r\n\t\t\t}\r\n\r\n\t\t\trecreateTestTab(stat);\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"SELECT bar() FROM foo\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi alla posizione 7 in 'bar'. Funzione sconosciuta\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"SELECT UCASE('a', '');\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi alla posizione 7 in 'UCASE'. Totale parametri non valido.\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tconn.close();\r\n\t\t}\r\n\t}","startLine":1,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestLanguage/testLocalizedErrors()","rawLines":"public void testLocalizedErrors() throws Exception {\r\n\t\tConnection conn = AllTests.createConnection(\"?locale=it\", null);\r\n\t\tStatement stat = conn.createStatement();\r\n\t\t\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\trecreateTestTab(stat);\r\n\t\r\n\t\t\t\tstat.execute(\"CREATE TABLE \" + TABLE_NAME + \" (id_test INT)\");\r\n\t\t\t\tfail();\r\n\t\t\t}\r\n\t\t\tcatch(SQLException e) {\r\n\t\t\t\tassertMessage(e, \"La tabella/vista '\" + TABLE_NAME + \"' è già esistente.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"DROP TABLE \" + TABLE_NAME);\r\n\t\t\t\tstat.execute(\"DROP TABLE \" + TABLE_NAME);\r\n\t\t\t}\r\n\t\t\tcatch (SQLException e) {\r\n\t\t\t\tassertMessage(e, \"Non si può effettuare DROP della tabella\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"CREATE TABLE foo\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException e) {\r\n\t\t\t\tassertMessage(e, \"Errore di sintassi, fine inattesa\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tconn.close();\r\n\t\t}\r\n\t}","startLine":1,"lastLine":5}],"window":4},{"content":"}prevLock = lock;lock = lock.nextLock;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Table/requestLockImpl(smallsql.database.SSConnection,int,long)","rawLines":"/**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * In the other case it return null.\r\n     * @param page The fileOffset or -1 for a new page\r\n     * @throws SQLException \r\n     */\r\n\tfinal private TableStorePage requestLockImpl(SSConnection con, int pageOperation, long page) throws SQLException{\r\n\t\tsynchronized(locks){\r\n\t\t\tif(tabLockConnection != null && tabLockConnection != con) return null;\r\n\t\t\tswitch(con.isolationLevel){\r\n\t\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\t\tserializeConnections.put( con, con);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tswitch(pageOperation){\r\n\t\t\t\tcase SQLTokenizer.CREATE:{\r\n\t\t\t\t\t\t// first check if another connection has a lock before creating a table lock\r\n\t\t\t\t\t\tif(locks.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\t//the first StorePage in the linked list must be ever TableStorePageInsert\r\n\t\t\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttabLockConnection = con;\r\n\t\t\t\t\t\ttabLockCount++;\r\n\t\t\t\t\t\tTableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n                case SQLTokenizer.ALTER:{\r\n                    // first check if there is any lock before creating a table lock\r\n                    if(locks.size() > 0 || locksInsert.size() > 0){\r\n                        return null;\r\n                    }\r\n                    if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }\r\n                    tabLockConnection = con;\r\n                    tabLockCount++;\r\n                    TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n                    lock.rollback();\r\n                    return lock;\r\n                }\r\n\t\t\t\tcase SQLTokenizer.INSERT:{\r\n\t\t\t\t\t\t// if there are more as one Connection with a serializable lock then an INSERT is not valid\r\n\t\t\t\t\t\tif(serializeConnections.size() > 1) return null;\r\n\t\t\t\t\t\tif(serializeConnections.size() == 1 && serializeConnections.get(con) == null) return null;\r\n\t\t\t\t\t\tTableStorePageInsert lock = new TableStorePageInsert(con, this, LOCK_INSERT);\r\n\t\t\t\t\t\tlocksInsert.add( lock );\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.SELECT:\r\n\t\t\t\tcase SQLTokenizer.UPDATE:{\r\n\t\t\t\t\t\tLong pageKey = new Long(page); //TODO performance\r\n\t\t\t\t\t\tTableStorePage prevLock = null;\r\n\t\t\t\t\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tTableStorePage usableLock = null;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock.con == con || \r\n\t\t\t\t\t\t\t   con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\t\t\t\t    usableLock = lock;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t    if(lock.lockType == LOCK_WRITE){\r\n\t\t\t\t\t\t\t        return null; // write lock of another Connection\r\n\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprevLock = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(usableLock != null){\r\n\t\t\t\t\t\t    return usableLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlock = new TableStorePage( con, this, LOCK_NONE, page);\r\n\t\t\t\t\t\tif(con.isolationLevel >= Connection.TRANSACTION_REPEATABLE_READ || pageOperation == SQLTokenizer.UPDATE){\r\n\t\t\t\t\t\t\tlock.lockType = pageOperation == SQLTokenizer.UPDATE ? LOCK_WRITE : LOCK_READ;\r\n\t\t\t\t\t\t\tif(prevLock != null){\r\n\t\t\t\t\t\t\t    prevLock.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t    locks.put( pageKey, lock );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lock;\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t// is used for written BLOB and CLOB\r\n\t\t\t\t\t// the difference to INSERT is that page described the size of the byte buffer\r\n\t\t\t\t\treturn new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"pageOperation:\"+pageOperation);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":84,"lastLine":87},{"locFile":"java+method:///smallsql/database/Table/requestWriteLock(smallsql.database.SSConnection,smallsql.database.TableStorePage)","rawLines":"/**\r\n\t * Request a write lock for a page that is read. It add the resulting StorePage to the list of commits.\r\n     * @throws SQLException\r\n     *             if the connection was closed.\r\n\t */\r\n\tTableStorePage requestWriteLock(SSConnection con, TableStorePage readlock) throws SQLException{\r\n\t\tif(readlock.lockType == LOCK_INSERT){\r\n\t\t\tTableStorePage lock = new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\treadlock.nextLock = lock;\r\n\t\t\tcon.add(lock);\r\n\t\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t\t}\r\n\t\tLong pageKey = new Long(readlock.fileOffset); //TODO performance\r\n\t\tTableStorePage prevLock = null;\r\n\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\twhile(lock != null){\r\n\t\t\tif(lock.con != con) return null; // there is already any lock from another connection, we can not start write\r\n\t\t\tif(lock.lockType < LOCK_WRITE){\r\n\t\t\t\t// if there is only a read lock we can transfer it\r\n\t\t\t\t// this is required for rollback to a savepoint\r\n\t\t\t\tlock.lockType = LOCK_WRITE;\r\n\t\t\t\treturn lock;\r\n\t\t\t}\r\n\t\t\tprevLock = lock;\r\n\t\t\tlock = lock.nextLock;\r\n\t\t}\r\n\t\tlock = new TableStorePage( con, this, LOCK_WRITE, readlock.fileOffset);\r\n\t\tif(prevLock != null){\r\n\t\t    prevLock.nextLock = lock;\r\n\t\t} else {\r\n\t\t    locks.put( pageKey, lock );\r\n\t\t}\r\n\t\tcon.add(lock);\r\n\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t}","startLine":22,"lastLine":25}],"window":4},{"content":"default:throw new Error();}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/set()","rawLines":"private CommandSet set() throws SQLException{\r\n        SQLToken token = nextToken( COMMANDS_SET );\r\n        switch(token.value){\r\n            case SQLTokenizer.TRANSACTION:\r\n                return setTransaction();\r\n            default:\r\n                throw new Error();\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1Number/getNumeric()","rawLines":"MutableNumeric getNumeric() throws Exception{\r\n\t\tif(param1.isNull()) return null;\r\n\t\tswitch(getDataType()){\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn new MutableNumeric(getInt());\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\treturn new MutableNumeric(getLong());\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn new MutableNumeric(getMoney(), 4);\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tMutableNumeric num = param1.getNumeric();\r\n\t\t\t\tnum.floor();\r\n\t\t\t\treturn num;\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn new MutableNumeric(getDouble());\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error();\r\n\t\t}\r\n    }","startLine":15,"lastLine":18},{"locFile":"java+method:///smallsql/database/ExpressionFunctionSign/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(param1.isNull()) return 0;\r\n\t\tswitch(ExpressionArithmetic.getBestNumberDataType(param1.getDataType())){\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tint intValue = param1.getInt();\r\n\t\t\t\tif(intValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(intValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tlong longValue = param1.getLong();\r\n\t\t\t\tif(longValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(longValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tlongValue = param1.getMoney();\r\n\t\t\t\tif(longValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(longValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\treturn param1.getNumeric().getSignum();\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tdouble doubleValue = param1.getDouble();\r\n\t\t\t\tif(doubleValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(doubleValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error();\r\n\t\t}\r\n\t}","startLine":33,"lastLine":36},{"locFile":"java+method:///smallsql/database/CommandDrop/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception {\r\n        switch(type){\r\n            case SQLTokenizer.DATABASE:\r\n                if(name.startsWith(\"file:\"))\r\n                    name = name.substring(5);\r\n                File dir = new File( name );\r\n                if(!dir.isDirectory() || \r\n                   !new File( dir, Utils.MASTER_FILENAME ).exists())\r\n               \t\t\tthrow SmallSQLException.create(Language.DB_NONEXISTENT, name);\r\n                File files[] = dir.listFiles();\r\n                if(files != null)\r\n\t                for(int i=0; i<files.length; i++){\r\n\t                    files[i].delete();\r\n\t                }\r\n                dir.delete();\r\n                break;\r\n            case SQLTokenizer.TABLE:\r\n                Database.dropTable( con, catalog, name );\r\n                break;\r\n            case SQLTokenizer.VIEW:\r\n\t\t\t\tDatabase.dropView( con, catalog, name );\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.INDEX:\r\n            case SQLTokenizer.PROCEDURE:\r\n                throw new java.lang.UnsupportedOperationException();\r\n            default:\r\n                throw new Error();\r\n        }\r\n    }","startLine":25,"lastLine":28},{"locFile":"java+method:///smallsql/database/CommandTable/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception{\r\n        Database database = catalog == null ? \r\n                con.getDatabase(false) : \r\n                Database.getDatabase( catalog, con, false );\r\n        switch(tableCommandType){\r\n        case SQLTokenizer.CREATE:\r\n            database.createTable( con, name, columns, indexes, foreignKeys );\r\n            break;\r\n        case SQLTokenizer.ADD:\r\n            con = new SSConnection(con);\r\n            //TODO disable the transaction to reduce memory use.\r\n            Table oldTable = (Table)database.getTableView( con, name);\r\n            \r\n            // Request a TableLock and hold it for the completely ALTER TABLE command\r\n            TableStorePage tableLock = oldTable.requestLock( con, SQLTokenizer.ALTER, -1);\r\n            String newName = \"#\" + System.currentTimeMillis() + this.hashCode();\r\n            try{\r\n                Columns oldColumns = oldTable.columns;\r\n                Columns newColumns = oldColumns.copy();\r\n                for(int i = 0; i < columns.size(); i++){\r\n                    addColumn(newColumns, columns.get(i));\r\n                }\r\n                \r\n                Table newTable = database.createTable( con, newName, newColumns, oldTable.indexes, indexes, foreignKeys );\r\n                StringBuffer buffer = new StringBuffer(256);\r\n                buffer.append(\"INSERT INTO \").append( newName ).append( '(' );\r\n                for(int c=0; c<oldColumns.size(); c++){\r\n                    if(c != 0){\r\n                        buffer.append( ',' );\r\n                    }\r\n                    buffer.append( oldColumns.get(c).getName() );\r\n                }\r\n                buffer.append( \")  SELECT * FROM \" ).append( name );\r\n                con.createStatement().execute( buffer.toString() );\r\n                \r\n                database.replaceTable( oldTable, newTable );\r\n            }catch(Exception ex){\r\n                //Remove all from the new table\r\n                try {\r\n                    database.dropTable(con, newName);\r\n                } catch (Exception ex1) {/* ignore it */}\r\n                try{\r\n                    indexes.drop(database);\r\n                } catch (Exception ex1) {/* ignore it */}\r\n                throw ex;\r\n            }finally{\r\n                tableLock.freeLock();\r\n            }\r\n            break;\r\n        default:\r\n            throw new Error();\r\n        }\r\n    }","startLine":49,"lastLine":52},{"locFile":"java+method:///smallsql/database/SQLParser/insert()","rawLines":"private Command insert() throws SQLException{\r\n        SQLToken token = nextToken( MISSING_INTO );\r\n        CommandInsert cmd = new CommandInsert( con.log, nextIdentifier() );\r\n\r\n\t\tint parthesisCount = 0;\r\n\r\n\t\ttoken = nextToken(MISSING_PARENTHESIS_VALUES_SELECT);\r\n        if(token.value == SQLTokenizer.PARENTHESIS_L){\r\n        \ttoken = nextToken(MISSING_EXPRESSION);\r\n        \tif(token.value == SQLTokenizer.SELECT){\r\n\t\t\t\tparthesisCount++;\r\n\t\t\t\tcmd.noColumns = true;\r\n        \t}else{\r\n\t\t\t\tpreviousToken();\r\n\t            Expressions list = expressionParenthesisList(cmd);\r\n\t            for(int i=0; i<list.size(); i++){\r\n\t                cmd.addColumnExpression( list.get( i ) );\r\n\t            }\r\n\t            token = nextToken(MISSING_PARENTHESIS_VALUES_SELECT);\r\n        \t}\r\n        }else cmd.noColumns = true;\r\n        \r\nSwitch: while(true)\r\n        switch(token.value){\r\n        \tcase SQLTokenizer.VALUES:{\r\n\t            token = nextToken(MISSING_PARENTHESIS_L);\r\n\t            cmd.addValues( expressionParenthesisList(cmd) );\r\n\t            return cmd;\r\n\t        }\r\n        \tcase SQLTokenizer.SELECT:\r\n        \t\tcmd.addValues( select() );\r\n        \t\twhile(parthesisCount-- > 0){\r\n        \t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\t}\r\n        \t\treturn cmd;\r\n        \tcase SQLTokenizer.PARENTHESIS_L:\r\n        \t\ttoken = nextToken(MISSING_PARENTHESIS_VALUES_SELECT);\r\n        \t\tparthesisCount++;\r\n        \t\tcontinue Switch;\r\n        \tdefault:\r\n        \t\tthrow new Error();\r\n        }\r\n    }","startLine":39,"lastLine":42},{"locFile":"java+method:///smallsql/database/CommandSet/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws java.sql.SQLException {\r\n        switch(type){\r\n            case SQLTokenizer.LEVEL:\r\n                con.isolationLevel = isolationLevel;\r\n                break;\r\n            case SQLTokenizer.USE:\r\n            \tcon.setCatalog(name);\r\n            \tbreak;\r\n            default:\r\n                throw new Error();\r\n        }\r\n    }","startLine":8,"lastLine":11},{"locFile":"java+method:///smallsql/database/SQLParser/parse(char%5B%5D)","rawLines":"final private Command parse(char[] sql) throws SQLException{\r\n        this.sql = sql;\r\n        this.tokens = SQLTokenizer.parseSQL( sql );\r\n        tokenIdx = 0;\r\n\r\n        SQLToken token = nextToken(COMMANDS);\r\n        switch (token.value){\r\n            case SQLTokenizer.SELECT:\r\n                    return select();\r\n            case SQLTokenizer.DELETE:\r\n                    return delete();\r\n            case SQLTokenizer.INSERT:\r\n                    return insert();\r\n            case SQLTokenizer.UPDATE:\r\n                    return update();\r\n            case SQLTokenizer.CREATE:\r\n                    return create();\r\n            case SQLTokenizer.DROP:\r\n                    return drop();\r\n            case SQLTokenizer.ALTER:\r\n                    return alter();\r\n            case SQLTokenizer.SET:\r\n                    return set();\r\n\t\t\tcase SQLTokenizer.USE:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\tString name = token.getName( sql );\r\n\t\t\t\t\tcheckValidIdentifier( name, token );\r\n\t\t\t\t\tCommandSet set = new CommandSet( con.log, SQLTokenizer.USE);\r\n\t\t\t\t\tset.name = name;\r\n\t\t\t\t\treturn set;\r\n            case SQLTokenizer.EXECUTE:\r\n                    return execute();\r\n            case SQLTokenizer.TRUNCATE:\r\n            \t\treturn truncate();\r\n            default:\r\n                    throw new Error();\r\n        }\r\n    }","startLine":34,"lastLine":37},{"locFile":"java+method:///smallsql/database/SQLParser/setTransaction()","rawLines":"private CommandSet setTransaction() throws SQLException{\r\n        SQLToken token = nextToken( MISSING_ISOLATION );\r\n        token = nextToken( MISSING_LEVEL );\r\n        token = nextToken( COMMANDS_TRANS_LEVEL );\r\n        CommandSet cmd = new CommandSet( con.log, SQLTokenizer.LEVEL );\r\n        switch(token.value){\r\n            case SQLTokenizer.READ:\r\n                token = nextToken( MISSING_COMM_UNCOMM );\r\n                switch(token.value){\r\n                    case SQLTokenizer.COMMITTED:\r\n                        cmd.isolationLevel = Connection.TRANSACTION_READ_COMMITTED;\r\n                        break;\r\n                    case SQLTokenizer.UNCOMMITTED:\r\n                        cmd.isolationLevel = Connection.TRANSACTION_READ_UNCOMMITTED;\r\n                        break;\r\n                    default:\r\n                        throw new Error();\r\n                }\r\n                return cmd;\r\n            case SQLTokenizer.REPEATABLE:\r\n                token = nextToken( MISSING_READ );\r\n                cmd.isolationLevel = Connection.TRANSACTION_REPEATABLE_READ;\r\n                return cmd;\r\n            case SQLTokenizer.SERIALIZABLE:\r\n                cmd.isolationLevel = Connection.TRANSACTION_SERIALIZABLE;\r\n                return cmd;\r\n            default:\r\n                throw new Error();\r\n        }\r\n\r\n\r\n    }","startLine":26,"lastLine":31}],"window":4},{"content":"}catch(Throwable e){e.printStackTrace();}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/init()","rawLines":"public void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tdropTable( con, table2 );\r\n\t\t\tdropTable( con, table3 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(v varchar(30), c char(30), nv nvarchar(30),i int, d float, r real, bi bigint, b boolean)\");\r\n\t\t\tst.execute(\"create table \" + table2 + \"(c2 char(30))\");\r\n\t\t\tst.execute(\"create table \" + table3 + \"(vc varchar(30), vb varbinary(30))\");\r\n\t\t\tst.close();\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(v,c,nv,i,d,r,bi,b) Values(?,?,?,?,?,?,?,?)\");\r\n\t\t\tPreparedStatement pr2= con.prepareStatement(\"INSERT into \" + table2 + \"(c2) Values(?)\");\r\n\t\t\tfor(int i=150; i>-10; i--){\r\n\t\t\t\tpr.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr.setString( 2, String.valueOf(i));\r\n\t\t\t\tpr.setString( 3, String.valueOf( (char)i ));\r\n\t\t\t\tpr.setInt   ( 4, i );\r\n\t\t\t\tpr.setDouble( 5, i );\r\n\t\t\t\tpr.setFloat ( 6, i );\r\n\t\t\t\tpr.setInt   ( 7, i );\r\n\t\t\t\tpr.setBoolean( 8, i == 0 );\r\n\t\t\t\tpr.execute();\r\n\t\t\t\tpr2.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr2.execute();\r\n\t\t\t\tvalueCount++;\r\n\t\t\t}\r\n\t\t\tpr.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 2, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 3, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 4, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 5, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 6, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 7, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 8, null, Types.VARCHAR);\r\n\t\t\tpr.execute();\r\n\t\t\tpr2.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr2.execute();\r\n\t\t\tpr2.setString( 1, \"\");\r\n\t\t\tpr2.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tpr = con.prepareStatement(\"INSERT into \" + table3 + \"(vc, vb) Values(?,?)\");\r\n\t\t\tpr.setString( 1, table3);\r\n\t\t\tpr.setBytes( 2, table3.getBytes());\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, \"\");\r\n\t\t\tpr.setBytes( 2, new byte[0]);\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, null);\r\n\t\t\tpr.setBytes( 2, null);\r\n\t\t\tpr.execute();\r\n\t\t\t\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}","startLine":57,"lastLine":60},{"locFile":"java+initializer:///smallsql/database/SSDriver$initializer1","rawLines":"static {\r\n        try{\r\n        \tdrv = new SSDriver();\r\n            java.sql.DriverManager.registerDriver(drv);\r\n//DriverManager.setLogStream(System.out);\r\n//DriverManager.setLogStream(new java.io.PrintStream(new java.io.FileOutputStream(\"jdbc.log\")));\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n\t}","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/junit/TestAlterTable/setUp()","rawLines":"public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(i int, v varchar(100))\");\r\n            st.execute(\"Insert into \" + table + \" Values(1,'abc')\");\r\n            st.execute(\"Insert into \" + table + \" Values(2,'bcd')\");\r\n            st.execute(\"Insert into \" + table + \" Values(3,'cde')\");\r\n            st.execute(\"Insert into \" + table + \" Values(4,'def')\");\r\n            st.execute(\"Insert into \" + table + \" Values(5,'efg')\");\r\n            st.execute(\"Insert into \" + table + \" Values(6,'fgh')\");\r\n            st.execute(\"Insert into \" + table + \" Values(7,'ghi')\");\r\n            st.execute(\"Insert into \" + table + \" Values(8,'hij')\");\r\n            st.execute(\"Insert into \" + table + \" Values(9,'ijk')\");\r\n            st.execute(\"Insert into \" + table + \" Values(10,'jkl')\");\r\n            st.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }","startLine":17,"lastLine":20},{"locFile":"java+method:///smallsql/junit/TestFunctions/setUp()","rawLines":"public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(aInt int, aVarchar varchar(100))\");\r\n            st.execute(\"Insert into \" + table + \"(aInt, aVarchar) Values(-120,'qwert')\");\r\n            st.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }","startLine":8,"lastLine":11},{"locFile":"java+method:///smallsql/junit/TestGroupBy/init()","rawLines":"public void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(name varchar(30), id int )\");\r\n\t\t\t//st.execute(\"create table \" + table2 + \"(c \" + testValue.dataType +\", d \" + testValue.dataType + \")\");\r\n\t\t\t//st.execute(\"create table \" + table3 + \"(c \" + testValue.dataType +\", d \" + testValue.dataType + \")\");\r\n\t\t\tst.close();\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(name, id) Values(?,?)\");\r\n\t\t\tpr.setString( 1, STR_VALUE1);\r\n\t\t\tpr.setInt( 2, 1 );\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, STR_VALUE1);\r\n\t\t\tpr.setInt( 2, 2 );\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, STR_VALUE1);\r\n\t\t\tpr.setNull( 2, Types.INTEGER );\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, STR_VALUE2);\r\n\t\t\tpr.setInt( 2, 1 );\r\n\t\t\tpr.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}","startLine":27,"lastLine":30},{"locFile":"java+method:///smallsql/junit/TestOperatoren/setUp()","rawLines":"public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(a \" + testValue.dataType +\", b \" + testValue.dataType + \")\");\r\n            st.close();\r\n            PreparedStatement pr = con.prepareStatement(\"INSERT into \" + table + \"(a,b) Values(?,?)\");\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n            pr.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }","startLine":37,"lastLine":40},{"locFile":"java+method:///smallsql/junit/AllTests/main(java.lang.String%5B%5D)","rawLines":"public static void main(String[] argv) {\r\n    \ttry{\r\n    \t\t//junit.swingui.TestRunner.main(new String[]{AllTests.class.getName()});\r\n    \t\tjunit.textui.TestRunner.main(new String[]{AllTests.class.getName()});\r\n    \t}catch(Throwable e){\r\n    \t\te.printStackTrace();\r\n    \t}\r\n    }","startLine":4,"lastLine":7}],"window":4},{"content":"break;default: throw new Error();}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":157,"lastLine":160},{"locFile":"java+constructor:///smallsql/database/ExpressionValue/ExpressionValue(int)","rawLines":"/**\r\n\t * Constructor is used from Constructor GroupResult\r\n\t */\r\n\tExpressionValue(int type){\r\n\t\tsuper(type);\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase SUM:\r\n\t\t\tcase FIRST:\r\n\t\t\tcase LAST:\r\n\t\t\t\tclear();\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\tcase MAX:\r\n\t\t\t\t// set value to null\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tvalue = new MutableInteger(0);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":19,"lastLine":22}],"window":4},{"content":"switch(dataType){case SQLTokenizer.TINYINT:case SQLTokenizer.SMALLINT:case SQLTokenizer.INT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":116,"lastLine":119},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":24,"lastLine":27},{"locFile":"java+method:///smallsql/database/ExpressionValue/initValue(smallsql.database.Expression)","rawLines":"/**\r\n     * Init a summary field with a Mutable \r\n     * @param expr the expression that produce the values which should be summary\r\n     * @throws Exception\r\n     */\r\n\tprivate void initValue(Expression expr) throws Exception{\r\n\t\tdataType = expr.getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tvalue = new MutableInteger(expr.getInt());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tvalue = new MutableLong(expr.getLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\tvalue = new MutableFloat(expr.getFloat());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tvalue = new MutableDouble(expr.getDouble());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tvalue = Money.createFromUnscaledValue(expr.getMoney());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tvalue = new MutableNumeric(expr.getNumeric());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\tvalue = new DateTime(expr.getLong(), dataType);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\t// is used for MAX and MIN\r\n\t\t\t\tvalue = expr.getObject();\r\n\t\t}\r\n\t}","startLine":7,"lastLine":10},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":59,"lastLine":62}],"window":4},{"content":"node.fileOffset = offset;node.load( store );return node;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/FileIndexNode/loadRootNode(boolean,java.nio.channels.FileChannel,long)","rawLines":"static FileIndexNode loadRootNode(boolean unique, FileChannel file, long offset) throws Exception{\r\n        StorePage storePage = new StorePage( null, -1, file, offset);\r\n        StoreImpl store = StoreImpl.createStore( null, storePage, SQLTokenizer.SELECT, offset);\r\n        FileIndexNode node = new FileIndexNode( unique, (char)store.readShort(), file );\r\n        node.fileOffset = offset;\r\n        node.load( store );\r\n        return node;    \r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/FileIndexNode/loadRef(long)","rawLines":"@Override\r\n    IndexNode loadRef( long offset ) throws SQLException{\r\n        StorePage storePage = new StorePage( null, -1, file, offset);\r\n        StoreImpl store = StoreImpl.createStore( null, storePage, SQLTokenizer.INSERT, fileOffset);\r\n        MemoryStream input = new MemoryStream();\r\n\t\tFileIndexNode node = new FileIndexNode( getUnique(), (char)input.readShort(), file );\r\n\t\tnode.fileOffset = offset;\r\n        node.load( store );\r\n\t\treturn node;\t\r\n\t}","startLine":6,"lastLine":9}],"window":4},{"content":"final boolean getBoolean() throws Exception {if(isNull()) return false;return Utils.string2boolean(getString().trim());}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1StringAndBinary/getBoolean()","rawLines":"final boolean getBoolean() throws Exception {\r\n\t\tif(isNull()) return false;\r\n\t\treturn Utils.string2boolean(getString().trim());\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnString/getBoolean()","rawLines":"final boolean getBoolean() throws Exception {\r\n\t\tif(isNull()) return false;\r\n\t\treturn Utils.string2boolean(getString().trim());\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"assertTrue( rs.isBeforeFirst() );assertFalse( rs.isFirst() );assertFalse( rs.isLast() );assertFalse( rs.isAfterLast() );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOther/testNoFromResult()","rawLines":"public void testNoFromResult() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\t\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY );\r\n\t\tResultSet rs = st.executeQuery(\"Select 12, 'qwert' alias\");\r\n\t\t\r\n\t\tassertRSMetaData( rs, new String[]{\"col1\", \"alias\"}, new int[]{Types.INTEGER, Types.VARCHAR });\r\n\t\t\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertTrue( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.previous() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.previous() );\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.first() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.last() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t}","startLine":32,"lastLine":35},{"locFile":"java+method:///smallsql/junit/TestOther/testNoFromResult()","rawLines":"public void testNoFromResult() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\t\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY );\r\n\t\tResultSet rs = st.executeQuery(\"Select 12, 'qwert' alias\");\r\n\t\t\r\n\t\tassertRSMetaData( rs, new String[]{\"col1\", \"alias\"}, new int[]{Types.INTEGER, Types.VARCHAR });\r\n\t\t\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertTrue( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.previous() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.previous() );\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.first() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.last() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t}","startLine":8,"lastLine":11}],"window":4},{"content":"buffer.putInt(TABLE_VIEW_VERSION);buffer.position(0);raFile.write(buffer);}","cloneLocs":[{"locFile":"java+method:///smallsql/database/View/writeMagic(java.nio.channels.FileChannel)","rawLines":"@Override\r\n    void writeMagic(FileChannel raFile) throws Exception{\r\n        ByteBuffer buffer = ByteBuffer.allocate(8);\r\n        buffer.putInt(MAGIC_VIEW);\r\n        buffer.putInt(TABLE_VIEW_VERSION);\r\n        buffer.position(0);\r\n        raFile.write(buffer);\r\n\t}","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/Table/writeMagic(java.nio.channels.FileChannel)","rawLines":"@Override\r\n    void writeMagic(FileChannel raFile) throws Exception{\r\n        ByteBuffer buffer = ByteBuffer.allocate(8);\r\n        buffer.putInt(MAGIC_TABLE);\r\n        buffer.putInt(TABLE_VIEW_VERSION);\r\n        buffer.position(0);\r\n        raFile.write(buffer);\r\n\t}","startLine":4,"lastLine":7}],"window":4},{"content":"final void noRow() {rowSource.noRow();row = 0;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Distinct/noRow()","rawLines":"final void noRow() {\r\n\t\trowSource.noRow();\r\n\t\trow = 0;\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/Where/noRow()","rawLines":"final void noRow() {\r\n\t\trowSource.noRow();\r\n\t\trow = 0;\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"switch(dataType){case SQLTokenizer.BINARY:case SQLTokenizer.VARBINARY:case SQLTokenizer.LONGVARBINARY:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/isBinaryDataType(int)","rawLines":"static boolean isBinaryDataType(int dataType) {\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/ExpressionValue/getBytes(java.lang.Object,int)","rawLines":"static byte[] getBytes(Object obj, int dataType) throws Exception{\r\n\t\tif(obj == null) return null;\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn (byte[])obj;\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\treturn ((String)obj).getBytes();\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\treturn Utils.unique2bytes((String)obj);\r\n            case SQLTokenizer.INT:\r\n                return Utils.int2bytes( ((Number)obj).intValue() );\r\n            case SQLTokenizer.DOUBLE:\r\n                return Utils.double2bytes( ((Number)obj).doubleValue() );\r\n            case SQLTokenizer.REAL:\r\n                return Utils.float2bytes( ((Number)obj).floatValue() );\r\n\t\t\tdefault: throw createUnsupportedConversion(dataType, obj, SQLTokenizer.VARBINARY);\r\n\t\t}\r\n\t}","startLine":2,"lastLine":5}],"window":4},{"content":"}row = 0;return false;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/UnionAll/next()","rawLines":"final boolean next() throws Exception {\r\n\t\tboolean n = currentDS.next();\r\n\t\trow++;\r\n\t\tif(n) return true;\r\n\t\twhile(dataSources.size() > dataSourceIdx+1){\r\n\t\t\tcurrentDS = dataSources.get(++dataSourceIdx);\r\n\t\t\tcurrentDS.beforeFirst();\r\n\t\t\tn = currentDS.next();\r\n\t\t\tif(n) return true;\r\n\t\t}\r\n\t\trow = 0;\r\n\t\treturn false;\r\n\t}","startLine":9,"lastLine":12},{"locFile":"java+method:///smallsql/database/TableResult/moveToValidRow()","rawLines":"/**\r\n     * Move to the next valid row. A valid row is a normal row or an pointer to an updated row value.\r\n     * A invalid row is a deleted row or an updated value that is reference by an update pointer. \r\n     */\r\n    final private boolean moveToValidRow() throws Exception{\r\n\t\twhile(filePos >= 0){\r\n        \tif(moveToRow())\r\n        \t\treturn true;\r\n\t\t\tsetNextFilePos();\r\n    \t}\r\n        row = 0;\r\n    \treturn false;\r\n    }","startLine":9,"lastLine":12}],"window":4},{"content":"String catalog;String tableName = catalog = nextIdentifier();tableName = nextIdentiferPart(tableName);if(tableName == catalog) catalog = null;","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/createTable()","rawLines":"private CommandTable createTable() throws SQLException{\r\n        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmdCreate = new CommandTable( con.log, catalog, tableName, SQLTokenizer.CREATE );\r\n        SQLToken token = nextToken( MISSING_PARENTHESIS_L );\r\n\r\n        nextCol:\r\n        while(true){\r\n            token = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\r\n\t\t\tString constraintName;\r\n            if(token.value == SQLTokenizer.CONSTRAINT){\r\n            \t// reading a CONSTRAINT with name\r\n\t\t    \tconstraintName = nextIdentifier();\r\n\t\t\t\ttoken = nextToken( MISSING_KEYTYPE );\r\n            }else{\r\n\t\t\t\tconstraintName = null;\r\n            }\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\tcase SQLTokenizer.FOREIGN:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, tableName, constraintName, null);\r\n                    if(token.value == SQLTokenizer.FOREIGN){\r\n                        nextToken( MISSING_REFERENCES );\r\n                        String pk = nextIdentifier();\r\n                        Expressions expressions = new Expressions();\r\n                        Strings columns = new Strings();\r\n                        expressionDefList( cmdCreate, expressions, columns );\r\n                        IndexDescription pkIndex = new IndexDescription( null, pk, SQLTokenizer.UNIQUE, expressions, columns);\r\n                        ForeignKey foreignKey = new ForeignKey(pk, pkIndex, tableName, index);\r\n                        cmdCreate.addForeingnKey(foreignKey);\r\n                    }else{\r\n                        cmdCreate.addIndex( index );\r\n                    }\r\n\t\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tswitch(token.value){\r\n\t\t\t\t\t\tcase SQLTokenizer.PARENTHESIS_R:\r\n\t\t\t\t\t\t\treturn cmdCreate;\r\n\t\t\t\t\t\tcase SQLTokenizer.COMMA:\r\n\t\t\t\t\t\t\tcontinue nextCol;\r\n\t\t\t\t\t}\r\n            }\r\n            // the token is a column name\r\n\t\t\ttoken = addColumn( token, cmdCreate );\r\n            if(token == null){\r\n                throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    return cmdCreate;\r\n                case SQLTokenizer.COMMA:\r\n                    continue nextCol;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/SQLParser/createIndex(boolean)","rawLines":"private CommandTable createIndex(boolean unique) throws SQLException{\r\n        String indexName = nextIdentifier();\r\n        nextToken(MISSING_ON);\r\n        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmd = new CommandTable( con.log, catalog, tableName, SQLTokenizer.INDEX );\r\n        Expressions expressions = new Expressions();\r\n        Strings columns = new Strings();\r\n        expressionDefList( cmd, expressions, columns );\r\n        IndexDescription indexDesc = new IndexDescription( \r\n                indexName, \r\n                tableName, \r\n                unique ? SQLTokenizer.UNIQUE : SQLTokenizer.INDEX, \r\n                        expressions, \r\n                        columns);\r\n        //TODO Create Index\r\n\t\tObject[] param = { \"Create Index\" };\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n    }","startLine":3,"lastLine":6}],"window":4},{"content":"Object[] params = {SQLTokenizer.getKeyWord(dataType),SQLTokenizer.getKeyWord(getFunction())};","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunction/createUnspportedDataType(int)","rawLines":"/**\r\n     * Create a SQLException that the current function does not support the specific data type.\r\n     * @param dataType A data type const from SQLTokenizer.\r\n     */\r\n\tSQLException createUnspportedDataType( int dataType ){\r\n\t\tObject[] params = {\r\n\t\t\t\tSQLTokenizer.getKeyWord(dataType),\r\n\t\t\t\tSQLTokenizer.getKeyWord(getFunction())\r\n\t\t};\r\n        return SmallSQLException.create(Language.UNSUPPORTED_DATATYPE_FUNC, params);\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/ExpressionFunction/createUnspportedConversion(int)","rawLines":"/**\r\n     * Create a SQLException that the current function can not convert the specific data type.\r\n     * @param dataType A data type const from SQLTokenizer.\r\n     */\r\n    SQLException createUnspportedConversion( int dataType ){\r\n    \tObject[] params = {\r\n    \t\t\tSQLTokenizer.getKeyWord(dataType),\r\n    \t\t\tSQLTokenizer.getKeyWord(getFunction())\r\n    \t};\r\n        return SmallSQLException.create(Language.UNSUPPORTED_CONVERSION_FUNC, params);\r\n    }","startLine":5,"lastLine":8}],"window":4},{"content":"return;}}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/LongTreeList/correctPointers(int,int,int,int)","rawLines":"/**\r\n\t * Correct all pointers that point behind a new entry.\r\n\t * @param startOffset the startoffset of the current node\r\n\t * @param oldOffset the offset of the new entry, only pointer that point behind it need to correct.\r\n\t * @param diff the differenz that need added to the pointers\r\n\t * @param level the stack level. There are only 3 levels with pointers.\r\n\t */\r\n\tfinal private void correctPointers(int startOffset, int oldOffset, int diff, int level){\r\n\t\toffset = startOffset;\r\n\t\tboolean firstNode = true;\r\n\t\twhile(offset < size){\r\n\t\t\tif(offset == oldOffset){\r\n\t\t\t\tint absDiff = Math.abs(diff);\r\n\t\t\t\tif(absDiff == 2) return;\r\n\t\t\t\toffset += absDiff;\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tint value = getUnsignedShort();\r\n\t\t\tif(value != 0 || firstNode){\r\n\t\t\t\tint pointer = getPointer();\r\n\t\t\t\tif(pointer > oldOffset){\r\n\t\t\t\t\toffset  -= pointerSize;\r\n\t\t\t\t\twritePointer( pointer + diff );\r\n\t\t\t\t\tif(diff > 0) pointer += diff;\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\tif(level < 2){\r\n\t\t\t\t\tstartOffset = offset;\r\n\t\t\t\t\tcorrectPointers( pointer, oldOffset, diff, level+1);\r\n\t\t\t\t\toffset = startOffset;\r\n\t\t\t\t}\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t}else{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":33,"lastLine":36},{"locFile":"java+method:///smallsql/database/SQLParser/from(smallsql.database.CommandSelect)","rawLines":"private void from(CommandSelect cmd) throws SQLException{\r\n\t\tDataSources tables = new DataSources();\r\n        cmd.setTables(tables);\r\n        cmd.setSource( rowSource( cmd, tables, 0 ) );\r\n\r\n\t\tSQLToken token;\r\n        while(null != (token = nextToken())){\r\n            switch(token.value){\r\n                case SQLTokenizer.WHERE:\r\n                    where( cmd );\r\n                    break;\r\n                case SQLTokenizer.GROUP:\r\n                    group( cmd );\r\n                    break;\r\n                case SQLTokenizer.HAVING:\r\n                    having( cmd );\r\n                    break;\r\n                default:\r\n                \tpreviousToken();\r\n                    return;\r\n            }\r\n        }\r\n    }","startLine":19,"lastLine":22}],"window":4},{"content":"case SQLTokenizer.TIMESTAMP:case SQLTokenizer.TIME:case SQLTokenizer.DATE:case SQLTokenizer.SMALLDATETIME:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":52,"lastLine":55},{"locFile":"java+method:///smallsql/database/StoreImpl/getMoney(int,int)","rawLines":"// is used for faster calculation\r\n    @Override\r\n    long getMoney( int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return (long)(Utils.bytes2double( readBinary() ) * 10000L);\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() * 10000L;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() * 10000L;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() * 10000L;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() * 10000L;\r\n            case SQLTokenizer.REAL:\r\n                    return (long)(readFloat() * 10000L);\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)(readDouble() * 10000L);\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return (long)(readNumeric().doubleValue() * 10000L);\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Money.parseMoney( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Money.parseMoney( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Money.parseMoney( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return (long)(Utils.bytes2double( readLongBinary() ) * 10000L);\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"MONEY\" });\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":49,"lastLine":52},{"locFile":"java+method:///smallsql/database/ExpressionValue/getInt(java.lang.Object,int)","rawLines":"static int getInt(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n                return ((Number)obj).intValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn (int)((DateTime)obj).getTimeMillis();\r\n            default:\r\n\t\t\t\tString str = obj.toString().trim();\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Integer.parseInt( str );\r\n\t\t\t\t}catch(Throwable th){/* A NumberFormatException can occur if it a floating point number */}\r\n\t\t\t\treturn (int)Double.parseDouble( str );\r\n        }\r\n    }","startLine":17,"lastLine":20},{"locFile":"java+method:///smallsql/database/StoreImpl/getNumeric(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBigDecimal()\r\n     */\r\n    @Override\r\n    MutableNumeric getNumeric(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":51,"lastLine":54}],"window":4},{"content":"return true;}return false;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/supportsResultSetType(int)","rawLines":"public boolean supportsResultSetType(int type) {\r\n\t\tswitch(type){\r\n\t\t\tcase ResultSet.TYPE_FORWARD_ONLY:\r\n\t\t\tcase ResultSet.TYPE_SCROLL_INSENSITIVE:\r\n\t\t\tcase ResultSet.TYPE_SCROLL_SENSITIVE:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/supportsTransactionIsolationLevel(int)","rawLines":"public boolean supportsTransactionIsolationLevel(int level) {\r\n    \tswitch(level){\r\n\t\t\tcase Connection.TRANSACTION_NONE:\r\n\t\t\tcase Connection.TRANSACTION_READ_UNCOMMITTED:\r\n    \t\tcase Connection.TRANSACTION_READ_COMMITTED:\r\n\t\t\tcase Connection.TRANSACTION_REPEATABLE_READ:\r\n\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\treturn true;\r\n    \t}\r\n    \treturn false;\r\n    }","startLine":7,"lastLine":10},{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/isSignedDataType(int)","rawLines":"static boolean isSignedDataType(int dataType) {\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":12,"lastLine":15},{"locFile":"java+method:///smallsql/database/TableResult/init(smallsql.database.SSConnection)","rawLines":"/**\r\n\t * Is used for compile() of different Commands\r\n\t * \r\n\t * @param con\r\n\t * @return true if now initialize; false if already initialize\r\n\t * @throws Exception\r\n\t */\r\n\t@Override\r\n    final boolean init( SSConnection con ) throws Exception{\r\n\t\tif(super.init(con)){\r\n\t\t\tColumns columns = table.columns;\r\n\t\t\toffsets     = new int[columns.size()];\r\n\t\t\tdataTypes   = new int[columns.size()];\r\n\t\t\tfor(int i=0; i<columns.size(); i++){\r\n\t\t\t\tdataTypes[i] = columns.get(i).getDataType();\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":16,"lastLine":19},{"locFile":"java+method:///smallsql/database/SQLParser/isKeyword(smallsql.database.SQLToken)","rawLines":"final private boolean isKeyword(SQLToken token){\r\n    \tif(token == null) return false;\r\n    \tswitch(token.value){\r\n    \t\tcase SQLTokenizer.SELECT:\r\n    \t\tcase SQLTokenizer.INSERT:\r\n    \t\tcase SQLTokenizer.UPDATE:\r\n    \t\tcase SQLTokenizer.UNION:\r\n    \t\tcase SQLTokenizer.FROM:\r\n    \t\tcase SQLTokenizer.WHERE:\r\n    \t\tcase SQLTokenizer.GROUP:\r\n    \t\tcase SQLTokenizer.HAVING:\r\n\t\t\tcase SQLTokenizer.ORDER:\r\n    \t\tcase SQLTokenizer.COMMA:\r\n\t\t\tcase SQLTokenizer.SET:\r\n            case SQLTokenizer.JOIN:\r\n            case SQLTokenizer.LIMIT:\r\n    \t\t\treturn true;\r\n    \t}\r\n    \treturn false;\r\n    }","startLine":16,"lastLine":19},{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/isBinaryDataType(int)","rawLines":"static boolean isBinaryDataType(int dataType) {\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/isCurrency(int)","rawLines":"public boolean isCurrency(int column) throws SQLException {\r\n        switch(getColumnExpression( column ).getDataType()){\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                return true;\r\n        }\r\n        return false;\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/TableViewResult/init(smallsql.database.SSConnection)","rawLines":"/**\r\n\t * Is used for compile() of different Commands\r\n\t * \r\n\t * @param con\r\n\t * @return true if now init; false if already init\r\n\t * @throws Exception\r\n\t */\r\n\tboolean init( SSConnection con ) throws Exception{\r\n\t\tTableView tableView = getTableView();\r\n\t\tif(tableTimestamp != tableView.getTimestamp()){\r\n\t\t\tthis.con = con;\r\n\t\t\ttableTimestamp = tableView.getTimestamp();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":12,"lastLine":15},{"locFile":"java+method:///smallsql/database/ViewResult/init(smallsql.database.SSConnection)","rawLines":"/**\r\n\t * Is used for compile() of different Commands\r\n\t * \r\n\t * @param con\r\n\t * @return true if now init; false if already init\r\n\t * @throws Exception\r\n\t */\r\n\tboolean init( SSConnection con ) throws Exception{\r\n\t\tif(super.init(con)){\r\n\t\t\tcommandSelect.compile(con);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":10,"lastLine":13},{"locFile":"java+method:///smallsql/database/TableResult/rowDeleted()","rawLines":"@Override\r\n    final boolean rowDeleted(){\r\n\t\t// A StoreNull is created on setRowPosition on a deleted row\r\n        // The instance Store.NULL is used for an empty outer join\r\n\t\tif(store instanceof StoreNull && store != Store.NULL){\r\n            return true;\r\n        }\r\n        if(store instanceof StoreImpl &&\r\n            ((StoreImpl)store).isRollback()){\r\n            return true;\r\n        }\r\n        return false;\r\n\t}","startLine":9,"lastLine":12}],"window":4},{"content":"signum = 1;}}}","cloneLocs":[{"locFile":"java+constructor:///smallsql/database/MutableNumeric/MutableNumeric(int)","rawLines":"MutableNumeric(int complement){\r\n        if(complement == 0){\r\n            signum = 0;\r\n            value = EMPTY_INTS;\r\n        }else{\r\n            value = new int[1];\r\n            if(complement < 0){\r\n                value[0] = -complement;\r\n                signum = -1;\r\n            }else{\r\n                value[0] = complement;\r\n                signum = 1;\r\n            }\r\n        }\r\n    }","startLine":11,"lastLine":14},{"locFile":"java+constructor:///smallsql/database/MutableNumeric/MutableNumeric(long)","rawLines":"MutableNumeric(long complement){\r\n        if(complement == 0){\r\n            signum = 0;\r\n            value = EMPTY_INTS;\r\n        }else{\r\n            value = new int[2];\r\n            if(complement < 0){\r\n                value[0] = (int)(~(complement >> 32));\r\n                value[1] = (int)(-complement);\r\n                signum = -1;\r\n            }else{\r\n                value[0] = (int)(complement >> 32);\r\n                value[1] = (int)complement;\r\n                signum = 1;\r\n            }\r\n        }\r\n    }","startLine":13,"lastLine":16}],"window":4},{"content":"setValue( big.unscaledValue().toByteArray() );scale = big.scale();signum = big.signum();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/MutableNumeric/div(smallsql.database.MutableNumeric)","rawLines":"void div(MutableNumeric num){\r\n    \t//TODO performance\r\n\t\tint newScale = Math.max(scale+5, num.scale +4);\r\n\t\tBigDecimal big = toBigDecimal().divide(num.toBigDecimal(), newScale, BigDecimal.ROUND_HALF_EVEN);\r\n\t\tsetValue( big.unscaledValue().toByteArray() );\r\n\t\tscale = big.scale();\r\n\t\tsignum = big.signum();\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/MutableNumeric/mul(smallsql.database.MutableNumeric)","rawLines":"void mul(MutableNumeric num){\r\n\t\t//TODO performance\r\n\t\tBigDecimal big = toBigDecimal().multiply(num.toBigDecimal() );\r\n\t\tsetValue( big.unscaledValue().toByteArray() );\r\n\t\tscale = big.scale();\r\n\t\tsignum = big.signum();\r\n    }","startLine":3,"lastLine":6}],"window":4},{"content":"case SQLTokenizer.INT:case SQLTokenizer.BIGINT:case SQLTokenizer.DOUBLE:case SQLTokenizer.MONEY:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/getDouble(java.lang.Object,int)","rawLines":"static double getDouble(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: return Double.parseDouble( obj.toString() );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/ExpressionValue/getLong(java.lang.Object,int)","rawLines":"static long getLong(Object obj, int dataType) throws Exception{\r\n       if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).longValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: \r\n            \tString str = obj.toString();\r\n            \tif(str.indexOf('-') > 0 || str.indexOf(':') > 0)\r\n            \t\treturn DateTime.parse(str);\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Long.parseLong( str );\r\n\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\treturn (long)Double.parseDouble( str );\r\n\t\t\t\t}\r\n        }\r\n    }","startLine":8,"lastLine":11}],"window":4},{"content":"rowSource.setRowPosition( rowList.get(rowIdx) );return true;}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Scrollable/previous()","rawLines":"boolean previous() throws Exception{\r\n\t\tif(rowIdx > -1){\r\n\t\t\trowIdx--;\r\n\t\t\tif(rowIdx > -1 && rowIdx < rowList.size()){\r\n\t\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\trowSource.beforeFirst();\r\n\t\treturn false;\r\n\t}","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/Scrollable/absolute(int)","rawLines":"boolean absolute(int row) throws Exception{\r\n\t\tif(row == 0)\r\n\t\t\tthrow SmallSQLException.create(Language.ROW_0_ABSOLUTE);\r\n\t\tif(row < 0){\r\n\t\t\tafterLast();\r\n\t\t\trowIdx = rowList.size() + row;\r\n\t\t\tif(rowIdx < 0){\r\n\t\t\t\tbeforeFirst();\r\n\t\t\t\treturn false;\r\n\t\t\t}else{\r\n\t\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(row <= rowList.size()){\r\n\t\t\trowIdx = row-1;\r\n\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\trowIdx = rowList.size()-1;\r\n\t\tif(rowIdx >= 0)\r\n\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\tboolean result;\r\n\t\twhile((result = next()) && row-1 > rowIdx){/* scroll forward */}\r\n\t\treturn result;\r\n\t}","startLine":10,"lastLine":13}],"window":4},{"content":"if (idx >= size)throw new IndexOutOfBoundsException(\"Column index: \"+idx+\", Size: \"+size);return data[idx];}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Columns/get(int)","rawLines":"final Column get(int idx){\r\n\t\tif (idx >= size)\r\n\t\t\tthrow new IndexOutOfBoundsException(\"Column index: \"+idx+\", Size: \"+size);\r\n\t\treturn data[idx];\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/ForeignKeys/get(int)","rawLines":"final ForeignKey get(int idx){\r\n\t\tif (idx >= size)\r\n\t\t\tthrow new IndexOutOfBoundsException(\"Column index: \"+idx+\", Size: \"+size);\r\n\t\treturn data[idx];\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/Strings/get(int)","rawLines":"final String get(int idx){\r\n\t\tif (idx >= size)\r\n\t\t\tthrow new IndexOutOfBoundsException(\"Column index: \"+idx+\", Size: \"+size);\r\n\t\treturn data[idx];\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/IndexDescriptions/get(int)","rawLines":"final IndexDescription get(int idx){\r\n\t\t// SAVER: use SmallSQLException\r\n\t\tif (idx >= size)\r\n\t\t\tthrow new IndexOutOfBoundsException(\"Column index: \"+idx+\", Size: \"+size);\r\n\t\treturn data[idx];\r\n\t}","startLine":2,"lastLine":5}],"window":4},{"content":"Connection con1 = AllTests.getConnection();Connection con2 = AllTests.createConnection();try{con1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testReadSerialized()","rawLines":"public void testReadSerialized() throws Exception{\r\n        Connection con1 = AllTests.getConnection();\r\n        Connection con2 = AllTests.createConnection();\r\n        try{        \r\n            con1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n            assertRowCount( 0, \"Select * from transactions\");\r\n            con1.createStatement().execute(\"Insert Into transactions(v) Values('qwert2')\");\r\n            assertRowCount( 1, \"Select * from transactions\");\r\n\r\n            con1.setTransactionIsolation( Connection.TRANSACTION_SERIALIZABLE );\r\n            con1.setAutoCommit(false);\r\n\r\n            //create a serialize lock on the table\r\n            ResultSet rs1 = con1.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n            assertTrue( rs1.next() );\r\n            assertEquals( \"Count(*)\", 1, rs1.getInt(1) );\r\n            \r\n            //reading should be possible on a second connection\r\n            ResultSet rs2 = con2.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n            assertTrue( rs2.next() );\r\n            assertEquals( \"Count(*)\", 1, rs2.getInt(1) );\r\n            try{\r\n                con2.createStatement().execute(\"Insert Into transactions(v) Values('qwert3')\");\r\n                fail(\"TRANSACTION_SERIALIZABLE does not lock the table\");\r\n            }catch(SQLException ex){\r\n                assertSQLException(\"01000\", 0, ex);\r\n            }\r\n        }finally{\r\n            con2.close();\r\n            dropTable(con1, \"transactions\");\r\n            con1.setAutoCommit(true);\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestTransactions/testReadWriteLock()","rawLines":"public void testReadWriteLock() throws Exception{\r\n\t\tConnection con1 = AllTests.getConnection();\r\n\t\tConnection con2 = AllTests.createConnection();\r\n\t\ttry{\t\t\r\n\t\t\tcon1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tcon1.createStatement().execute(\"Insert Into transactions(v) Values('qwert1')\");\r\n\r\n\t\t\tcon1.setAutoCommit(false);\r\n\t\t\tcon1.createStatement().execute(\"Update transactions Set v = 'qwert'\");\r\n\t\t\t\r\n\t\t\tlong time = System.currentTimeMillis();\r\n\t\t\ttry{\r\n\t\t\t\tcon2.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n\t\t\t}catch(SQLException ex){\r\n\t\t\t    assertSQLException(\"01000\", 0, ex);\r\n\t\t\t}\t\t\r\n\t\t\tassertTrue(\"Wait time to small\", System.currentTimeMillis()-time>=5000);\r\n\t\t}finally{\r\n\t\t    con2.close();\r\n\t\t\tcon1.setAutoCommit(true);\r\n\t\t\tdropTable(con1, \"transactions\");\r\n\t\t}\r\n\t}","startLine":1,"lastLine":4}],"window":4},{"content":"firstNode = true;break;}if((nextEntry == 0 && !firstNode) || nextEntry > octet){","cloneLocs":[{"locFile":"java+method:///smallsql/database/LongTreeList/remove(long)","rawLines":"/**\r\n\t * Remove a value from this list.\r\n\t * @param value\r\n\t * @throws SQLException\r\n\t */\r\n\tfinal void remove(long value) throws SQLException{\r\n\t\tif(size == 0) return;\r\n\t\tint offset1 = 0;\r\n\t\tint offset2 = 0;\r\n\t\tint offset3 = 0;\r\n\t\toffset = 0;\r\n\t\tint shift = 48;\r\n\t\tboolean firstNode = true; // if this the first node in this tree level (0 can be the first node and are the end of the level)\r\n\t\tboolean firstNode1 = true;\r\n\t\tboolean firstNode2 = true;\r\n\t\tboolean firstNode3 = true;\r\n\t\twhile(shift>=0){\r\n\t\t\tint octet = (int)(value >> shift) & 0xFFFF;\r\n\t\t\twhile(true){\r\n\t\t\t\tint nextEntry = getUnsignedShort();\r\n\t\t\t\tif(nextEntry == octet){\r\n\t\t\t\t\tif(shift == 0){\r\n\t\t\t\t\t\t//value find\r\n\t\t\t\t\t\toffset -= 2;\r\n\t\t\t\t\t\tremoveNodeLastLevel();\r\n\t\t\t\t\t\twhile(firstNode && getUnsignedShort() == 0){\r\n\t\t\t\t\t\t\toffset -= 2;\r\n\t\t\t\t\t\t\tremoveNodeLastLevel(); // the end 0 of a node\r\n\t\t\t\t\t\t\tif(shift >= 3) \r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\toffset = offset1;\r\n\t\t\t\t\t\t\toffset1 = offset2;\r\n\t\t\t\t\t\t\toffset2 = offset3;\r\n\t\t\t\t\t\t\tfirstNode = firstNode1;\r\n\t\t\t\t\t\t\tfirstNode1 = firstNode2;\r\n\t\t\t\t\t\t\tfirstNode2 = firstNode3;\r\n\t\t\t\t\t\t\tremoveNode();\r\n\t\t\t\t\t\t\tshift++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\toffset3 = offset2;\r\n\t\t\t\t\toffset2 = offset1;\r\n\t\t\t\t\toffset1 = offset -2;\r\n\t\t\t\t\toffset = getPointer();\r\n\t\t\t\t\tfirstNode3 = firstNode2;\r\n\t\t\t\t\tfirstNode2 = firstNode1;\r\n\t\t\t\t\tfirstNode1 = firstNode;\r\n\t\t\t\t\tfirstNode = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif((nextEntry == 0 && !firstNode) || nextEntry > octet){\r\n\t\t\t\t\t//value is not in the list, this should not occur\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t\tif(shift != 0) offset += pointerSize;\r\n\t\t\t}\r\n\t\t\tshift -= 16;\r\n\t\t}\r\n\t}","startLine":48,"lastLine":51},{"locFile":"java+method:///smallsql/database/LongTreeList/add(long)","rawLines":"/**\r\n\t * Add a value to this list.\r\n\t * @param value\r\n\t * @throws SQLException\r\n\t */\r\n\tfinal void add(long value) throws SQLException{\r\n\t\toffset = 0;\r\n\t\tif(size == 0){\r\n\t\t\twriteShort( (int)(value >> 48) );\r\n\t\t\twritePointer ( offset+pointerSize+2 );\r\n\t\t\twriteShort( 0 );\r\n\t\t\twriteShort( (int)(value >> 32) );\r\n\t\t\twritePointer ( offset+pointerSize+2 );\r\n\t\t\twriteShort( 0 );\r\n\t\t\twriteShort( (int)(value >> 16) );\r\n\t\t\twritePointer ( offset+pointerSize+2 );\r\n\t\t\twriteShort( 0 );\r\n\t\t\twriteShort( (int)(value) );\r\n\t\t\twriteShort( 0 );\r\n\t\t\tsize = offset;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint shift = 48;\r\n\t\tboolean firstNode = (size > 2); // if this the first node in this tree level (0 can be the first node and are the end of the level)\r\n\t\twhile(shift>=0){\r\n\t\t\tint octet = (int)(value >> shift) & 0xFFFF;\r\n\t\t\twhile(true){\r\n\t\t\t\tint nextEntry = getUnsignedShort();\r\n\t\t\t\tif(nextEntry == octet){\r\n\t\t\t\t\tif(shift == 0) return; //value exist already, this case should not occur\r\n\t\t\t\t\toffset = getPointer();\r\n\t\t\t\t\tfirstNode = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif((nextEntry == 0 && !firstNode) || nextEntry > octet){\r\n\t\t\t\t\toffset -= 2;\r\n\t\t\t\t\twhile(true){\r\n\t\t\t\t\t\tif(shift != 0){\r\n\t\t\t\t\t\t\toffset = insertNode(octet);\t\t\t\t\t\t\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tinsertNodeLastLevel(octet);\t\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tshift -= 16;\r\n\t\t\t\t\t\toctet = (int)(value >> shift) & 0xFFFF;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfirstNode = false;\r\n\t\t\t\tif(shift != 0) offset += pointerSize;\r\n\t\t\t}\r\n\t\t\tshift -= 16;\r\n\t\t}\r\n\t}","startLine":31,"lastLine":34}],"window":4},{"content":"try{MutableNumeric obj = getValue(columnIndex).getNumeric();wasNull = obj == null;if(wasNull) return null;","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getBigDecimal(int)","rawLines":"public BigDecimal getBigDecimal(int columnIndex) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(columnIndex).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSResultSet/getBigDecimal(int,int)","rawLines":"public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(columnIndex).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal(scale);\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4}],"window":4},{"content":"isOuterValid = false;right.nullRow();return true;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":42,"lastLine":45},{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":57,"lastLine":60}],"window":4},{"content":"}catch(Exception e){throw SmallSQLException.createFromException( e );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSCallableStatement/getDate(int)","rawLines":"public Date getDate(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getDate( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSResultSet/getDate(int)","rawLines":"public Date getDate(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getDate( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBytes(int)","rawLines":"public byte[] getBytes(int i) throws SQLException {\r\n        try{\r\n            byte[] obj = getValue(i).getBytes();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getFloat(int)","rawLines":"public float getFloat(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getFloat();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getTime(int)","rawLines":"public Time getTime(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTime( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSResultSet/getTimestamp(int)","rawLines":"public Timestamp getTimestamp(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTimestamp( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSResultSet/getTime(int,java.util.Calendar)","rawLines":"public Time getTime(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getTime(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Time(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":9,"lastLine":12},{"locFile":"java+method:///smallsql/database/SSResultSet/getBoolean(int)","rawLines":"public boolean getBoolean(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getBoolean();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getString(int)","rawLines":"public String getString(int i) throws SQLException {\r\n        try{\r\n            String obj = getValue(i).getString();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getLong(int)","rawLines":"public long getLong(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getBigDecimal(int,int)","rawLines":"public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(columnIndex).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal(scale);\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getObject(int)","rawLines":"public Object getObject(int i) throws SQLException {\r\n        try{\r\n            Object obj = getValue(i).getObject();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBoolean(int)","rawLines":"public boolean getBoolean(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getBoolean();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getBigDecimal(int)","rawLines":"public BigDecimal getBigDecimal(int columnIndex) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(columnIndex).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getDouble(int)","rawLines":"public double getDouble(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getURL(int)","rawLines":"public URL getURL(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new URL( expr.getString() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getFloat(int)","rawLines":"public float getFloat(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getFloat();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getInt(int)","rawLines":"public int getInt(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getInt();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getTimestamp(int,java.util.Calendar)","rawLines":"public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getTimestamp(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Timestamp(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":9,"lastLine":12},{"locFile":"java+method:///smallsql/database/SSResultSet/getBytes(int)","rawLines":"public byte[] getBytes(int columnIndex) throws SQLException {\r\n        try{\r\n            byte[] obj = getValue(columnIndex).getBytes();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getLong(int)","rawLines":"public long getLong(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/getString(int)","rawLines":"public String getString(int columnIndex) throws SQLException {\r\n        try{\r\n            Object obj = getObject(columnIndex);\r\n            \r\n            if(obj instanceof String || obj == null){\r\n                return (String)obj;\r\n            }\r\n            if(obj instanceof byte[]){\r\n                // The Display Value of a binary Value is different as the default in SQL \r\n                return \"0x\" + Utils.bytes2hex( (byte[])obj );\r\n            }\r\n            // all other values\r\n            return getValue(columnIndex).getString();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":13,"lastLine":16},{"locFile":"java+method:///smallsql/database/SSResultSet/getObject(int)","rawLines":"public Object getObject(int columnIndex) throws SQLException {\r\n        try{\r\n            Object obj = getValue(columnIndex).getApiObject();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getTimestamp(int)","rawLines":"public Timestamp getTimestamp(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return DateTime.getTimestamp( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSResultSet/getTime(int)","rawLines":"public Time getTime(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTime( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSResultSet/getDate(int,java.util.Calendar)","rawLines":"public Date getDate(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getDate(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Date(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":9,"lastLine":12},{"locFile":"java+method:///smallsql/database/SSResultSet/getDouble(int)","rawLines":"public double getDouble(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getDouble();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getInt(int)","rawLines":"public int getInt(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getInt();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBigDecimal(int,int)","rawLines":"public BigDecimal getBigDecimal(int i, int scale) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal(scale);\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBigDecimal(int)","rawLines":"public BigDecimal getBigDecimal(int i) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":6,"lastLine":9}],"window":4},{"content":"con.commit();assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");}finally{","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertAndUpdate()","rawLines":"/**\r\n     * Insert a row and update the inserted row in the same transaction. Then make a partial rollback. Test the correct\r\n     * status after of the table after every change of the database.\r\n     * \r\n     * @throws Exception\r\n     *             if an error occur\r\n     */\r\n\tpublic void testInsertAndUpdate() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions ( v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Insert Into transactions(v) Values('qwert')\") );\r\n\t\t\tassertEqualsRsValue(\"qwert\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t\t\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert1'\") );\r\n\t\t\tassertEqualsRsValue(\"qwert1\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t\t\r\n            assertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert2'\") );\r\n            assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n            \r\n\t\t\tSavepoint savepoint = con.setSavepoint();\r\n\t\t\t\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 3'\") );\r\n\t\t\tassertEqualsRsValue(\"qwert 3\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n\t\t\tcon.rollback( savepoint );\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":34,"lastLine":37},{"locFile":"java+method:///smallsql/junit/TestTransactions/testUpdateAndSavepoint()","rawLines":"/**\r\n     * The difference to testInsertAndUpdate() is that the row was not inserted in the same transaction\r\n     */\r\n    public void testUpdateAndSavepoint() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table transactions ( v varchar(20))\");\r\n            assertRowCount(0, \"Select * from transactions\");\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Insert Into transactions(v) Values('qwert')\"));\r\n            assertEqualsRsValue(\"qwert\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            // start the transaction after the row is already insert\r\n            con.setAutoCommit(false);\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert1'\"));\r\n            assertEqualsRsValue(\"qwert1\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert2'\"));\r\n            assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            Savepoint savepoint = con.setSavepoint();\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 3'\"));\r\n            assertEqualsRsValue(\"qwert 3\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 4'\"));\r\n            assertEqualsRsValue(\"qwert 4\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 5'\"));\r\n            assertEqualsRsValue(\"qwert 5\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            con.rollback(savepoint);\r\n\r\n            con.commit();\r\n            assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n        }finally{\r\n            dropTable(con, \"transactions\");\r\n            con.setAutoCommit(true);\r\n        }\r\n    }","startLine":39,"lastLine":42}],"window":4},{"content":"right.nullRow();return true;}}else fullRightRowCounter++;","cloneLocs":[{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":22,"lastLine":25},{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":58,"lastLine":61}],"window":4},{"content":"try{MutableNumeric obj = getValue(i).getNumeric();wasNull = obj == null;if(wasNull) return null;","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBigDecimal(int)","rawLines":"public BigDecimal getBigDecimal(int i) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getBigDecimal(int,int)","rawLines":"public BigDecimal getBigDecimal(int i, int scale) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal(scale);\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4}],"window":4},{"content":"finally {conn.close();}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestLanguage/testLocalizedErrors()","rawLines":"public void testLocalizedErrors() throws Exception {\r\n\t\tConnection conn = AllTests.createConnection(\"?locale=it\", null);\r\n\t\tStatement stat = conn.createStatement();\r\n\t\t\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\trecreateTestTab(stat);\r\n\t\r\n\t\t\t\tstat.execute(\"CREATE TABLE \" + TABLE_NAME + \" (id_test INT)\");\r\n\t\t\t\tfail();\r\n\t\t\t}\r\n\t\t\tcatch(SQLException e) {\r\n\t\t\t\tassertMessage(e, \"La tabella/vista '\" + TABLE_NAME + \"' è già esistente.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"DROP TABLE \" + TABLE_NAME);\r\n\t\t\t\tstat.execute(\"DROP TABLE \" + TABLE_NAME);\r\n\t\t\t}\r\n\t\t\tcatch (SQLException e) {\r\n\t\t\t\tassertMessage(e, \"Non si può effettuare DROP della tabella\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"CREATE TABLE foo\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException e) {\r\n\t\t\t\tassertMessage(e, \"Errore di sintassi, fine inattesa\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tconn.close();\r\n\t\t}\r\n\t}","startLine":30,"lastLine":33},{"locFile":"java+method:///smallsql/junit/TestLanguage/testSyntaxErrors()","rawLines":"public void testSyntaxErrors() throws SQLException {\r\n\t\tConnection conn = AllTests.createConnection(\"?locale=it\", null);\r\n\t\tStatement stat = conn.createStatement();\r\n\t\t\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"CREATE TABLE\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi, fine inattesa della stringa SQL. Le parole chiave richieste sono: <identifier>\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"Some nonsensical sentence.\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi alla posizione 0 in 'Some'. Le parole chiave richieste sono\");\r\n\t\t\t}\r\n\r\n\t\t\trecreateTestTab(stat);\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"SELECT bar() FROM foo\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi alla posizione 7 in 'bar'. Funzione sconosciuta\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tstat.execute(\"SELECT UCASE('a', '');\");\r\n\t\t\t}\r\n\t\t\tcatch (SQLException se) {\r\n\t\t\t\tassertMessage(se, \"Errore di sintassi alla posizione 7 in 'UCASE'. Totale parametri non valido.\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tconn.close();\r\n\t\t}\r\n\t}","startLine":35,"lastLine":38},{"locFile":"java+method:///smallsql/junit/TestLanguage/tearDown()","rawLines":"public void tearDown() throws SQLException {\r\n\t\t// restore language\r\n\t\tConnection conn = AllTests.createConnection(\"?locale=en\", null);\r\n\t\t\r\n\t\ttry {\r\n\t\t\tconn.prepareStatement(\"DROP TABLE \" + TABLE_NAME).execute();\r\n\t\t}\r\n\t\tcatch (Exception e) {}\r\n\t\tfinally {\r\n\t\t\tconn.close();\r\n\t\t}\r\n\t}","startLine":8,"lastLine":11}],"window":4},{"content":"case SQLTokenizer.CHAR:case SQLTokenizer.NCHAR:case SQLTokenizer.VARCHAR:case SQLTokenizer.NVARCHAR:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/getDataTypePrecision(int,int)","rawLines":"static int getDataTypePrecision(int dataType, int defaultValue){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.NULL:\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 1;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 5;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn 7;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 15;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\tif(defaultValue == -1)\r\n\t\t\t\t\treturn 0xFFFF;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                if(defaultValue == -1)\r\n                    return 38;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\treturn 23;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\treturn 8;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn 16;\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\treturn 36;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn Integer.MAX_VALUE;\r\n\t\t}\r\n\t\tif(defaultValue == -1)\r\n\t\t\tthrow new Error(\"Precision:\"+SQLTokenizer.getKeyWord(dataType));\r\n\t\treturn defaultValue;\r\n\t}","startLine":22,"lastLine":25},{"locFile":"java+method:///smallsql/database/StoreImpl/getLong(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getLong()\r\n     */\r\n    @Override\r\n    long getLong(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2long( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (long)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().longValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Long.parseLong( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Long.parseLong( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getLong( ois.readObject().toString(), SQLTokenizer.VARCHAR );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2long( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BIGINT\" });\r\n        }\r\n    }","startLine":34,"lastLine":37},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":25,"lastLine":28},{"locFile":"java+method:///smallsql/database/StoreImpl/scanObjectOffsets(int%5B%5D,int%5B%5D)","rawLines":"@Override\r\n    void scanObjectOffsets( int[] offsets, int dataTypes[] ){\r\n        offset = PAGE_CONTROL_SIZE;\r\n        for(int i=0; i<offsets.length; i++){\r\n            offsets[i] = offset;\r\n            boolean isNull = readBoolean(); // for isNull\r\n            switch(dataTypes[i]){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                    int count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count;  // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    count = readByte();\r\n\t\t\t\t\toffset += 2;\r\n\t\t\t\t\tif(!isNull) offset += count*4;\r\n                    break;\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count << 1; // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                default: throw new Error(String.valueOf( dataTypes[i] ) );\r\n            }\r\n        }\r\n    }","startLine":48,"lastLine":51},{"locFile":"java+method:///smallsql/database/StoreImpl/getBytes(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBytes()\r\n     */\r\n    @Override\r\n    byte[] getBytes(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    byte[] bytes = new byte[1];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.SMALLINT:\r\n                    bytes = new byte[2];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    bytes = new byte[4];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    bytes = new byte[8];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toByteArray();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString().getBytes();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString().getBytes();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    bytes = new byte[16];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":41,"lastLine":44},{"locFile":"java+method:///smallsql/database/StoreImpl/getInt(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getInt()\r\n     */\r\n    @Override\r\n    int getInt(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return (int)readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (int)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (int)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n            \t\tlong longValue = readLong() / 10000;\r\n            \t\treturn Utils.money2int(longValue);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().intValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Integer.parseInt( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Integer.parseInt( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getInt(ois.readObject().toString(), SQLTokenizer.VARCHAR);\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn (int)readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn (int)readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn (int)readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn (int)readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"INT\" });\r\n        }\r\n    }","startLine":35,"lastLine":38},{"locFile":"java+method:///smallsql/database/StoreImpl/getBoolean(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBoolean()\r\n     */\r\n    @Override\r\n    boolean getBoolean(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return false;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean();\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() ) != 0;\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() != 0;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() != 0;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat() != 0;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble() != 0;\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().getSignum() != 0;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Utils.string2boolean( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Utils.string2boolean( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Utils.string2boolean( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() ) != 0;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp() != 0;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime() != 0;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate() != 0;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime() != 0;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                return false;\r\n\t\t\tdefault: \r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BOOLEAN\" });\r\n        }\r\n    }","startLine":34,"lastLine":37},{"locFile":"java+method:///smallsql/database/StoreImpl/getMoney(int,int)","rawLines":"// is used for faster calculation\r\n    @Override\r\n    long getMoney( int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return (long)(Utils.bytes2double( readBinary() ) * 10000L);\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() * 10000L;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() * 10000L;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() * 10000L;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() * 10000L;\r\n            case SQLTokenizer.REAL:\r\n                    return (long)(readFloat() * 10000L);\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)(readDouble() * 10000L);\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return (long)(readNumeric().doubleValue() * 10000L);\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Money.parseMoney( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Money.parseMoney( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Money.parseMoney( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return (long)(Utils.bytes2double( readLongBinary() ) * 10000L);\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"MONEY\" });\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":32,"lastLine":35},{"locFile":"java+method:///smallsql/database/StoreImpl/getFloat(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getFloat()\r\n     */\r\n    @Override\r\n    float getFloat(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2float( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (float)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / (float)10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / (float)10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().floatValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Float.parseFloat( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Float.parseFloat( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Float.parseFloat( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2float( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"REAL\" });\r\n        }\r\n    }","startLine":34,"lastLine":37},{"locFile":"java+method:///smallsql/database/StoreImpl/getNumeric(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBigDecimal()\r\n     */\r\n    @Override\r\n    MutableNumeric getNumeric(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":34,"lastLine":37},{"locFile":"java+method:///smallsql/database/StoreImpl/getDouble(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getDouble()\r\n     */\r\n    @Override\r\n    double getDouble(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2double( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().doubleValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Double.parseDouble( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Double.parseDouble( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Double.parseDouble( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2double( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n        }\r\n    }","startLine":34,"lastLine":37}],"window":4},{"content":"if (! inserted.add(key)) {throw new IllegalArgumentException(\"Duplicate key: \" + key);}else {","cloneLocs":[{"locFile":"java+method:///smallsql/database/language/Language/setSqlStates()","rawLines":"/**\r\n\t * Add entries to sql states map.<br>\r\n\t * If duplicates entries are found the adding entries, an exception is\r\n\t * thrown.\r\n\t * \r\n\t * @param entries\r\n\t *            adding language entries.\r\n\t * @throws IllegalArgumentException\r\n\t *             if duplicate entry is found.\r\n\t */\r\n\tprivate final void setSqlStates() {\r\n\t\tSet inserted = new HashSet(); // for duplicates checking\r\n\t\t\r\n\t\tfor (int i = 0; i < SQL_STATES.length; i++) {\r\n\t\t\tString key = SQL_STATES[i][0];\r\n\t\t\t\r\n\t\t\tif (! inserted.add(key)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"Duplicate key: \" + key);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tString value = SQL_STATES[i][1];\r\n\t\t\t\tsqlStates.put(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":16,"lastLine":19},{"locFile":"java+method:///smallsql/database/language/Language/addMessages(java.lang.String%5B%5D%5B%5D)","rawLines":"/**\r\n\t * Add entries to message map.<br>\r\n\t * If duplicates entries are found the adding entries, an exception is\r\n\t * thrown.\r\n\t * \r\n\t * @param entries\r\n\t *            adding language entries.\r\n\t * @throws IllegalArgumentException\r\n\t *             if duplicate entry is found.\r\n\t */\r\n\tprotected final void addMessages(String[][] entries) \r\n\tthrows IllegalArgumentException {\r\n\t\tSet inserted = new HashSet(); // for duplicates checking\r\n\t\t\r\n\t\tfor (int i = 0; i < entries.length; i++) {\r\n\t\t\tString key = entries[i][0];\r\n\t\t\t\r\n\t\t\tif (! inserted.add(key)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"Duplicate key: \" + key);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tString value = entries[i][1];\r\n\t\t\t\tmessages.put(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":17,"lastLine":20}],"window":4},{"content":"default:return super.getPrecision();}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionConvert/getPrecision()","rawLines":"final int getPrecision(){\r\n\t\tfinal int dataType = getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\treturn datatype.getPrecision();\r\n\t\t\tdefault:\r\n\t\t\t\treturn super.getPrecision();\r\n\t\t}\r\n\t}","startLine":10,"lastLine":13},{"locFile":"java+method:///smallsql/database/ExpressionValue/getPrecision()","rawLines":"final int getPrecision(){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\treturn ((String)value).length();\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\treturn ((byte[])value).length;\r\n\t\t\tdefault: \r\n\t\t\t\treturn super.getPrecision();\r\n\t\t}\r\n\t}","startLine":8,"lastLine":11}],"window":4},{"content":"}System.out.println();}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BasicTestCase/printRS(java.sql.ResultSet)","rawLines":"void printRS(ResultSet rs) throws SQLException{\r\n   \t\tint count = rs.getMetaData().getColumnCount();\r\n\t\twhile(rs.next()){ \r\n\t\t\tfor(int i=1; i<=count; i++){\r\n\t\t\t\tSystem.out.print(rs.getString(i) + '\\t');\r\n\t\t\t} \r\n\t\t\tSystem.out.println();\r\n\t\t}\r\n\r\n   \t}","startLine":5,"lastLine":9},{"locFile":"java+method:///smallsql/tools/CommandLine/printRS(java.sql.ResultSet)","rawLines":"private static void printRS(ResultSet rs) throws SQLException {\r\n        ResultSetMetaData md = rs.getMetaData();\r\n        int count = md.getColumnCount();\r\n        for(int i=1; i<=count; i++){\r\n            System.out.print(md.getColumnLabel(i));\r\n            System.out.print('\\t');\r\n        }\r\n        System.out.println();\r\n        while(rs.next()){\r\n            for(int i=1; i<=count; i++){\r\n                System.out.print(rs.getObject(i));\r\n                System.out.print('\\t');\r\n            }\r\n            System.out.println();\r\n        }\r\n    }","startLine":12,"lastLine":15},{"locFile":"java+method:///smallsql/junit/AllTests/printRS(java.sql.ResultSet)","rawLines":"public static void printRS( ResultSet rs ) throws SQLException{\r\n        while(rs.next()){\r\n            for(int i=1; i<=rs.getMetaData().getColumnCount(); i++){\r\n                System.out.print(rs.getObject(i)+\"\\t\");\r\n            }\r\n            System.out.println();\r\n        }\r\n    }","startLine":4,"lastLine":7}],"window":4},{"content":"if(nodeStack.size() > 1){nodeStack.pop();continue;}else{","cloneLocs":[{"locFile":"java+method:///smallsql/database/IndexScrollStatus/getRowOffset(boolean)","rawLines":"/**\r\n\t * Return the next rowOffset of this index. You need to call reset() before the first use. \r\n\t * @param next if true the next rowOffset else the previous rowOffset\r\n\t */\r\n\tfinal long getRowOffset( boolean scroll){\r\n\t\tif(longList != null){\r\n\t\t\tlong rowOffset = scroll ? \r\n\t\t\t\t\t\t\t\tlongList.getNext(longListEnum) : \r\n\t\t\t\t\t\t\t\tlongList.getPrevious(longListEnum);\r\n\t\t\tif(rowOffset < 0){\r\n\t\t\t\t// No more entries on this node\r\n\t\t\t\tlongList = null;\r\n\t\t\t}else{\r\n\t\t\t\treturn rowOffset;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\tIndexNodeScrollStatus status = (IndexNodeScrollStatus)nodeStack.peek();\r\n\t\t\tint level = status.level;\r\n\t\t\tif(!status.asc ^ scroll){\r\n\t\t\t\t//ASC order\r\n\t\t\t\tint idx = ++status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t\tidx = ++status.idx;\r\n\t\t\t\t}\r\n\t\t\t\tif(idx >= status.nodes.length){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n                        status.idx = status.nodes.length; //to prevent problems with scroll back after multiple calls after the end.\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}else{\r\n\t\t\t\t//DESC order\r\n\t\t\t\tint idx = --status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t}\r\n\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":69,"lastLine":72},{"locFile":"java+method:///smallsql/database/IndexScrollStatus/getRowOffset(boolean)","rawLines":"/**\r\n\t * Return the next rowOffset of this index. You need to call reset() before the first use. \r\n\t * @param next if true the next rowOffset else the previous rowOffset\r\n\t */\r\n\tfinal long getRowOffset( boolean scroll){\r\n\t\tif(longList != null){\r\n\t\t\tlong rowOffset = scroll ? \r\n\t\t\t\t\t\t\t\tlongList.getNext(longListEnum) : \r\n\t\t\t\t\t\t\t\tlongList.getPrevious(longListEnum);\r\n\t\t\tif(rowOffset < 0){\r\n\t\t\t\t// No more entries on this node\r\n\t\t\t\tlongList = null;\r\n\t\t\t}else{\r\n\t\t\t\treturn rowOffset;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\tIndexNodeScrollStatus status = (IndexNodeScrollStatus)nodeStack.peek();\r\n\t\t\tint level = status.level;\r\n\t\t\tif(!status.asc ^ scroll){\r\n\t\t\t\t//ASC order\r\n\t\t\t\tint idx = ++status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t\tidx = ++status.idx;\r\n\t\t\t\t}\r\n\t\t\t\tif(idx >= status.nodes.length){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n                        status.idx = status.nodes.length; //to prevent problems with scroll back after multiple calls after the end.\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}else{\r\n\t\t\t\t//DESC order\r\n\t\t\t\tint idx = --status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t}\r\n\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":39,"lastLine":42}],"window":4},{"content":"case SQLTokenizer.BINARY:case SQLTokenizer.VARBINARY:case SQLTokenizer.LONGVARBINARY:case SQLTokenizer.BLOB:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":165,"lastLine":168},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":146,"lastLine":149},{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/isBinaryDataType(int)","rawLines":"static boolean isBinaryDataType(int dataType) {\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":2,"lastLine":5}],"window":4},{"content":"case SQLTokenizer.TABLE:case SQLTokenizer.VIEW:case SQLTokenizer.INDEX:case SQLTokenizer.PROCEDURE:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/drop()","rawLines":"private Command drop() throws SQLException{\r\n        SQLToken tokenType = nextToken(COMMANDS_DROP);\r\n        \r\n\t\tString catalog;\r\n\t\tString name = catalog = nextIdentifier();\r\n        name = nextIdentiferPart( name );\r\n        if(name == catalog) catalog = null;\r\n\r\n        switch(tokenType.value){\r\n            case SQLTokenizer.DATABASE:\r\n            case SQLTokenizer.TABLE:\r\n            case SQLTokenizer.VIEW:\r\n            case SQLTokenizer.INDEX:\r\n            case SQLTokenizer.PROCEDURE:\r\n            \treturn new CommandDrop( con.log, catalog, name, tokenType.value);\r\n            default:\r\n                throw createSyntaxError( tokenType, COMMANDS_DROP );\r\n        }\r\n    }","startLine":10,"lastLine":13},{"locFile":"java+method:///smallsql/database/SQLParser/alter()","rawLines":"private Command alter() throws SQLException{\r\n    \tSQLToken tokenType = nextToken(COMMANDS_ALTER);\r\n\t\tString catalog;\r\n\t\tString tableName = catalog = nextIdentifier();\r\n        switch(tokenType.value){\r\n        case SQLTokenizer.TABLE:\r\n        case SQLTokenizer.VIEW:\r\n        case SQLTokenizer.INDEX:\r\n        case SQLTokenizer.PROCEDURE:\r\n            tableName = nextIdentiferPart(tableName);\r\n            if(tableName == catalog) catalog = null;\r\n        }\r\n        switch(tokenType.value){\r\n    \t//case SQLTokenizer.DATABASE:\r\n        case SQLTokenizer.TABLE:\r\n            return alterTable( catalog, tableName );\r\n        //case SQLTokenizer.VIEW:\r\n        //case SQLTokenizer.INDEX:\r\n        //case SQLTokenizer.PROCEDURE:\r\n        default:\r\n    \t\tObject[] param = { \"ALTER \" + tokenType.getName( sql ) };\r\n        \tthrow SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n        }\r\n    }","startLine":5,"lastLine":8}],"window":4},{"content":"boolean last() throws Exception{afterLast();return previous();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Scrollable/last()","rawLines":"boolean last() throws Exception{\r\n\t\tafterLast();\r\n\t\treturn previous();\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/SortedResult/last()","rawLines":"boolean last() throws Exception{\r\n\t\tafterLast();\r\n\t\treturn previous();\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"assertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );oldValue = newValue;count++;}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_char()","rawLines":"public void testOrderBy_char() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by c\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"c\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":19,"lastLine":22},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar()","rawLines":"public void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":19,"lastLine":22}],"window":4},{"content":"}catch(Throwable ex){throwable = ex;}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentConnectionWrite()/$anonymous1/run()","rawLines":"public void run(){\r\n                        try{\r\n                            Connection con2 = AllTests.createConnection();\r\n                            Statement st2 = con2.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                            con2.close();\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }","startLine":7,"lastLine":10},{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentThreadWrite()/$anonymous1/run()","rawLines":"public void run(){\r\n                        try{\r\n                            Statement st2 = con.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentRead()/$anonymous1/run()","rawLines":"public void run(){\r\n                    try{\r\n                        assertRowCount(rowCount, sql);\r\n                    }catch(Throwable ex){\r\n                        throwable = ex;\r\n                    }\r\n                }","startLine":3,"lastLine":6}],"window":4},{"content":"protected void setUp() throws Exception{if(init) return;Connection con = AllTests.getConnection();Statement st = con.createStatement();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/setUp()","rawLines":"protected void setUp() throws Exception{\r\n    \tif(init) return;\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tdropTable( con, \"statement\");\r\n\t\tst.execute(\"Create Table statement (c varchar(30), i counter)\");\r\n\t\tinit = true;\r\n    }","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/junit/TestResultSet/setUp()","rawLines":"protected void setUp() throws Exception{\r\n    \tif(init) return;\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tdropTable( con, \"ResultSet\");\r\n\t\tst.execute(\"Create Table ResultSet (i int identity, c varchar(30))\");\r\n        \r\n        st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs = st.executeQuery(\"Select * From ResultSet\");\r\n        \r\n        rs.moveToInsertRow();\r\n        rs.insertRow();\r\n        rs.moveToInsertRow();\r\n        rs.insertRow();\r\n\t\tinit = true;\r\n    }","startLine":0,"lastLine":3}],"window":4},{"content":"token = nextToken(MISSING_INTERVALS);nextToken(MISSING_COMMA);expr = expression( cmd, 0);nextToken(MISSING_COMMA);","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/function(smallsql.database.Command,smallsql.database.SQLToken,boolean)","rawLines":"/**\r\n     * Parse any functions. The left parenthesis is already consumed from token list.\r\n     * @param token the SQLToken of the function\r\n     * @param isEscape If the function is a FN ESCAPE sequence\r\n     */ \r\n    private Expression function( Command cmd, SQLToken token, boolean isEscape ) throws SQLException{\r\n        Expression expr;\r\n        switch(token.value){\r\n        \tcase SQLTokenizer.CONVERT:{\r\n        \t\tColumn col;\r\n        \t\tExpression style = null;\r\n        \t\tif(isEscape){\r\n        \t\t\texpr = expression( cmd, 0);\r\n\t\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\t\tcol = datatype(isEscape);\r\n        \t\t}else{\r\n\t        \t\tcol = datatype(isEscape);\r\n\t        \t\tnextToken(MISSING_COMMA);\r\n\t\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\t\ttoken = nextToken(MISSING_COMMA_PARENTHESIS);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\tstyle = expression( cmd, 0);\r\n\t\t\t\t\t}else\r\n\t\t\t\t\t\tpreviousToken();\r\n        \t\t}\r\n        \t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\treturn new ExpressionFunctionConvert( col, expr, style );\r\n        \t}\r\n        \tcase SQLTokenizer.CAST:\r\n        \t\texpr = expression( cmd, 0);\r\n        \t\tnextToken(MISSING_AS);\r\n        \t\tColumn col = datatype(false);\r\n        \t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\treturn new ExpressionFunctionConvert( col, expr, null );\r\n\t\t\tcase SQLTokenizer.TIMESTAMPDIFF:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampDiff( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;\r\n\t\t\tcase SQLTokenizer.TIMESTAMPADD:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampAdd( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;\r\n        }\r\n\t\tExpressions paramList = expressionParenthesisList(cmd);\r\n        int paramCount = paramList.size();\r\n        Expression[] params = paramList.toArray();\r\n        boolean invalidParamCount;\r\n        switch(token.value){\r\n        // numeric functions:\r\n            case SQLTokenizer.ABS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionAbs();\r\n                break;\r\n            case SQLTokenizer.ACOS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionACos();\r\n                break;\r\n            case SQLTokenizer.ASIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionASin();\r\n                break;\r\n            case SQLTokenizer.ATAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionATan();\r\n                break;\r\n            case SQLTokenizer.ATAN2:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionATan2();\r\n                break;\r\n            case SQLTokenizer.CEILING:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCeiling();\r\n                break;\r\n            case SQLTokenizer.COS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCos();\r\n                break;\r\n            case SQLTokenizer.COT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCot();\r\n                break;\r\n            case SQLTokenizer.DEGREES:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionDegrees();\r\n                break;\r\n            case SQLTokenizer.EXP:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionExp();\r\n                break;\r\n            case SQLTokenizer.FLOOR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionFloor();\r\n                break;\r\n            case SQLTokenizer.LOG:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog();\r\n                break;\r\n            case SQLTokenizer.LOG10:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog10();\r\n                break;\r\n            case SQLTokenizer.MOD:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionMod();\r\n                break;\r\n            case SQLTokenizer.PI:\r\n                invalidParamCount = (paramCount != 0);\r\n                expr = new ExpressionFunctionPI();\r\n                break;\r\n            case SQLTokenizer.POWER:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionPower();\r\n                break;\r\n            case SQLTokenizer.RADIANS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRadians();\r\n                break;\r\n            case SQLTokenizer.RAND:\r\n                invalidParamCount =  (paramCount != 0) && (paramCount != 1);\r\n                expr = new ExpressionFunctionRand();\r\n                break;\r\n            case SQLTokenizer.ROUND:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionRound();\r\n                break;\r\n            case SQLTokenizer.SIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSin();\r\n                break;\r\n            case SQLTokenizer.SIGN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSign();\r\n                break;\r\n            case SQLTokenizer.SQRT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSqrt();\r\n                break;\r\n            case SQLTokenizer.TAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionTan();\r\n                break;\r\n            case SQLTokenizer.TRUNCATE:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionTruncate();\r\n                break;\r\n         \r\n        // string functions:\r\n\t\t\tcase SQLTokenizer.ASCII:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionAscii();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.BITLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionBitLen();\r\n                break;\r\n            case SQLTokenizer.CHARLEN:\r\n            case SQLTokenizer.CHARACTLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCharLen();\r\n                break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionChar();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.CONCAT:\r\n                if(paramCount != 2){\r\n                    invalidParamCount = true;\r\n                    expr = null;//only for compiler\r\n                    break;\r\n                }\r\n                invalidParamCount = false;\r\n                expr = new ExpressionArithmetic( params[0], params[1], ExpressionArithmetic.ADD);\r\n                break;\r\n            case SQLTokenizer.DIFFERENCE:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionDifference();\r\n                break;\r\n            case SQLTokenizer.INSERT:\r\n                invalidParamCount = (paramCount != 4);\r\n                expr = new ExpressionFunctionInsert();\r\n                break;\r\n            case SQLTokenizer.LCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLCase();\r\n                break;\r\n            case SQLTokenizer.LEFT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionLeft();\r\n                break;\r\n\t\t\tcase SQLTokenizer.LENGTH:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionLength();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.LOCATE:\r\n            \tinvalidParamCount = (paramCount != 2) && (paramCount != 3);\r\n            \texpr = new ExpressionFunctionLocate();\r\n            \tbreak;\r\n            case SQLTokenizer.LTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLTrim();\r\n                break;\r\n            case SQLTokenizer.OCTETLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionOctetLen();\r\n                break;\r\n            case SQLTokenizer.REPEAT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionRepeat();\r\n                break;\r\n            case SQLTokenizer.REPLACE:\r\n                invalidParamCount = (paramCount != 3);\r\n                expr = new ExpressionFunctionReplace();\r\n                break;\r\n\t\t\tcase SQLTokenizer.RIGHT:\r\n\t\t\t\tinvalidParamCount = (paramCount != 2);\r\n\t\t\t\texpr = new ExpressionFunctionRight();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.RTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRTrim();\r\n                break;\r\n            case SQLTokenizer.SPACE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSpace();\r\n                break;\r\n            case SQLTokenizer.SOUNDEX:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSoundex();\r\n                break;\r\n\t\t\tcase SQLTokenizer.SUBSTRING:\r\n\t\t\t\tinvalidParamCount = (paramCount != 3);\r\n\t\t\t\texpr = new ExpressionFunctionSubstring();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.UCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionUCase();\r\n                break;\r\n                \r\n        // date time functions\r\n            case SQLTokenizer.CURDATE:\r\n            case SQLTokenizer.CURRENTDATE:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.DATE), SQLTokenizer.DATE);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.CURTIME:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIME), SQLTokenizer.TIME);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFMONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFWEEK:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfWeek();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFYEAR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfYear();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.HOUR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionHour();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MINUTE:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMinute();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.NOW:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.YEAR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionYear();\r\n                break;\r\n            \t\r\n        // system functions:\r\n            case SQLTokenizer.IIF:\r\n        \t\tinvalidParamCount = (paramCount != 3);\r\n            \texpr = new ExpressionFunctionIIF();\r\n        \t\tbreak;\r\n        \tcase SQLTokenizer.SWITCH:\r\n        \t\tinvalidParamCount = (paramCount % 2 != 0);\r\n        \t\tExpressionFunctionCase exprCase = new ExpressionFunctionCase();\r\n        \t\tfor(int i=0; i < paramCount-1; i +=2)\r\n        \t\t\texprCase.addCase(params[i], params[i+1] );\r\n        \t\texprCase.setEnd();\r\n        \t\texpr = exprCase;\r\n        \t\tbreak;\r\n        \tcase SQLTokenizer.IFNULL:\r\n        \t\tswitch(paramCount){\r\n        \t\t\tcase 1:\r\n        \t\t\t\treturn new ExpressionArithmetic( params[0], ExpressionArithmetic.ISNULL );\r\n        \t\t\tcase 2:        \t\t\t\t\r\n        \t\t\t\tinvalidParamCount = false;\r\n        \t\t\t\texpr = new ExpressionFunctionIIF();\r\n        \t\t\t\tExpression[] newParams = new Expression[3];\r\n        \t\t\t\tnewParams[0] = new ExpressionArithmetic( params[0], ExpressionArithmetic.ISNULL );\r\n        \t\t\t\tnewParams[1] = params[1];\r\n        \t\t\t\tnewParams[2] = params[0];        \t\t\t\t\r\n        \t\t\t\tparams = newParams;\r\n        \t\t\t\tparamCount = 3;\r\n        \t\t\t\tbreak;\r\n        \t\t\tdefault:\r\n        \t\t\t\tinvalidParamCount = true;\r\n        \t\t\t\texpr = null; // only for Compiler\r\n        \t\t}\r\n        \t\tbreak;\r\n                    \r\n        // now come the aggregate functions\r\n            case SQLTokenizer.COUNT:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\tif(params[0].getType() == Expression.NAME){\r\n\t\t\t\t\t\t//detect special case COUNT(*)\r\n\t\t\t\t\t\tExpressionName param = (ExpressionName)params[0];\r\n\t\t\t\t\t\tif(\"*\".equals(param.getName()) && param.getTableAlias() == null){\r\n                            //set any not NULL value as parameter\r\n\t\t\t\t\t\t\tparams[0] = new ExpressionValue(\"*\", SQLTokenizer.VARCHAR);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\texpr = new ExpressionName( Expression.COUNT );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SUM:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.SUM );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MAX:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.MAX );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MIN:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.MIN );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FIRST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.FIRST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.LAST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.LAST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.AVG:\r\n\t\t\t\t\tif(paramCount != 1){\r\n                        invalidParamCount = true;\r\n                        expr = null;//Only for the compiler\r\n                        break;\r\n                    }\r\n\t\t\t\t\texpr = new ExpressionName( Expression.SUM );\r\n\t\t\t\t\texpr.setParams( params );\r\n\t\t\t\t\tExpression expr2 = new ExpressionName( Expression.COUNT );\r\n\t\t\t\t\texpr2.setParams( params );\r\n\t\t\t\t\texpr = new ExpressionArithmetic( expr, expr2, ExpressionArithmetic.DIV );\r\n\t\t\t\t\treturn expr;\r\n            default:\r\n            \tthrow createSyntaxError(token, Language.STXADD_FUNC_UNKNOWN);\r\n        }\r\n        if(invalidParamCount) {\r\n        \tthrow createSyntaxError(token, Language.STXADD_PARAM_INVALID_COUNT);\r\n        }\r\n        expr.setParams( params );\r\n        return expr;\r\n    }","startLine":35,"lastLine":38},{"locFile":"java+method:///smallsql/database/SQLParser/function(smallsql.database.Command,smallsql.database.SQLToken,boolean)","rawLines":"/**\r\n     * Parse any functions. The left parenthesis is already consumed from token list.\r\n     * @param token the SQLToken of the function\r\n     * @param isEscape If the function is a FN ESCAPE sequence\r\n     */ \r\n    private Expression function( Command cmd, SQLToken token, boolean isEscape ) throws SQLException{\r\n        Expression expr;\r\n        switch(token.value){\r\n        \tcase SQLTokenizer.CONVERT:{\r\n        \t\tColumn col;\r\n        \t\tExpression style = null;\r\n        \t\tif(isEscape){\r\n        \t\t\texpr = expression( cmd, 0);\r\n\t\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\t\tcol = datatype(isEscape);\r\n        \t\t}else{\r\n\t        \t\tcol = datatype(isEscape);\r\n\t        \t\tnextToken(MISSING_COMMA);\r\n\t\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\t\ttoken = nextToken(MISSING_COMMA_PARENTHESIS);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\tstyle = expression( cmd, 0);\r\n\t\t\t\t\t}else\r\n\t\t\t\t\t\tpreviousToken();\r\n        \t\t}\r\n        \t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\treturn new ExpressionFunctionConvert( col, expr, style );\r\n        \t}\r\n        \tcase SQLTokenizer.CAST:\r\n        \t\texpr = expression( cmd, 0);\r\n        \t\tnextToken(MISSING_AS);\r\n        \t\tColumn col = datatype(false);\r\n        \t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\treturn new ExpressionFunctionConvert( col, expr, null );\r\n\t\t\tcase SQLTokenizer.TIMESTAMPDIFF:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampDiff( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;\r\n\t\t\tcase SQLTokenizer.TIMESTAMPADD:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampAdd( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;\r\n        }\r\n\t\tExpressions paramList = expressionParenthesisList(cmd);\r\n        int paramCount = paramList.size();\r\n        Expression[] params = paramList.toArray();\r\n        boolean invalidParamCount;\r\n        switch(token.value){\r\n        // numeric functions:\r\n            case SQLTokenizer.ABS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionAbs();\r\n                break;\r\n            case SQLTokenizer.ACOS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionACos();\r\n                break;\r\n            case SQLTokenizer.ASIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionASin();\r\n                break;\r\n            case SQLTokenizer.ATAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionATan();\r\n                break;\r\n            case SQLTokenizer.ATAN2:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionATan2();\r\n                break;\r\n            case SQLTokenizer.CEILING:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCeiling();\r\n                break;\r\n            case SQLTokenizer.COS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCos();\r\n                break;\r\n            case SQLTokenizer.COT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCot();\r\n                break;\r\n            case SQLTokenizer.DEGREES:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionDegrees();\r\n                break;\r\n            case SQLTokenizer.EXP:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionExp();\r\n                break;\r\n            case SQLTokenizer.FLOOR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionFloor();\r\n                break;\r\n            case SQLTokenizer.LOG:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog();\r\n                break;\r\n            case SQLTokenizer.LOG10:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog10();\r\n                break;\r\n            case SQLTokenizer.MOD:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionMod();\r\n                break;\r\n            case SQLTokenizer.PI:\r\n                invalidParamCount = (paramCount != 0);\r\n                expr = new ExpressionFunctionPI();\r\n                break;\r\n            case SQLTokenizer.POWER:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionPower();\r\n                break;\r\n            case SQLTokenizer.RADIANS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRadians();\r\n                break;\r\n            case SQLTokenizer.RAND:\r\n                invalidParamCount =  (paramCount != 0) && (paramCount != 1);\r\n                expr = new ExpressionFunctionRand();\r\n                break;\r\n            case SQLTokenizer.ROUND:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionRound();\r\n                break;\r\n            case SQLTokenizer.SIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSin();\r\n                break;\r\n            case SQLTokenizer.SIGN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSign();\r\n                break;\r\n            case SQLTokenizer.SQRT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSqrt();\r\n                break;\r\n            case SQLTokenizer.TAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionTan();\r\n                break;\r\n            case SQLTokenizer.TRUNCATE:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionTruncate();\r\n                break;\r\n         \r\n        // string functions:\r\n\t\t\tcase SQLTokenizer.ASCII:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionAscii();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.BITLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionBitLen();\r\n                break;\r\n            case SQLTokenizer.CHARLEN:\r\n            case SQLTokenizer.CHARACTLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCharLen();\r\n                break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionChar();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.CONCAT:\r\n                if(paramCount != 2){\r\n                    invalidParamCount = true;\r\n                    expr = null;//only for compiler\r\n                    break;\r\n                }\r\n                invalidParamCount = false;\r\n                expr = new ExpressionArithmetic( params[0], params[1], ExpressionArithmetic.ADD);\r\n                break;\r\n            case SQLTokenizer.DIFFERENCE:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionDifference();\r\n                break;\r\n            case SQLTokenizer.INSERT:\r\n                invalidParamCount = (paramCount != 4);\r\n                expr = new ExpressionFunctionInsert();\r\n                break;\r\n            case SQLTokenizer.LCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLCase();\r\n                break;\r\n            case SQLTokenizer.LEFT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionLeft();\r\n                break;\r\n\t\t\tcase SQLTokenizer.LENGTH:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionLength();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.LOCATE:\r\n            \tinvalidParamCount = (paramCount != 2) && (paramCount != 3);\r\n            \texpr = new ExpressionFunctionLocate();\r\n            \tbreak;\r\n            case SQLTokenizer.LTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLTrim();\r\n                break;\r\n            case SQLTokenizer.OCTETLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionOctetLen();\r\n                break;\r\n            case SQLTokenizer.REPEAT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionRepeat();\r\n                break;\r\n            case SQLTokenizer.REPLACE:\r\n                invalidParamCount = (paramCount != 3);\r\n                expr = new ExpressionFunctionReplace();\r\n                break;\r\n\t\t\tcase SQLTokenizer.RIGHT:\r\n\t\t\t\tinvalidParamCount = (paramCount != 2);\r\n\t\t\t\texpr = new ExpressionFunctionRight();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.RTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRTrim();\r\n                break;\r\n            case SQLTokenizer.SPACE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSpace();\r\n                break;\r\n            case SQLTokenizer.SOUNDEX:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSoundex();\r\n                break;\r\n\t\t\tcase SQLTokenizer.SUBSTRING:\r\n\t\t\t\tinvalidParamCount = (paramCount != 3);\r\n\t\t\t\texpr = new ExpressionFunctionSubstring();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.UCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionUCase();\r\n                break;\r\n                \r\n        // date time functions\r\n            case SQLTokenizer.CURDATE:\r\n            case SQLTokenizer.CURRENTDATE:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.DATE), SQLTokenizer.DATE);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.CURTIME:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIME), SQLTokenizer.TIME);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFMONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFWEEK:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfWeek();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFYEAR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfYear();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.HOUR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionHour();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MINUTE:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMinute();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.NOW:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.YEAR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionYear();\r\n                break;\r\n            \t\r\n        // system functions:\r\n            case SQLTokenizer.IIF:\r\n        \t\tinvalidParamCount = (paramCount != 3);\r\n            \texpr = new ExpressionFunctionIIF();\r\n        \t\tbreak;\r\n        \tcase SQLTokenizer.SWITCH:\r\n        \t\tinvalidParamCount = (paramCount % 2 != 0);\r\n        \t\tExpressionFunctionCase exprCase = new ExpressionFunctionCase();\r\n        \t\tfor(int i=0; i < paramCount-1; i +=2)\r\n        \t\t\texprCase.addCase(params[i], params[i+1] );\r\n        \t\texprCase.setEnd();\r\n        \t\texpr = exprCase;\r\n        \t\tbreak;\r\n        \tcase SQLTokenizer.IFNULL:\r\n        \t\tswitch(paramCount){\r\n        \t\t\tcase 1:\r\n        \t\t\t\treturn new ExpressionArithmetic( params[0], ExpressionArithmetic.ISNULL );\r\n        \t\t\tcase 2:        \t\t\t\t\r\n        \t\t\t\tinvalidParamCount = false;\r\n        \t\t\t\texpr = new ExpressionFunctionIIF();\r\n        \t\t\t\tExpression[] newParams = new Expression[3];\r\n        \t\t\t\tnewParams[0] = new ExpressionArithmetic( params[0], ExpressionArithmetic.ISNULL );\r\n        \t\t\t\tnewParams[1] = params[1];\r\n        \t\t\t\tnewParams[2] = params[0];        \t\t\t\t\r\n        \t\t\t\tparams = newParams;\r\n        \t\t\t\tparamCount = 3;\r\n        \t\t\t\tbreak;\r\n        \t\t\tdefault:\r\n        \t\t\t\tinvalidParamCount = true;\r\n        \t\t\t\texpr = null; // only for Compiler\r\n        \t\t}\r\n        \t\tbreak;\r\n                    \r\n        // now come the aggregate functions\r\n            case SQLTokenizer.COUNT:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\tif(params[0].getType() == Expression.NAME){\r\n\t\t\t\t\t\t//detect special case COUNT(*)\r\n\t\t\t\t\t\tExpressionName param = (ExpressionName)params[0];\r\n\t\t\t\t\t\tif(\"*\".equals(param.getName()) && param.getTableAlias() == null){\r\n                            //set any not NULL value as parameter\r\n\t\t\t\t\t\t\tparams[0] = new ExpressionValue(\"*\", SQLTokenizer.VARCHAR);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\texpr = new ExpressionName( Expression.COUNT );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SUM:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.SUM );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MAX:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.MAX );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MIN:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.MIN );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FIRST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.FIRST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.LAST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.LAST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.AVG:\r\n\t\t\t\t\tif(paramCount != 1){\r\n                        invalidParamCount = true;\r\n                        expr = null;//Only for the compiler\r\n                        break;\r\n                    }\r\n\t\t\t\t\texpr = new ExpressionName( Expression.SUM );\r\n\t\t\t\t\texpr.setParams( params );\r\n\t\t\t\t\tExpression expr2 = new ExpressionName( Expression.COUNT );\r\n\t\t\t\t\texpr2.setParams( params );\r\n\t\t\t\t\texpr = new ExpressionArithmetic( expr, expr2, ExpressionArithmetic.DIV );\r\n\t\t\t\t\treturn expr;\r\n            default:\r\n            \tthrow createSyntaxError(token, Language.STXADD_FUNC_UNKNOWN);\r\n        }\r\n        if(invalidParamCount) {\r\n        \tthrow createSyntaxError(token, Language.STXADD_PARAM_INVALID_COUNT);\r\n        }\r\n        expr.setParams( params );\r\n        return expr;\r\n    }","startLine":43,"lastLine":46}],"window":4},{"content":"while(lock != null){if(lock == storePage){if(lock == prev){if(lock.nextLock == null){","cloneLocs":[{"locFile":"java+method:///smallsql/database/Table/freeLock(smallsql.database.TableStorePage)","rawLines":"/**\r\n\t * Remove the lock from this table.\r\n\t */\r\n\tvoid freeLock(TableStorePage storePage){\r\n\t\tfinal int lockType = storePage.lockType;\r\n\t\tfinal long fileOffset = storePage.fileOffset;\r\n\t\tsynchronized(locks){\r\n\t\t\ttry{\r\n\t\t\t\tTableStorePage lock;\r\n\t\t\t\tTableStorePage prev;\r\n\t\t\t\tswitch(lockType){\r\n\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();\r\n\t\t\t\t}\r\n\t\t\t}finally{\r\n\t\t\t\tlocks.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":14,"lastLine":18},{"locFile":"java+method:///smallsql/database/Table/freeLock(smallsql.database.TableStorePage)","rawLines":"/**\r\n\t * Remove the lock from this table.\r\n\t */\r\n\tvoid freeLock(TableStorePage storePage){\r\n\t\tfinal int lockType = storePage.lockType;\r\n\t\tfinal long fileOffset = storePage.fileOffset;\r\n\t\tsynchronized(locks){\r\n\t\t\ttry{\r\n\t\t\t\tTableStorePage lock;\r\n\t\t\t\tTableStorePage prev;\r\n\t\t\t\tswitch(lockType){\r\n\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();\r\n\t\t\t\t}\r\n\t\t\t}finally{\r\n\t\t\t\tlocks.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":41,"lastLine":45}],"window":4},{"content":"}st.close();verify(firstValue);}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestMoneyRounding/testMoney2()","rawLines":"public void testMoney2() throws Exception{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tint firstValue = -10000;\r\n\t\t\tfor(int i=firstValue; i<10000; i++){\r\n\t\t\t\tst.execute(\"Insert into \" + table + \"(a,b) values( (\" + i + \"/10000.0), (\" + i + \"/10000.0) )\");\r\n\t\t\t}\r\n\t\t\tst.close();\r\n\t\t\tverify(firstValue);\r\n\t}","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/junit/TestMoneyRounding/testMoney1()","rawLines":"public void testMoney1() throws Exception{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            int firstValue = -10000;\r\n            for(int i=firstValue; i<10000; i++){\r\n                st.execute(\"Insert into \" + table + \"(a,b) values(\" + (i/10000.0) + \",\" +(i/10000.0) +\")\");\r\n            }\r\n            st.close();\r\n            verify(firstValue);\r\n    }","startLine":6,"lastLine":9}],"window":4},{"content":"formatNumber( details.month+1, 2, buf);buf.append('/');formatNumber( details.day, 2, buf);buf.append('/');","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":23,"lastLine":26},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":30,"lastLine":33}],"window":4},{"content":"return;}}st1.close();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_DeleteRows(java.sql.Connection)","rawLines":"/**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":23,"lastLine":26},{"locFile":"java+method:///smallsql/junit/BenchTest/test_RowRequestPages(java.sql.Connection)","rawLines":"/**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":24,"lastLine":27}],"window":4},{"content":"case SQLTokenizer.TINYINT:case SQLTokenizer.SMALLINT:case SQLTokenizer.INT:case SQLTokenizer.BIGINT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/getInt(java.lang.Object,int)","rawLines":"static int getInt(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n                return ((Number)obj).intValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn (int)((DateTime)obj).getTimeMillis();\r\n            default:\r\n\t\t\t\tString str = obj.toString().trim();\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Integer.parseInt( str );\r\n\t\t\t\t}catch(Throwable th){/* A NumberFormatException can occur if it a floating point number */}\r\n\t\t\t\treturn (int)Double.parseDouble( str );\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/ExpressionValue/getLong(java.lang.Object,int)","rawLines":"static long getLong(Object obj, int dataType) throws Exception{\r\n       if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).longValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: \r\n            \tString str = obj.toString();\r\n            \tif(str.indexOf('-') > 0 || str.indexOf(':') > 0)\r\n            \t\treturn DateTime.parse(str);\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Long.parseLong( str );\r\n\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\treturn (long)Double.parseDouble( str );\r\n\t\t\t\t}\r\n        }\r\n    }","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/ExpressionValue/getMoney(java.lang.Object,int)","rawLines":"static long getMoney(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                return (obj == Boolean.TRUE) ? 10000 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).longValue() * 10000;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                return Utils.doubleToMoney(((Number)obj).doubleValue());\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            \treturn ((Money)obj).value;\r\n            default: return Money.parseMoney( obj.toString() );\r\n        }\r\n\t}","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/ExpressionValue/getBoolean(java.lang.Object,int)","rawLines":"static boolean getBoolean(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return false;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj.equals(Boolean.TRUE));\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).intValue() != 0;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue() != 0;\r\n            default: return Utils.string2boolean( obj.toString() );\r\n        }\r\n    }","startLine":6,"lastLine":9}],"window":4},{"content":"Object getObject() throws Exception {if(isNull()) return null;return Utils.getInteger(getInt());}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionTimestampDiff/getObject()","rawLines":"Object getObject() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\treturn Utils.getInteger(getInt());\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnInt/getObject()","rawLines":"Object getObject() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\treturn Utils.getInteger(getInt());\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"this.type = type;this.condition = condition;this.left = left;this.right = right;","cloneLocs":[{"locFile":"java+constructor:///smallsql/database/JoinScroll/JoinScroll(int,smallsql.database.RowSource,smallsql.database.RowSource,smallsql.database.Expression)","rawLines":"JoinScroll( int type, RowSource left, RowSource right, Expression condition ){\r\n        this.type = type;\r\n        this.condition = condition;\r\n        this.left = left;\r\n        this.right = right;\r\n        if(type == Join.FULL_JOIN){\r\n            isFullNotValid = new boolean[10];\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+constructor:///smallsql/database/Join/Join(int,smallsql.database.RowSource,smallsql.database.RowSource,smallsql.database.Expression)","rawLines":"Join( int type, RowSource left, RowSource right, Expression condition ){\r\n        this.type = type;\r\n        this.condition = condition;\r\n        this.left = left;\r\n        this.right = right;\r\n    }","startLine":1,"lastLine":4}],"window":4},{"content":"int idx = internalExpressions.indexOf(expr);if(idx >= 0) return idx;internalExpressions.add(expr);return internalExpressions.size()-1;","cloneLocs":[{"locFile":"java+method:///smallsql/database/GroupResult/addInternalExpressionFromSelect(smallsql.database.Expression)","rawLines":"/**\r\n\t * Add a expression to the internal expression list if not exist in this list.\r\n\t * It will be added aggregate functions from the SELECT, HAVING and ORDER BY clause.\r\n\t * @param expr The expression to added.\r\n\t * @return the position in the internal list\r\n\t */\r\n\tfinal private int addInternalExpressionFromSelect(Expression expr) throws SQLException{\r\n\t\tint type = expr.getType();\r\n\t\tif(type == Expression.NAME){\r\n\t\t\tint idx = internalExpressions.indexOf(expr);\r\n\t\t\tif(idx >= 0) return idx;\r\n\t\t\tthrow SmallSQLException.create(Language.GROUP_AGGR_NOTPART, expr);\r\n\t\t}else\r\n\t\tif(type >= Expression.GROUP_BEGIN){\r\n\t\t\tint idx = internalExpressions.indexOf(expr);\r\n\t\t\tif(idx >= 0) return idx;\r\n\t\t\tinternalExpressions.add(expr);\r\n\t\t\treturn internalExpressions.size()-1;\r\n\t\t}else{\r\n\t\t\t//if a function or arithmetic expression is already in the group by the it is OK\r\n\t\t\tint idx = internalExpressions.indexOf(expr);\r\n\t\t\tif(idx >= 0) return idx;\r\n\t\t\tExpression[] params = expr.getParams();\r\n\t\t\tif(params != null){\r\n\t\t\t\tfor(int p=0; p<params.length; p++){\r\n\t\t\t\t\taddInternalExpressionFromSelect( params[p]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}","startLine":14,"lastLine":17},{"locFile":"java+method:///smallsql/database/GroupResult/addInternalExpressionFromGroupBy(smallsql.database.Expression)","rawLines":"/**\r\n\t * Add a expression to the internal expression list if not exist in this list.\r\n\t * It will be added named columns in the GROUP BY clause.\r\n\t * @param expr The expression to added.\r\n\t * @return the position in the internal list\r\n\t */\r\n\tfinal private int addInternalExpressionFromGroupBy(Expression expr) throws SQLException{\r\n\t\tint type = expr.getType();\r\n\t\tif(type >= Expression.GROUP_BEGIN){\r\n\t\t\t\tthrow SmallSQLException.create(Language.GROUP_AGGR_INVALID, expr);\r\n\t\t}else{\r\n\t\t\tint idx = internalExpressions.indexOf(expr);\r\n\t\t\tif(idx >= 0) return idx;\r\n\t\t\tinternalExpressions.add(expr);\r\n\t\t\treturn internalExpressions.size()-1;\r\n\t\t}\r\n\t}","startLine":11,"lastLine":14}],"window":4},{"content":"}}return true;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/DataSource/isExpressionsFromThisRowSource(smallsql.database.Expressions)","rawLines":"/**\r\n     * @inheritDoc\r\n     */\r\n\tboolean isExpressionsFromThisRowSource(Expressions columns){\r\n        for(int i=0; i<columns.size(); i++){\r\n            ExpressionName expr = (ExpressionName)columns.get(i);\r\n            if(this != expr.getDataSource()){\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }","startLine":8,"lastLine":11},{"locFile":"java+method:///smallsql/database/SortedResult/relative(int)","rawLines":"boolean relative(int rows) throws Exception{\r\n        if(rows == 0) return (row != 0);\r\n        if(rows > 0){\r\n            while(rows-- > 0){\r\n                if(!next()){\r\n                    return false;\r\n                }\r\n            }\r\n        }else{\r\n            while(rows++ < 0){\r\n                if(!previous()){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","startLine":13,"lastLine":16},{"locFile":"java+method:///smallsql/database/SortedResult/absolute(int)","rawLines":"boolean absolute(int newRow) throws Exception{\r\n        if(newRow == 0) throw SmallSQLException.create(Language.ROW_0_ABSOLUTE);\r\n        if(newRow > 0){\r\n            beforeFirst();\r\n            while(newRow-- > 0){\r\n                if(!next()){\r\n                    return false;\r\n                }\r\n            }\r\n        }else{\r\n            afterLast();\r\n            while(newRow++ < 0){\r\n                if(!previous()){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","startLine":15,"lastLine":18}],"window":4},{"content":"final void nullRow() {rowSource.nullRow();row = 0;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Where/nullRow()","rawLines":"final void nullRow() {\r\n\t\trowSource.nullRow();\r\n\t\trow = 0;\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/Distinct/nullRow()","rawLines":"final void nullRow() {\r\n\t\trowSource.nullRow();\r\n\t\trow = 0;\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"case SQLTokenizer.CLOB:case SQLTokenizer.NCLOB:case SQLTokenizer.LONGNVARCHAR:case SQLTokenizer.LONGVARCHAR:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getBoolean(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBoolean()\r\n     */\r\n    @Override\r\n    boolean getBoolean(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return false;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean();\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() ) != 0;\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() != 0;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() != 0;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat() != 0;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble() != 0;\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().getSignum() != 0;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Utils.string2boolean( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Utils.string2boolean( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Utils.string2boolean( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() ) != 0;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp() != 0;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime() != 0;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate() != 0;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime() != 0;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                return false;\r\n\t\t\tdefault: \r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BOOLEAN\" });\r\n        }\r\n    }","startLine":39,"lastLine":42},{"locFile":"java+method:///smallsql/database/StoreImpl/getLong(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getLong()\r\n     */\r\n    @Override\r\n    long getLong(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2long( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (long)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().longValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Long.parseLong( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Long.parseLong( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getLong( ois.readObject().toString(), SQLTokenizer.VARCHAR );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2long( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BIGINT\" });\r\n        }\r\n    }","startLine":39,"lastLine":42},{"locFile":"java+method:///smallsql/database/StoreImpl/getInt(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getInt()\r\n     */\r\n    @Override\r\n    int getInt(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return (int)readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (int)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (int)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n            \t\tlong longValue = readLong() / 10000;\r\n            \t\treturn Utils.money2int(longValue);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().intValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Integer.parseInt( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Integer.parseInt( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getInt(ois.readObject().toString(), SQLTokenizer.VARCHAR);\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn (int)readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn (int)readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn (int)readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn (int)readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"INT\" });\r\n        }\r\n    }","startLine":40,"lastLine":43},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/convertExpressionIfNeeded(smallsql.database.Expression,smallsql.database.Expression)","rawLines":"private Expression convertExpressionIfNeeded( Expression expr, Expression other ){\r\n        if(expr == null || other == null){\r\n            return expr;\r\n        }\r\n        switch(expr.getDataType()){\r\n        case SQLTokenizer.CHAR:\r\n        case SQLTokenizer.NCHAR:\r\n        case SQLTokenizer.BINARY:\r\n            switch(other.getDataType()){\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CLOB:\r\n            case SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.VARBINARY:\r\n                ExpressionFunctionRTrim trim = new ExpressionFunctionRTrim();\r\n                trim.setParams(new Expression[]{expr});\r\n                return trim;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.BINARY:\r\n                if(other.getPrecision() > expr.getPrecision()){\r\n                    return new ExpressionFunctionConvert(new ColumnExpression(other), expr, null );\r\n                }\r\n                break; \r\n            }\r\n            break;\r\n        }\r\n        return expr;\r\n    }","startLine":11,"lastLine":14},{"locFile":"java+method:///smallsql/database/StoreImpl/getFloat(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getFloat()\r\n     */\r\n    @Override\r\n    float getFloat(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2float( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (float)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / (float)10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / (float)10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().floatValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Float.parseFloat( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Float.parseFloat( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Float.parseFloat( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2float( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"REAL\" });\r\n        }\r\n    }","startLine":39,"lastLine":42},{"locFile":"java+method:///smallsql/database/StoreImpl/getBytes(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBytes()\r\n     */\r\n    @Override\r\n    byte[] getBytes(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    byte[] bytes = new byte[1];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.SMALLINT:\r\n                    bytes = new byte[2];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    bytes = new byte[4];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    bytes = new byte[8];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toByteArray();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString().getBytes();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString().getBytes();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    bytes = new byte[16];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":46,"lastLine":49},{"locFile":"java+method:///smallsql/database/StoreImpl/getMoney(int,int)","rawLines":"// is used for faster calculation\r\n    @Override\r\n    long getMoney( int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return (long)(Utils.bytes2double( readBinary() ) * 10000L);\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() * 10000L;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() * 10000L;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() * 10000L;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() * 10000L;\r\n            case SQLTokenizer.REAL:\r\n                    return (long)(readFloat() * 10000L);\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)(readDouble() * 10000L);\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return (long)(readNumeric().doubleValue() * 10000L);\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Money.parseMoney( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Money.parseMoney( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Money.parseMoney( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return (long)(Utils.bytes2double( readLongBinary() ) * 10000L);\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"MONEY\" });\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":37,"lastLine":40},{"locFile":"java+method:///smallsql/database/StoreImpl/getDouble(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getDouble()\r\n     */\r\n    @Override\r\n    double getDouble(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2double( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().doubleValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Double.parseDouble( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Double.parseDouble( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Double.parseDouble( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2double( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n        }\r\n    }","startLine":39,"lastLine":42},{"locFile":"java+method:///smallsql/database/StoreImpl/getNumeric(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBigDecimal()\r\n     */\r\n    @Override\r\n    MutableNumeric getNumeric(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":39,"lastLine":42},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":114,"lastLine":117}],"window":4},{"content":"}catch(Exception e){throw SmallSQLException.createFromException(e);}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/absolute(int)","rawLines":"public boolean absolute(int row) throws SQLException {\r\n\t\ttry{\r\n            moveToCurrentRow();\r\n\t\t\treturn getCmd().absolute(row);\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/beforeFirst()","rawLines":"public void beforeFirst() throws SQLException {\r\n    \ttry{\r\n            moveToCurrentRow();\r\n    \t\tgetCmd().beforeFirst();\r\n    \t}catch(Exception e){\r\n    \t\tthrow SmallSQLException.createFromException(e);\r\n    \t}\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/previous()","rawLines":"public boolean previous() throws SQLException {\r\n\t\ttry{\r\n            moveToCurrentRow();\r\n\t\t\treturn getCmd().previous();\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/getRow()","rawLines":"public int getRow() throws SQLException {\r\n\t\ttry{\r\n\t\t\treturn getCmd().getRow();\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}","startLine":3,"lastLine":6},{"locFile":"java+method:///smallsql/database/SSPreparedStatement/addBatch()","rawLines":"public void addBatch() throws SQLException {\r\n        checkStatement();\r\n    \ttry{\r\n\t    \tfinal Expressions params = cmd.params;\r\n\t    \tfinal int size = params.size();\r\n\t\t\tExpressionValue[] values = new ExpressionValue[size];\r\n\t    \tfor(int i=0; i<size; i++){\r\n\t    \t\tvalues[i] = (ExpressionValue)params.get(i).clone();\r\n\t    \t}\r\n\t    \tif(batches == null) batches = new ArrayList();\r\n\t    \tbatches.add(values);\r\n    \t}catch(Exception e){\r\n    \t\tthrow SmallSQLException.createFromException(e);\r\n    \t}\r\n    }","startLine":11,"lastLine":14},{"locFile":"java+method:///smallsql/database/SSResultSet/first()","rawLines":"public boolean first() throws SQLException {\r\n\t\ttry{\r\n\t\t\tif(st.rsType == ResultSet.TYPE_FORWARD_ONLY) throw SmallSQLException.create(Language.RSET_FWDONLY);\r\n            moveToCurrentRow();\r\n\t\t\treturn getCmd().first();\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/StorePage/commit()","rawLines":"@Override\r\n    long commit() throws SQLException{\r\n\t\ttry{\r\n\t\t    // rsFile == null --> rollback()\r\n\t\t    // page == null --> only a write lock, no data\r\n\t\t\tif(raFile != null && page != null){\r\n\t\t\t\t// if new page then append at end of file\r\n\t\t\t    ByteBuffer buffer = ByteBuffer.wrap( page, 0, pageSize );\r\n\t\t\t    synchronized(raFile){\r\n    \t\t\t\tif(fileOffset < 0){\r\n    \t\t\t\t\tfileOffset = raFile.size();\r\n    \t\t\t\t}\r\n\t\t\t\t    raFile.position(fileOffset);\r\n\t\t\t\t    raFile.write(buffer);\r\n\t\t\t\t}\r\n\t\t\t\t//raFile.getFD().sync();\r\n\t\t\t}\r\n\t\t\treturn fileOffset;\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}","startLine":18,"lastLine":21},{"locFile":"java+method:///smallsql/database/SSResultSet/last()","rawLines":"public boolean last() throws SQLException {\r\n\t\ttry{\r\n            moveToCurrentRow();\r\n            return getCmd().last();\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/afterLast()","rawLines":"public void afterLast() throws SQLException {\r\n\t\ttry{\r\n\t\t\tif(st.rsType == ResultSet.TYPE_FORWARD_ONLY) throw SmallSQLException.create(Language.RSET_FWDONLY);\r\n            moveToCurrentRow();\r\n            getCmd().afterLast();\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/isAfterLast()","rawLines":"public boolean isAfterLast() throws SQLException {\r\n        try{\r\n            return getCmd().isAfterLast();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException(e);\r\n        }\r\n    }","startLine":3,"lastLine":6},{"locFile":"java+method:///smallsql/database/SSResultSet/relative(int)","rawLines":"public boolean relative(int rows) throws SQLException {\r\n\t\ttry{\r\n            moveToCurrentRow();\r\n\t\t\treturn getCmd().relative(rows);\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/next()","rawLines":"public boolean next() throws SQLException {\r\n\t\ttry{\r\n            moveToCurrentRow();\r\n            return getCmd().next();\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}","startLine":4,"lastLine":7},{"locFile":"java+constructor:///smallsql/database/Database/Database(java.lang.String,java.io.File,boolean)","rawLines":"/**\r\n     * Create a instance of a Database\r\n     * @param name is used for getCatalog()\r\n     * @param canonicalFile the directory that is already canonical\r\n     * @param readonly open database in read only mode\r\n     * @throws SQLException If can't open\r\n     */\r\n    private Database( String name, File canonicalFile, boolean readonly ) throws SQLException{\r\n        try{\r\n\t        this.name = name;\r\n\t        this.readonly = readonly;\r\n\t\t\tdirectory = canonicalFile;\r\n\t\t\tif(!directory.isDirectory()){\r\n                throw SmallSQLException.create(Language.DB_NONEXISTENT, name);\r\n            }\r\n\t\t\tFile file = new File( directory, Utils.MASTER_FILENAME);\r\n\t\t\tif(!file.exists())\r\n\t\t\t\tthrow SmallSQLException.create(Language.DB_NOT_DIRECTORY, name);\r\n\t\t\tmaster = Utils.openRaFile( file, readonly );\r\n        }catch(Exception e){\r\n        \tthrow SmallSQLException.createFromException(e);\r\n        }\r\n    }","startLine":19,"lastLine":22},{"locFile":"java+constructor:///smallsql/database/ViewResult/ViewResult(smallsql.database.SSConnection,smallsql.database.CommandSelect)","rawLines":"/**\r\n\t * Constructor is used for UNION\r\n\t * @throws Exception \r\n\t * \r\n\t */\r\n\tViewResult(SSConnection con, CommandSelect commandSelect) throws SQLException{\r\n\t\ttry{\r\n\t\t\tthis.view = new View( con, commandSelect);\r\n\t\t\tthis.columnExpressions = commandSelect.columnExpressions;\r\n\t\t\tthis.commandSelect     = commandSelect;\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}","startLine":10,"lastLine":13},{"locFile":"java+method:///smallsql/database/SSResultSet/isLast()","rawLines":"public boolean isLast() throws SQLException {\r\n    \ttry{\r\n    \t\treturn getCmd().isLast();\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":3,"lastLine":6}],"window":4},{"content":"}}}}","cloneLocs":[{"locFile":"java+constructor:///smallsql/database/MemoryResult/MemoryResult(java.lang.Object%5B%5D%5B%5D,int)","rawLines":"/**\r\n\t * Constructor for DatabaseMetaData. ResultSets that not based on a store.\r\n\t */\r\n\tMemoryResult(Object[][] data, int colCount) throws SQLException{\r\n        for(int c=0; c<colCount; c++){\r\n            Column column = new Column();\r\n            column.setDataType(SQLTokenizer.NULL);\r\n            columns.add( column );\r\n        }\r\n\t\tfor(int r=0; r<data.length; r++){\r\n\t\t\tObject[] row = data[r];\r\n            ExpressionValue[] rowValues = new ExpressionValue[row.length];\r\n\t\t\taddRow(rowValues);\r\n\t\t\tfor(int c=0; c<colCount; c++){\r\n                ExpressionValue expr = rowValues[c] = new ExpressionValue();\r\n\t\t\t\texpr.set( row[c], -1);\r\n                Column column = columns.get(c);\r\n                if(expr.getDataType() != SQLTokenizer.NULL){\r\n                    column.setDataType(expr.getDataType());\r\n                }\r\n                if(expr.getPrecision() > column.getPrecision()){\r\n                    column.setPrecision(expr.getPrecision());\r\n                }\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":22,"lastLine":25},{"locFile":"java+constructor:///smallsql/database/DateTime/Details/Details(long)","rawLines":"Details(long time){\r\n\t\t\tint t = (int)(time % 86400000);\r\n\t\t\tint d = (int)(time / 86400000);\r\n\t\t\tif(t<0){\r\n\t\t\t    //Time before 1970 and not a full day\r\n\t\t\t\tt += 86400000;\r\n\t\t\t\td--;\r\n\t\t\t}\t\t\t\t\r\n\t\t\tmillis = t % 1000;\r\n\t\t\tt /= 1000;\r\n\t\t\tsecond = t % 60;\r\n\t\t\tt /= 60;\r\n\t\t\tminute = t % 60;\r\n\t\t\tt /= 60;\r\n\t\t\thour = t % 24;\r\n\r\n\t\t\tyear = 1970 - (int)(t / 365.2425);\r\n\t\t\tboolean isLeap;\r\n\t\t\tdo{\r\n\t\t\t\tisLeap = false;\r\n\t\t\t\tdayofyear = day = d - ((year - 1970)*365 + (year/4) - (year/100) + (year/400) - 477);\r\n\t\t\t\tif(isLeapYear(year)){\r\n\t\t\t\t\t// is leap year\r\n\t\t\t\t\tif(day < 59){\r\n\t\t\t\t\t\tday++;\r\n\t\t\t\t\t\tisLeap = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdayofyear++;\r\n\t\t\t\t}\r\n\t\t\t\tif(day < 0){\r\n\t\t\t\t\tyear--;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}else\r\n\t\t\t\tif(day >= 365){\r\n\t\t\t\t\tyear++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}while(true);\r\n\t\t\t\r\n\t\t\tif(isLeap && day == 59){\r\n\t\t\t\t// 29. Feb\r\n\t\t\t\tmonth = 1;\r\n\t\t\t\tday   = 29;\r\n\t\t\t}else{\r\n\t\t\t\tfor(int m=11; m>=0; m--){\r\n\t\t\t\t\tif(MONTH_DAYS[m] <= day){\r\n\t\t\t\t\t\tmonth = m;\r\n\t\t\t\t\t\tday   = day - MONTH_DAYS[m] + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}","startLine":50,"lastLine":53},{"locFile":"java+method:///smallsql/database/Database/closeConnection(smallsql.database.SSConnection)","rawLines":"/**\r\n\t * Remove a connection from this database.\r\n\t */\r\n\tstatic final void closeConnection(SSConnection con) throws SQLException{\r\n\t\tsynchronized(databases){\r\n\t\t\tIterator iterator = databases.values().iterator();\r\n\t\t\twhile(iterator.hasNext()){\r\n\t\t\t\tDatabase database = (Database)iterator.next();\r\n\t\t\t\tWeakHashMap connections = database.connections;\r\n\t\t\t\tconnections.remove(con);\r\n\t\t\t\tif(connections.size() == 0){\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\titerator.remove();\r\n\t\t\t\t\t\tdatabase.close();\r\n\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":17,"lastLine":20},{"locFile":"java+method:///smallsql/database/SSConnection/rollbackFile(java.nio.channels.FileChannel)","rawLines":"/**\r\n\t * Discard all changes of a file because it was deleted.\r\n\t */\r\n\tvoid rollbackFile(FileChannel raFile) throws SQLException{\r\n\t\ttestClosedConnection();\r\n\t\t// remove the all commits that point to this table\r\n\t\tsynchronized(getMonitor()){\r\n            for(int i = commitPages.size() - 1; i >= 0; i--){\r\n                TransactionStep page = (TransactionStep)commitPages.get(i);\r\n                if(page.raFile == raFile){\r\n                    page.rollback();\r\n                    page.freeLock();\r\n                }\r\n            }\r\n        }\r\n\t}","startLine":12,"lastLine":15},{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":68,"lastLine":71},{"locFile":"java+method:///smallsql/database/ExpressionInSelect/loadInList()","rawLines":"private void loadInList() throws Exception{\r\n\t\tif(cmdSel.compile(con)){\r\n\t\t\tcmdSel.from.execute();\r\n\t\t\tif(cmdSel.columnExpressions.size() != 1)\r\n\t\t\t\tthrow SmallSQLException.create(Language.SUBQUERY_COL_COUNT, new Integer(cmdSel.columnExpressions.size()));\r\n\t\t\tindex.clear();\r\n\t\t\twhile(cmdSel.next()){\r\n\t\t\t\ttry{\r\n\t\t\t\t\tindex.addValues(0, cmdSel.columnExpressions );\r\n\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t//double values can not add\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":11,"lastLine":14}],"window":4},{"content":"final long getLong() throws Exception {if(isNull()) return 0;return Long.parseLong(getString().trim());}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnString/getLong()","rawLines":"final long getLong() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Long.parseLong(getString().trim());\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1StringAndBinary/getLong()","rawLines":"final long getLong() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Long.parseLong(getString().trim());\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"if(equals(node.getRemainderValue(), key, i)){return node;}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/find(smallsql.database.IndexNode,long,int,java.util.ArrayList)","rawLines":"final private IndexNode find(IndexNode node, long key, int digitCount, ArrayList nodeList){\r\n\t\tfor(int i=digitCount-1; i>=0; i--){\r\n\t\t\tchar digit = (char)(key >> (i<<4));\r\n\t\t\tnode = node.getChildNode(digit);\r\n\t\t\t\r\n\t\t\tif(node == null) return null;\r\n\t\t\tif(nodeList != null) nodeList.add(node);\r\n\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn node;\r\n\t}","startLine":8,"lastLine":11},{"locFile":"java+method:///smallsql/database/Index/find(smallsql.database.IndexNode,char%5B%5D,java.util.ArrayList)","rawLines":"final private IndexNode find(IndexNode node, char[] key, ArrayList nodeList){\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tnode = node.getChildNode(digit);\r\n\r\n\t\t\tif(node == null) return null;\r\n\t\t\tif(nodeList != null) nodeList.add(node);\r\n\t\t\tif(++i == length){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":15,"lastLine":18}],"window":4},{"content":"try{Statement st = con.createStatement();st.execute(\"DELETE FROM \" + tableName);st.close();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/deleteTestTable(java.sql.Connection)","rawLines":"static void deleteTestTable(Connection con){\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            st.close();\r\n        }catch(Exception e){/* ignore it */}\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertRows(java.sql.Connection)","rawLines":"/**\r\n      *  5. Test\r\n      *  Insert rows with the method insertRow().\r\n      */  \r\n    static void test_InsertRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n\t            rs.updateBytes (  \"bi\", byteArray );\r\n\t            rs.updateString(  \"c\" , \"Test\" );\r\n\t            rs.updateDate  (  \"d\" , new Date( System.currentTimeMillis() ) );\r\n\t            rs.updateFloat (  \"de\", (float)1234.56789 );\r\n\t            rs.updateFloat (  \"f\" , (float)9876.54321 );\r\n\t            rs.updateBytes (  \"im\", largeByteArray );\r\n\t            rs.updateInt   (  \"i\" , i );\r\n\t            rs.updateDouble(  \"m\" , 23.45 );\r\n\t            rs.updateDouble(  \"n\" , 567.45 );\r\n\t            rs.updateFloat (  \"r\" , (float)78.89 );\r\n\t            rs.updateTime  (  \"sd\", new Time( System.currentTimeMillis() ) );\r\n\t            rs.updateShort (  \"si\", (short)i );\r\n\t            rs.updateFloat (  \"sm\", (float)34.56 );\r\n\t            rs.updateString(  \"sy\", \"sysname (30) NULL\" );\r\n\t            rs.updateString(  \"t\" , \"ntext NULL, sample to save in the field\" );\r\n\t            rs.updateByte  (  \"ti\", (byte)i );\r\n\t            rs.updateBytes (  \"vb\", byteArray );\r\n\t            rs.updateString(  \"vc\", \"nvarchar (255) NULL\" );\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                  st.execute(\"DELETE FROM \" + tableName);\r\n                  System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            }else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n        \te.printStackTrace();\r\n            try{\r\n                // reset for the next test\r\n                Statement st = con.createStatement();\r\n                st.execute(\"DELETE FROM \" + tableName);\r\n                st.close();\r\n            }catch(Exception ee){/* ignore it */}\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":45,"lastLine":49}],"window":4},{"content":"assertTrue( \"To few rows\", rs.next() );assertTrue( \"To few rows\", rs.next() );assertTrue( \"To few rows\", rs.next() );assertFalse( \"To many rows\", rs.next() );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":27,"lastLine":30},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":49,"lastLine":52},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":34,"lastLine":37}],"window":4},{"content":"String newValue = rs.getString(\"c2\");assertTrue( oldValue.compareTo( newValue ) < 0 );oldValue = newValue;count++;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/test2Columns()","rawLines":"public void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}","startLine":37,"lastLine":40},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test2Columns()","rawLines":"public void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}","startLine":18,"lastLine":21}],"window":4},{"content":"} catch (Exception e) {throw SmallSQLException.createFromException(e);}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getIndexInfo(java.lang.String,java.lang.String,java.lang.String,boolean,boolean)","rawLines":"public ResultSet getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"NON_UNIQUE\", \"INDEX_QUALIFIER\", \"INDEX_NAME\", \"TYPE\", \"ORDINAL_POSITION\", \"COLUMN_NAME\", \"ASC_OR_DESC\", \"CARDINALITY\", \"PAGES\", \"FILTER_CONDITION\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getIndexInfo(con, table, unique);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSet/updateRow()","rawLines":"public void updateRow() throws SQLException {\r\n        try {\r\n        \tif(values == null){\r\n                // no changes then also no update needed\r\n                return;\r\n            }\r\n       \t\tst.con.log.println(\"updateRow()\");\r\n            testNotInsertRow();\r\n            final CommandSelect command = getCmd();\r\n            command.updateRow( st.con, values);\r\n            command.relative(0);  //refresh the row\r\n            clearRowBuffer();\r\n        } catch (Exception e) {\r\n            throw SmallSQLException.createFromException(e);\r\n        }\r\n    }","startLine":12,"lastLine":15},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getCrossReference(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)","rawLines":"public ResultSet getCrossReference(String primaryCatalog, String primarySchema, String primaryTable, String foreignCatalog, String foreignSchema, String foreignTable) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"PKTABLE_CAT\", \"PKTABLE_SCHEM\", \"PKTABLE_NAME\", \"PKCOLUMN_NAME\", \"FKTABLE_CAT\", \"FKTABLE_SCHEM\", \"FKTABLE_NAME\", \"FKCOLUMN_NAME\", \"KEY_SEQ\", \"UPDATE_RULE\", \"DELETE_RULE\", \"FK_NAME\", \"PK_NAME\", \"DEFERRABILITY\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getReferenceKeys(con, primaryTable, foreignTable);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getColumns(java.lang.String,java.lang.String,java.lang.String,java.lang.String)","rawLines":"public ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getColumns(con, tableNamePattern, columnNamePattern);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getBestRowIdentifier(java.lang.String,java.lang.String,java.lang.String,int,boolean)","rawLines":"public ResultSet getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getBestRowIdentifier(con, table);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getVersionColumns(java.lang.String,java.lang.String,java.lang.String)","rawLines":"public ResultSet getVersionColumns(String catalog, String schema, String table) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n\t\t\tObject[][] data   = new Object[0][0];\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":5,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getPrimaryKeys(java.lang.String,java.lang.String,java.lang.String)","rawLines":"public ResultSet getPrimaryKeys(String catalog, String schema, String table) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"KEY_SEQ\", \"PK_NAME\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getPrimaryKeys(con, table);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":5,"lastLine":8}],"window":4},{"content":"int offset = token.offset + token.length;token = nextToken();if(token != null) offset = token.offset;previousToken();","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/addColumn(smallsql.database.SQLToken,smallsql.database.CommandTable)","rawLines":"/**\r\n     * Parse a Column and add it to the Command. If the column is unique or primary\r\n     * then an index is added.\r\n     * @param token the SQLToken with the column name\r\n     * @return the token of the delimiter\r\n     */\r\n    private SQLToken addColumn(SQLToken token, CommandTable cmdCreate) throws SQLException{\r\n        String colName = getIdentifier( token );\r\n        Column col = datatype(false);\r\n        col.setName( colName );\r\n\r\n\t\ttoken = nextToken();\r\n        boolean nullableWasSet = false;\r\n        boolean defaultWasSet = col.isAutoIncrement(); // with data type COUNTER already this value is set\r\n        while(true){\r\n            if(token == null){\r\n                cmdCreate.addColumn( col );\r\n                return null;\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.COMMA:\r\n                    cmdCreate.addColumn( col );\r\n                    return token;\r\n                case SQLTokenizer.DEFAULT:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tint offset = token.offset + token.length;\r\n                    token = nextToken();\r\n                    if(token != null) offset = token.offset;\r\n\t\t\t\t\tpreviousToken();                    \r\n\t\t\t\t\tExpression expr = expression(cmdCreate, 0);\r\n\t\t\t\t\tSQLToken last = lastToken();\r\n\t\t\t\t\tint length = last.offset + last.length - offset;\r\n\t\t\t\t\tString def = new String( sql, offset, length );\r\n                    col.setDefaultValue( expr, def );\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.IDENTITY:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    col.setAutoIncrement(true);\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NULL:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    //col.setNullable(true); is already default\r\n                    nullableWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NOT:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    token = nextToken( MISSING_NULL );\r\n                    col.setNullable(false);\r\n                    nullableWasSet = true;\r\n                    break;\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, cmdCreate.name, null, colName);\r\n\t\t\t\t\tcmdCreate.addIndex( index );\r\n\t\t\t\t\tbreak;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_OPTIONS_DATATYPE);\r\n            }\r\n            token = nextToken();\r\n        }\r\n    }","startLine":26,"lastLine":29},{"locFile":"java+method:///smallsql/database/SQLParser/expressionDefList(smallsql.database.Command,smallsql.database.Expressions,smallsql.database.Strings)","rawLines":"private void expressionDefList(Command cmd, Expressions expressions, Strings columns) throws SQLException{\r\n        SQLToken token = nextToken();\r\n        if(token.value != SQLTokenizer.PARENTHESIS_L) throw createSyntaxError(token, MISSING_PARENTHESIS_L );\r\n        Loop:\r\n        while(true){\r\n            int offset = token.offset + token.length;\r\n            token = nextToken();\r\n            if(token != null) offset = token.offset;\r\n            previousToken();  \r\n            \r\n            expressions.add( expression(cmd, 0) );\r\n            SQLToken last = lastToken();\r\n            int length = last.offset + last.length - offset;\r\n            columns.add( new String( sql, offset, length ) );\r\n\r\n            token = nextToken(MISSING_COMMA_PARENTHESIS);\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    break Loop;\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n                    throw new Error();\r\n            }\r\n        }\r\n    }","startLine":5,"lastLine":8}],"window":4},{"content":"final void beforeFirst() throws Exception {rowSource.beforeFirst();row = 0;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Where/beforeFirst()","rawLines":"final void beforeFirst() throws Exception {\r\n\t\trowSource.beforeFirst();\r\n\t\trow = 0;\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/Distinct/beforeFirst()","rawLines":"final void beforeFirst() throws Exception {\r\n\t\trowSource.beforeFirst();\r\n\t\trow = 0;\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"final int getInt() throws Exception {if(isNull()) return 0;return Integer.parseInt(getString().trim());}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1StringAndBinary/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Integer.parseInt(getString().trim());\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnString/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Integer.parseInt(getString().trim());\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"case SQLTokenizer.SMALLMONEY:return readInt() / 10000;case SQLTokenizer.NUMERIC:case SQLTokenizer.DECIMAL:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getLong(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getLong()\r\n     */\r\n    @Override\r\n    long getLong(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2long( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (long)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().longValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Long.parseLong( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Long.parseLong( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getLong( ois.readObject().toString(), SQLTokenizer.VARCHAR );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2long( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BIGINT\" });\r\n        }\r\n    }","startLine":29,"lastLine":32},{"locFile":"java+method:///smallsql/database/StoreImpl/getInt(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getInt()\r\n     */\r\n    @Override\r\n    int getInt(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return (int)readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (int)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (int)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n            \t\tlong longValue = readLong() / 10000;\r\n            \t\treturn Utils.money2int(longValue);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().intValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Integer.parseInt( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Integer.parseInt( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getInt(ois.readObject().toString(), SQLTokenizer.VARCHAR);\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn (int)readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn (int)readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn (int)readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn (int)readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"INT\" });\r\n        }\r\n    }","startLine":30,"lastLine":33}],"window":4},{"content":"for(int i = 0; i < 200; i++){Thread thread = new Thread(new Runnable(){public void run(){try{","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentConnectionWrite()","rawLines":"/**\r\n     * Create a table with a single row. In different connections a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentConnectionWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Connection con2 = AllTests.createConnection();\r\n                            Statement st2 = con2.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                            con2.close();\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }","startLine":16,"lastLine":20},{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentRead()","rawLines":"/**\r\n     * Test the concurrently read of a table\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentRead() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n\r\n        // Any table from another test that include rows.\r\n        final String sql = \"Select * From table_OrderBy1\";\r\n\r\n        // calculate the row count of this table\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs = st.executeQuery(\"Select * From table_OrderBy1\");\r\n        int count = 0;\r\n        while(rs.next()){\r\n            count++;\r\n        }\r\n        final int rowCount = count;\r\n\r\n        // start threads that check the row count\r\n        for(int i = 0; i < 200; i++){\r\n            Thread thread = new Thread(new Runnable(){\r\n\r\n                public void run(){\r\n                    try{\r\n                        assertRowCount(rowCount, sql);\r\n                    }catch(Throwable ex){\r\n                        throwable = ex;\r\n                    }\r\n                }\r\n\r\n            });\r\n            threadList.add(thread);\r\n            thread.start();\r\n        }\r\n\r\n        // wait until all threads are finish\r\n        for(int i = 0; i < threadList.size(); i++){\r\n            Thread thread = (Thread)threadList.get(i);\r\n            thread.join(5000);\r\n        }\r\n\r\n        // throw the exception if one occur\r\n        if(throwable != null){\r\n            throw throwable;\r\n        }\r\n    }","startLine":24,"lastLine":28},{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentThreadWrite()","rawLines":"/**\r\n     * Create a table with a single row. In different threads on the same connection a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentThreadWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Statement st2 = con.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }","startLine":16,"lastLine":20}],"window":4},{"content":"try{Expression expr = getValue(i);wasNull = expr.isNull();if(wasNull) return null;","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSCallableStatement/getTime(int)","rawLines":"public Time getTime(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTime( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getTimestamp(int)","rawLines":"public Timestamp getTimestamp(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return DateTime.getTimestamp( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSCallableStatement/getDate(int)","rawLines":"public Date getDate(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getDate( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4}],"window":4},{"content":"}catch(Exception e){}}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getTables(java.lang.String,java.lang.String,java.lang.String,java.lang.String%5B%5D)","rawLines":"public ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types) throws SQLException {\r\n\t\tString[] colNames = {\"TABLE_CAT\",\"TABLE_SCHEM\",\"TABLE_NAME\",\"TABLE_TYPE\",\"REMARKS\",\"TYPE_CAT\",\"TYPE_SCHEM\",\"TYPE_NAME\",\"SELF_REFERENCING_COL_NAME\",\"REF_GENERATION\"};\r\n\t\tDatabase database;\r\n\t\tif(catalog == null){ \r\n\t\t\tdatabase = con.getDatabase(true);\r\n\t\t\tif(database != null)\r\n\t\t\t\tcatalog = database.getName();\r\n    \t}else{\r\n\t\t\tdatabase = Database.getDatabase(catalog, con, false);\r\n    \t}\r\n\t\tArrayList rows = new ArrayList();\r\n\t\tboolean isTypeTable = types == null;\r\n\t\tboolean isTypeView = types == null;\r\n\t\tfor(int i=0; types != null && i<types.length; i++){\r\n\t\t\tif(\"TABLE\".equalsIgnoreCase(types[i])) isTypeTable = true;\r\n\t\t\tif(\"VIEW\" .equalsIgnoreCase(types[i])) isTypeView  = true;\r\n\t\t}\r\n\t\t\r\n\t\tif(database != null){\r\n\t\t\tStrings tables = database.getTables(tableNamePattern);\r\n\t\t\tfor(int i=0; i<tables.size(); i++){\r\n\t\t\t\tString table = tables.get(i);\r\n\t\t\t\tObject[] row = new Object[10];\r\n\t\t\t\trow[0] = catalog;\r\n\t\t\t\trow[2] = table;\r\n\t\t\t\ttry{\r\n\t\t\t\t\tif(database.getTableView( con, table) instanceof View){\r\n\t\t\t\t\t\tif(isTypeView){\r\n\t\t\t\t\t\t\trow[3] = \"VIEW\";\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(isTypeTable){\r\n\t\t\t\t\t\t\trow[3] = \"TABLE\";\t\t\t\t\t\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t//TODO invalid VIEWS does not show because it can't load.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] data = new Object[rows.size()][];\r\n\t\trows.toArray(data);\r\n\t\tCommandSelect cmdSelect = Utils.createMemoryCommandSelect( con, colNames, data);\r\n\t\tExpressions order = new Expressions();\r\n\t\torder.add( new ExpressionName(\"TABLE_TYPE\") );\r\n\t\torder.add( new ExpressionName(\"TABLE_NAME\") );\r\n\t\tcmdSelect.setOrder( order );\r\n\t\treturn new SSResultSet( st, cmdSelect);\r\n    }","startLine":37,"lastLine":41},{"locFile":"java+method:///smallsql/database/ExpressionInSelect/loadInList()","rawLines":"private void loadInList() throws Exception{\r\n\t\tif(cmdSel.compile(con)){\r\n\t\t\tcmdSel.from.execute();\r\n\t\t\tif(cmdSel.columnExpressions.size() != 1)\r\n\t\t\t\tthrow SmallSQLException.create(Language.SUBQUERY_COL_COUNT, new Integer(cmdSel.columnExpressions.size()));\r\n\t\t\tindex.clear();\r\n\t\t\twhile(cmdSel.next()){\r\n\t\t\t\ttry{\r\n\t\t\t\t\tindex.addValues(0, cmdSel.columnExpressions );\r\n\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t//double values can not add\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":9,"lastLine":13}],"window":4},{"content":"byte[] b = new byte[length];System.arraycopy(bytes, 0, b, 0, length);return b;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionRTrim/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n        int length = bytes.length;\r\n        while(length>0 && bytes[length-1]==0){\r\n            length--;\r\n        }\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, 0, b, 0, length);\r\n\t\treturn b;\t\t\r\n\t}","startLine":7,"lastLine":10},{"locFile":"java+method:///smallsql/database/ExpressionFunctionLeft/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint length = param2.getInt();\r\n\t\tif(bytes.length <= length) return bytes;\r\n\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, 0, b, 0, length);\r\n\t\treturn b;\t\t\r\n\t}","startLine":6,"lastLine":9}],"window":4},{"content":"Money money = new Money();money.value = value;return money;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Money/createFromUnscaledValue(long)","rawLines":"public static Money createFromUnscaledValue(long value){\r\n        Money money = new Money();\r\n        money.value = value;\r\n        return money;\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/Money/createFromUnscaledValue(int)","rawLines":"public static Money createFromUnscaledValue(int value){\r\n        Money money = new Money();\r\n        money.value = value;\r\n        return money;\r\n    }","startLine":1,"lastLine":4}],"window":4},{"content":"final MutableNumeric getNumeric() throws Exception {if(isNull()) return null;return new MutableNumeric(getString().trim());}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1StringAndBinary/getNumeric()","rawLines":"final MutableNumeric getNumeric() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\treturn new MutableNumeric(getString().trim());\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnString/getNumeric()","rawLines":"final MutableNumeric getNumeric() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\treturn new MutableNumeric(getString().trim());\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"final long getMoney() throws Exception {if(isNull()) return 0;return Money.parseMoney(getString().trim());}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnString/getMoney()","rawLines":"final long getMoney() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Money.parseMoney(getString().trim());\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1StringAndBinary/getMoney()","rawLines":"final long getMoney() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Money.parseMoney(getString().trim());\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"assertNotNull(\"RETURN_GENERATED_KEYS\", rs);assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));assertRowCount(1,rs);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":19,"lastLine":22},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":42,"lastLine":45},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":27,"lastLine":30},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":40,"lastLine":43},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":27,"lastLine":30}],"window":4},{"content":"}}return null;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSPreparedStatement/getMetaData()","rawLines":"public ResultSetMetaData getMetaData() throws SQLException {\r\n        checkStatement();\r\n\t\tif(cmd instanceof CommandSelect){\r\n\t\t\ttry{\r\n\t\t\t\t((CommandSelect)cmd).compile(con);\r\n\t\t\t\tSSResultSetMetaData metaData = new SSResultSetMetaData();\r\n\t\t\t\tmetaData.columns = cmd.columnExpressions;\r\n\t\t\t\treturn metaData;\r\n\t\t\t}catch(Exception e){\r\n\t\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n    }","startLine":10,"lastLine":13},{"locFile":"java+method:///smallsql/database/SQLParser/expressionSingle(smallsql.database.Command,smallsql.database.SQLToken)","rawLines":"/**\r\n     * This method parse a single expression like 12, 'qwert', 0x3F or a column name.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     */\r\n    private Expression expressionSingle(Command cmd, SQLToken token) throws SQLException{\r\n        boolean isMinus = false;\r\n        if(token != null){\r\n            switch(token.value){\r\n                case SQLTokenizer.NULL:\r\n                        return new ExpressionValue( null, SQLTokenizer.NULL );\r\n                case SQLTokenizer.STRING:\r\n                        return new ExpressionValue( token.getName(null), SQLTokenizer.VARCHAR );\r\n                case SQLTokenizer.IDENTIFIER:\r\n                        {\r\n                        String name = getIdentifier( token );\r\n                        ExpressionName expr =  new ExpressionName( name );\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                            expr.setNameAfterTableAlias( nextIdentifier() );\r\n                        }else{\r\n                            previousToken();\r\n                        }\r\n                        return expr;\r\n                        }\r\n                case SQLTokenizer.TRUE:\r\n                        return new ExpressionValue( Boolean.TRUE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.FALSE:\r\n                        return new ExpressionValue( Boolean.FALSE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.ESCAPE_L:{\r\n                        token = nextToken(COMMANDS_ESCAPE);\r\n                        SQLToken para = nextToken(MISSING_EXPRESSION);\r\n                        Expression expr;\r\n                        switch(token.value){\r\n                            case SQLTokenizer.D: // date escape sequence\r\n                            \texpr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.DATE), SQLTokenizer.DATE );\r\n                            \tbreak;\r\n                            case SQLTokenizer.T: // time escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIME), SQLTokenizer.TIME );\r\n                            \tbreak;\r\n                            case SQLTokenizer.TS: // timestamp escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP );\r\n                            \tbreak;\r\n                            case SQLTokenizer.FN: // function escape sequence\r\n                            \tnextToken(MISSING_PARENTHESIS_L);\r\n                            \texpr = function(cmd, para, true);\r\n                            \tbreak;\r\n                            case SQLTokenizer.CALL: // call escape sequence\r\n                                throw new java.lang.UnsupportedOperationException(\"call escape sequence\");\r\n                            default: throw new Error();\r\n                        }\r\n                        token = nextToken( ESCAPE_MISSING_CLOSE );\r\n                        return expr;\r\n                }\r\n                case SQLTokenizer.QUESTION:\r\n                        ExpressionValue param = new ExpressionValue();\r\n                        cmd.addParameter( param );\r\n                        return param;\r\n                case SQLTokenizer.CASE:\r\n                \t\treturn caseExpr(cmd);\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.PLUS:\r\n                        // sign detection\r\n                        do{\r\n                            if(token.value == SQLTokenizer.MINUS)\r\n                                    isMinus = !isMinus;\r\n                            token = nextToken();\r\n                            if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        }while(token.value == SQLTokenizer.MINUS || token.value == SQLTokenizer.PLUS);\r\n                        // no Break\r\n                default:\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.PARENTHESIS_L){\r\n                            if(isMinus)\r\n                                return new ExpressionArithmetic( function( cmd, token, false ),  ExpressionArithmetic.NEGATIVE );\r\n                            return function( cmd, token, false );\r\n                        }else{\r\n                            // constant expression or identifier\r\n                            char chr1 = sql[ token.offset ];\r\n\t\t\t\t\t\t\tif(chr1 == '$'){\r\n\t\t\t\t\t\t\t\tpreviousToken();\r\n\t                            String tok = new String(sql, token.offset+1, token.length-1);\r\n                                if(isMinus) tok = \"-\" + tok;\r\n\t\t\t\t\t\t\t\treturn new ExpressionValue( new Money(Double.parseDouble(tok)), SQLTokenizer.MONEY );\r\n\t\t\t\t\t\t\t}\r\n                            String tok = new String(sql, token.offset, token.length);\r\n                            if((chr1 >= '0' && '9' >= chr1) || chr1 == '.'){\r\n                                previousToken();\r\n                                // first character is a digit\r\n                                if(token.length>1 && (sql[ token.offset +1 ] | 0x20) == 'x'){\r\n                                    // binary data as hex\r\n                                    if(isMinus) {\r\n                \t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_OPER_MINUS);\r\n                                    }\r\n                                    return new ExpressionValue( Utils.hex2bytes( sql, token.offset+2, token.length-2), SQLTokenizer.VARBINARY );\r\n                                }\r\n                                if(isMinus) tok = \"-\" + tok;\r\n                                if(Utils.indexOf( '.', sql, token.offset, token.length ) >= 0 ||\r\n                                   Utils.indexOf( 'e', sql, token.offset, token.length ) >= 0){\r\n                                    return new ExpressionValue( new Double(tok), SQLTokenizer.DOUBLE );\r\n                                }else{\r\n                                    try{\r\n                                        return new ExpressionValue( new Integer(tok), SQLTokenizer.INT );\r\n                                    }catch(NumberFormatException e){\r\n                                        return new ExpressionValue( new Long(tok), SQLTokenizer.BIGINT );\r\n                                    }\r\n                                }\r\n                            }else{\r\n                                // identifier\r\n                                checkValidIdentifier( tok, token );\r\n                                ExpressionName expr = new ExpressionName(tok);\r\n                                if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                                    expr.setNameAfterTableAlias( nextIdentifier() );\r\n                                }else{\r\n                                    previousToken();\r\n                                }\r\n                                if(isMinus)\r\n                                    return new ExpressionArithmetic( expr,  ExpressionArithmetic.NEGATIVE );\r\n                                return expr;\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return null;\r\n    }","startLine":121,"lastLine":124},{"locFile":"java+method:///smallsql/database/Columns/get(java.lang.String)","rawLines":"/**\r\n     * Search for a Column with the given name. The search is not case sensitive.\r\n     * \r\n     * @param name\r\n     *            the name of the searching column.\r\n     * @return The first found column or null.\r\n     * @throws NullPointerException\r\n     *             if the name is null.\r\n     */\r\n    final Column get(String name){\r\n        for(int i = 0; i < size; i++){\r\n            Column column = data[i];\r\n            if(name.equalsIgnoreCase(column.getName())){\r\n                return column;\r\n            }\r\n        }\r\n        return null;\r\n    }","startLine":14,"lastLine":17}],"window":4},{"content":"((page[ offset++ ] & 0xFF) << 16) |((page[ offset++ ] & 0xFF) << 8) |((page[ offset++ ] & 0xFF));}","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/readInt()","rawLines":"int readInt(){\r\n        return  ((page[ offset++ ]) << 24) |\r\n                ((page[ offset++ ] & 0xFF) << 16) |\r\n                ((page[ offset++ ] & 0xFF) << 8) |\r\n                ((page[ offset++ ] & 0xFF));\r\n    }","startLine":2,"lastLine":5},{"locFile":"java+method:///smallsql/database/StoreImpl/readLong()","rawLines":"long readLong(){\r\n        //return (((long)readInt()) << 32) | (readInt() & 0xFFFFFFFFL);\r\n        return  ((long)(page[ offset++ ]) << 56) |\r\n                ((long)(page[ offset++ ] & 0xFF) << 48) |\r\n                ((long)(page[ offset++ ] & 0xFF) << 40) |\r\n                ((long)(page[ offset++ ] & 0xFF) << 32) |\r\n                ((long)(page[ offset++ ] & 0xFF) << 24) |\r\n                ((page[ offset++ ] & 0xFF) << 16) |\r\n                ((page[ offset++ ] & 0xFF) << 8) |\r\n                ((page[ offset++ ] & 0xFF));\r\n    }","startLine":7,"lastLine":10}],"window":4},{"content":"try{Expression expr = getValue(columnIndex);wasNull = expr.isNull();if(wasNull) return null;","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getTime(int)","rawLines":"public Time getTime(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTime( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSResultSet/getURL(int)","rawLines":"public URL getURL(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new URL( expr.getString() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSResultSet/getTimestamp(int)","rawLines":"public Timestamp getTimestamp(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTimestamp( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSResultSet/getDate(int)","rawLines":"public Date getDate(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getDate( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":4}],"window":4},{"content":"value[v1] = (int)temp;}boolean uebertrag = (temp >>> 32) != 0;while(v1 > 0 && uebertrag)","cloneLocs":[{"locFile":"java+method:///smallsql/database/MutableNumeric/sub(int%5B%5D)","rawLines":"/**\r\n     * Subtract the value to the current MutableNumeric Object and change it.\r\n     * The parameter <code>val2</code> has a shorter or equals length.\r\n     * The signum of both values is equals.\r\n     * @param val2 the subtracted  value\r\n     */\r\n    private void sub(int[] val2){\r\n        long temp = 0;\r\n        int v1 = value.length;\r\n        for(int v2 = val2.length; v2>0; ){\r\n            temp = (value[--v1] & 0xFFFFFFFFL) - (val2 [--v2] & 0xFFFFFFFFL) + (temp >>>= 32);\r\n            value[v1] = (int)temp;\r\n        }\r\n\r\n        boolean uebertrag = (temp >>> 32) != 0;\r\n        while(v1 > 0 && uebertrag)\r\n            uebertrag = (value[--v1] = value[v1] - 1) == -1;\r\n\r\n        if(uebertrag){\r\n            signum = -signum;\r\n            int last = value.length-1;\r\n            for(int i=0; i<=last; i++){\r\n                value[i] = (i == last) ? -value[i] : ~value[i];\r\n            }\r\n        }\r\n    }","startLine":11,"lastLine":15},{"locFile":"java+method:///smallsql/database/MutableNumeric/add(int%5B%5D)","rawLines":"/**\r\n     * Add the value to the current MutableNumeric Object and change it.\r\n     * The parameter <code>val2</code> has a shorter or equals length.\r\n     * The signum of both values is equals.\r\n     * @param val2 the added value\r\n     */\r\n    private void add( int[] val2){\r\n        long temp = 0;\r\n        int v1 = value.length;\r\n        for(int v2 = val2.length; v2>0; ){\r\n            temp = (value[--v1] & 0xFFFFFFFFL) + (val2 [--v2] & 0xFFFFFFFFL) + (temp >>> 32);\r\n            value[v1] = (int)temp;\r\n        }\r\n        boolean uebertrag = (temp >>> 32) != 0;\r\n        while(v1 > 0 && uebertrag)\r\n            uebertrag = (value[--v1] = value[v1] + 1) == 0;\r\n\r\n        // resize if needed\r\n        if(uebertrag){\r\n\t\t\tresizeValue(1);\r\n        }\r\n    }","startLine":11,"lastLine":14}],"window":4},{"content":"formatNumber( details.day, 2, buf);buf.append('-');formatNumber( details.month+1, 2, buf);buf.append('-');","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":79,"lastLine":82},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":86,"lastLine":89}],"window":4},{"content":"int getScale(){switch(dataType){case SQLTokenizer.DECIMAL:case SQLTokenizer.NUMERIC:","cloneLocs":[{"locFile":"java+method:///smallsql/database/Column/getScale()","rawLines":"int getScale(){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\treturn scale;\r\n\t\t\tdefault:\r\n\t\t\t\treturn Expression.getScale(dataType);\r\n\t\t}\r\n    }","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionValue/getScale()","rawLines":"int getScale(){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\tMutableNumeric obj = getNumeric();\r\n\t\t\t\treturn (obj == null) ? 0: obj.getScale();\r\n\t\t\tdefault:\r\n\t\t\t\treturn getScale(dataType);\r\n\t\t}\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"st.execute(\"alter table \"+table+\" add b varchar(4) primary key\");ResultSet rs = st.executeQuery(\"Select * From \" + table);assertRSMetaData( rs, new String[]{\"a\", \"b\"},  new int[]{Types.VARCHAR, Types.VARCHAR} );rs = con.getMetaData().getIndexInfo( null, null, table, false, false );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestAlterTable2/testAdd2Keys()","rawLines":"public void testAdd2Keys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"create table \"+table+\" (a varchar(2) unique)\");\r\n        st.execute(\"alter table \"+table+\" add b varchar(4) primary key\");\r\n        ResultSet rs = st.executeQuery(\"Select * From \" + table);\r\n        assertRSMetaData( rs, new String[]{\"a\", \"b\"},  new int[]{Types.VARCHAR, Types.VARCHAR} );\r\n        rs = con.getMetaData().getIndexInfo( null, null, table, false, false );\r\n        assertRowCount( 2, rs );\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/junit/TestAlterTable2/testAddPrimaryKey()","rawLines":"public void testAddPrimaryKey() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"create table \"+table+\" (a varchar(2))\");\r\n        st.execute(\"alter table \"+table+\" add b varchar(4) primary key\");\r\n        ResultSet rs = st.executeQuery(\"Select * From \" + table);\r\n        assertRSMetaData( rs, new String[]{\"a\", \"b\"},  new int[]{Types.VARCHAR, Types.VARCHAR} );\r\n        rs = con.getMetaData().getIndexInfo( null, null, table, false, false );\r\n        assertRowCount( 1, rs );\r\n    }","startLine":4,"lastLine":7}],"window":4},{"content":"case SQLTokenizer.BINARY:case SQLTokenizer.VARBINARY:return readBinary();case SQLTokenizer.TINYINT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getBytes(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBytes()\r\n     */\r\n    @Override\r\n    byte[] getBytes(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    byte[] bytes = new byte[1];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.SMALLINT:\r\n                    bytes = new byte[2];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    bytes = new byte[4];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    bytes = new byte[8];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toByteArray();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString().getBytes();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString().getBytes();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    bytes = new byte[16];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":8,"lastLine":11},{"locFile":"java+method:///smallsql/database/StoreImpl/getObject(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getObject()\r\n     */\r\n    @Override\r\n    Object getObject(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n                    return Utils.getInteger( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return Utils.getInteger( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return Utils.getInteger(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue(readLong());\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME );\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE );\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":11,"lastLine":14}],"window":4},{"content":"}default: throw new Error();}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionTimestampAdd/getLong()","rawLines":"long getLong() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\tswitch(interval){\r\n\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong();\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 1000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 60000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 3600000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 86400000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 604800000;\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong() * 3;\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.year += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t\t// TODO Auto-generated method stub\r\n\t}","startLine":29,"lastLine":33},{"locFile":"java+method:///smallsql/database/ExpressionFunctionTimestampDiff/getInt()","rawLines":"int getInt() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\tswitch(interval){\r\n\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() - param1.getLong());\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() /1000 - param1.getLong() /1000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn (int)(param2.getLong() /60000 - param1.getLong() /60000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn (int)(param2.getLong() /3600000 - param1.getLong() /3600000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn (int)(param2.getLong() /86400000 - param1.getLong() /86400000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\tlong day2 = param2.getLong() /86400000;\r\n\t\t\t\tlong day1 = param1.getLong() /86400000;\r\n\t\t\t\t// the 1. Jan 1970 is a Thursday --> 3\r\n\t\t\t\treturn (int)((day2 + 3) / 7 - (day1 + 3) / 7);\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 12 + details2.month) - (details1.year * 12 + details1.month);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 4 + details2.month / 3) - (details1.year * 4 + details1.month / 3);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn details2.year - details1.year;\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":32,"lastLine":35}],"window":4},{"content":"assertTrue( oldValue.compareTo( newValue ) < 0 );oldValue = newValue;count++;}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_varchar_asc()","rawLines":"public void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":19,"lastLine":22},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test2Columns()","rawLines":"public void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}","startLine":19,"lastLine":22},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testUnion()","rawLines":"public void testUnion() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT v, 5 as Const FROM \" + table1 + \" Union All Select vc, 6 From \" + table3 + \" ORDER by v\");\r\n\t\t\r\n\t\tassertRSMetaData(rs, new String[]{\"v\", \"Const\"}, new int[]{Types.VARCHAR, Types.INTEGER});\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 3;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+4, count );\r\n\t}","startLine":25,"lastLine":28}],"window":4},{"content":"break;}}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/CommandInsert/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception {\r\n        // on first time and on change of the table we need to recompile\r\n        if(table == null || tableTimestamp != table.getTimestamp()) compile( con );\r\n\r\n\t\tfinal IndexDescriptions indexes = table.indexes;\r\n\t\t\r\n\t\tupdateCount = 0;\r\n\t\tcmdSel.from.execute();\r\n\t\tcmdSel.beforeFirst();\r\n        \r\n        //Variables for GeneratedKeys\r\n        Strings keyColumnNames = null;\r\n        ArrayList keys = null;\r\n        boolean needGeneratedKeys = st.needGeneratedKeys();\r\n        int generatedKeysType = 0;\r\n\r\n        while(cmdSel.next()){\r\n            if(needGeneratedKeys){\r\n                keyColumnNames = new Strings();\r\n                keys = new ArrayList();\r\n                if(st.getGeneratedKeyNames() != null)\r\n                    generatedKeysType = 1;\r\n                if(st.getGeneratedKeyIndexes() != null)\r\n                    generatedKeysType = 2;\r\n            }\r\n\t        StoreImpl store = table.getStoreInsert( con );\r\n\t        for(int c=0; c<matrix.length; c++){\r\n\t            Column column = table.columns.get(c);\r\n\t            int idx = matrix[c];\r\n\t            Expression valueExpress;\r\n                if(idx >= 0){\r\n                    valueExpress = cmdSel.columnExpressions.get(idx);\r\n                }else{\r\n                    valueExpress = column.getDefaultValue(con);\r\n                    if(needGeneratedKeys && generatedKeysType == 0 && valueExpress != Expression.NULL){\r\n                        keyColumnNames.add(column.getName());\r\n                        keys.add(valueExpress.getObject());\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 1){\r\n                    String[] keyNames = st.getGeneratedKeyNames();\r\n                    for(int i=0; i<keyNames.length; i++){\r\n                        if(column.getName().equalsIgnoreCase(keyNames[i])){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 2){\r\n                    int[] keyIndexes = st.getGeneratedKeyIndexes();\r\n                    for(int i=0; i<keyIndexes.length; i++){\r\n                        if(c+1 == keyIndexes[i]){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\t            store.writeExpression( valueExpress, column );\r\n\t\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\t\tindexes.get(i).writeExpression( c, valueExpress );\r\n\t\t\t\t}\r\n\t        }\r\n\t        store.writeFinsh( con );\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tindexes.get(i).writeFinish( con );\r\n\t\t\t}\r\n\t        updateCount++;\r\n            if(needGeneratedKeys){\r\n                Object[][] data = new Object[1][keys.size()];\r\n                keys.toArray(data[0]);\r\n                st.setGeneratedKeys(new SSResultSet( st, Utils.createMemoryCommandSelect( con, keyColumnNames.toArray(), data)));\r\n            }\r\n        }\r\n    }","startLine":55,"lastLine":58},{"locFile":"java+method:///smallsql/database/CommandInsert/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception {\r\n        // on first time and on change of the table we need to recompile\r\n        if(table == null || tableTimestamp != table.getTimestamp()) compile( con );\r\n\r\n\t\tfinal IndexDescriptions indexes = table.indexes;\r\n\t\t\r\n\t\tupdateCount = 0;\r\n\t\tcmdSel.from.execute();\r\n\t\tcmdSel.beforeFirst();\r\n        \r\n        //Variables for GeneratedKeys\r\n        Strings keyColumnNames = null;\r\n        ArrayList keys = null;\r\n        boolean needGeneratedKeys = st.needGeneratedKeys();\r\n        int generatedKeysType = 0;\r\n\r\n        while(cmdSel.next()){\r\n            if(needGeneratedKeys){\r\n                keyColumnNames = new Strings();\r\n                keys = new ArrayList();\r\n                if(st.getGeneratedKeyNames() != null)\r\n                    generatedKeysType = 1;\r\n                if(st.getGeneratedKeyIndexes() != null)\r\n                    generatedKeysType = 2;\r\n            }\r\n\t        StoreImpl store = table.getStoreInsert( con );\r\n\t        for(int c=0; c<matrix.length; c++){\r\n\t            Column column = table.columns.get(c);\r\n\t            int idx = matrix[c];\r\n\t            Expression valueExpress;\r\n                if(idx >= 0){\r\n                    valueExpress = cmdSel.columnExpressions.get(idx);\r\n                }else{\r\n                    valueExpress = column.getDefaultValue(con);\r\n                    if(needGeneratedKeys && generatedKeysType == 0 && valueExpress != Expression.NULL){\r\n                        keyColumnNames.add(column.getName());\r\n                        keys.add(valueExpress.getObject());\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 1){\r\n                    String[] keyNames = st.getGeneratedKeyNames();\r\n                    for(int i=0; i<keyNames.length; i++){\r\n                        if(column.getName().equalsIgnoreCase(keyNames[i])){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 2){\r\n                    int[] keyIndexes = st.getGeneratedKeyIndexes();\r\n                    for(int i=0; i<keyIndexes.length; i++){\r\n                        if(c+1 == keyIndexes[i]){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\t            store.writeExpression( valueExpress, column );\r\n\t\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\t\tindexes.get(i).writeExpression( c, valueExpress );\r\n\t\t\t\t}\r\n\t        }\r\n\t        store.writeFinsh( con );\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tindexes.get(i).writeFinish( con );\r\n\t\t\t}\r\n\t        updateCount++;\r\n            if(needGeneratedKeys){\r\n                Object[][] data = new Object[1][keys.size()];\r\n                keys.toArray(data[0]);\r\n                st.setGeneratedKeys(new SSResultSet( st, Utils.createMemoryCommandSelect( con, keyColumnNames.toArray(), data)));\r\n            }\r\n        }\r\n    }","startLine":45,"lastLine":48},{"locFile":"java+constructor:///smallsql/database/DateTime/Details/Details(long)","rawLines":"Details(long time){\r\n\t\t\tint t = (int)(time % 86400000);\r\n\t\t\tint d = (int)(time / 86400000);\r\n\t\t\tif(t<0){\r\n\t\t\t    //Time before 1970 and not a full day\r\n\t\t\t\tt += 86400000;\r\n\t\t\t\td--;\r\n\t\t\t}\t\t\t\t\r\n\t\t\tmillis = t % 1000;\r\n\t\t\tt /= 1000;\r\n\t\t\tsecond = t % 60;\r\n\t\t\tt /= 60;\r\n\t\t\tminute = t % 60;\r\n\t\t\tt /= 60;\r\n\t\t\thour = t % 24;\r\n\r\n\t\t\tyear = 1970 - (int)(t / 365.2425);\r\n\t\t\tboolean isLeap;\r\n\t\t\tdo{\r\n\t\t\t\tisLeap = false;\r\n\t\t\t\tdayofyear = day = d - ((year - 1970)*365 + (year/4) - (year/100) + (year/400) - 477);\r\n\t\t\t\tif(isLeapYear(year)){\r\n\t\t\t\t\t// is leap year\r\n\t\t\t\t\tif(day < 59){\r\n\t\t\t\t\t\tday++;\r\n\t\t\t\t\t\tisLeap = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdayofyear++;\r\n\t\t\t\t}\r\n\t\t\t\tif(day < 0){\r\n\t\t\t\t\tyear--;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}else\r\n\t\t\t\tif(day >= 365){\r\n\t\t\t\t\tyear++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}while(true);\r\n\t\t\t\r\n\t\t\tif(isLeap && day == 59){\r\n\t\t\t\t// 29. Feb\r\n\t\t\t\tmonth = 1;\r\n\t\t\t\tday   = 29;\r\n\t\t\t}else{\r\n\t\t\t\tfor(int m=11; m>=0; m--){\r\n\t\t\t\t\tif(MONTH_DAYS[m] <= day){\r\n\t\t\t\t\t\tmonth = m;\r\n\t\t\t\t\t\tday   = day - MONTH_DAYS[m] + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}","startLine":49,"lastLine":52}],"window":4},{"content":"int mid = start + (end - start)/2;char nodeDigit = nodes[mid].digit;if(nodeDigit == digit) return mid;if(nodeDigit < digit){","cloneLocs":[{"locFile":"java+method:///smallsql/database/IndexNode/findNodeInsertPos(char,int,int)","rawLines":"private final int findNodeInsertPos(char digit, int start, int end){\r\n\t\tif(start == end) return start;\r\n\t\tint mid = start + (end - start)/2;\r\n\t\tchar nodeDigit = nodes[mid].digit;\r\n\t\tif(nodeDigit == digit) return mid;\r\n\t\tif(nodeDigit < digit){\r\n\t\t\treturn findNodeInsertPos( digit, mid+1, end );\r\n\t\t}else{\r\n\t\t\tif(start == mid) return start;\r\n\t\t\treturn findNodeInsertPos( digit, start, mid );\r\n\t\t}\r\n\t}","startLine":2,"lastLine":5},{"locFile":"java+method:///smallsql/database/IndexNode/findNodePos(char,int,int)","rawLines":"private final int findNodePos(char digit, int start, int end){\r\n\t\tif(start == nodes.length) return -1;\r\n\t\tint mid = start + (end - start)/2;\r\n\t\tchar nodeDigit = nodes[mid].digit;\r\n\t\tif(nodeDigit == digit) return mid;\r\n\t\tif(nodeDigit < digit){\r\n\t\t\treturn findNodePos( digit, mid+1, end );\r\n\t\t}else{\r\n\t\t\tif(start == mid) return -1;\r\n\t\t\treturn findNodePos( digit, start, mid-1 );\r\n\t\t}\r\n\t}","startLine":2,"lastLine":5}],"window":4},{"content":"break;case SQLTokenizer.NUMERIC:case SQLTokenizer.DECIMAL:MutableNumeric newValue = expr.getNumeric();","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":39,"lastLine":42},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":138,"lastLine":141},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":81,"lastLine":84}],"window":4},{"content":"}finally{dropTable( con, \"Scrollable\");}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestScrollable/testFirstWithWhere()","rawLines":"public void testFirstWithWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from Scrollable\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable Where 1=0\");\r\n\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n            testFirstWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0\") );\r\n            testFirstWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0 Order By v\") );\r\n            testFirstWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v\") );\r\n            testFirstWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v Order By v\") );\r\n\t\t}finally{\r\n            dropTable( con, \"Scrollable\");\r\n\t\t}\r\n\t}","startLine":15,"lastLine":18},{"locFile":"java+method:///smallsql/junit/TestScrollable/testPreviousWithWhere()","rawLines":"public void testPreviousWithWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from Scrollable\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable Where 1=0\");\r\n\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0\") );\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0 Order By v\") );\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v\") );\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v Order By v\") );\r\n            testPreviousWithWhereAssert( st.executeQuery(\"Select v from Scrollable Group By v Having 1=0 Order By v\") );\r\n\t\t\t\r\n\t\t}finally{\r\n            dropTable( con, \"Scrollable\");\r\n\t\t}\r\n\t}","startLine":17,"lastLine":20},{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelative()","rawLines":"public void testAbsoluteRelative() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert1')\");\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert2')\");\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert3')\");\r\n\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n            testAbsoluteRelativeAssert( st.executeQuery(\"Select * from Scrollable\") );\r\n            testAbsoluteRelativeAssert( st.executeQuery(\"Select * from Scrollable Order By i\") );\r\n            testAbsoluteRelativeAssert( st.executeQuery(\"Select v from Scrollable Group By v\") );\r\n            testAbsoluteRelativeAssert( st.executeQuery(\"Select v from Scrollable Group By v Order By v\") );\r\n\t\t}finally{\r\n            dropTable( con, \"Scrollable\");\r\n\t\t}\r\n\t}","startLine":15,"lastLine":18},{"locFile":"java+method:///smallsql/junit/TestScrollable/testUpdatable()","rawLines":"public void testUpdatable() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{            \r\n            con.createStatement().execute(\"Create Table Scrollable (i int Identity primary key, v varchar(20))\");\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\r\n            for(int row = 1; row < 4; row++){\r\n                testUpdatableAssert( con, st.executeQuery(\"Select * from Scrollable\"), row );\r\n                testUpdatableAssert( con, st.executeQuery(\"Select * from Scrollable Order By i\"), row );\r\n                testUpdatableAssert( con, st.executeQuery(\"Select * from Scrollable Where 1 = 1\"), row );\r\n                testUpdatableAssert( con, st.executeQuery(\"Select * from Scrollable Where 1 = 1 Order By i\"), row );\r\n                con.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert\" +row + \"')\");\r\n            }\r\n        }finally{\r\n            dropTable( con, \"Scrollable\");\r\n        }\r\n    }","startLine":13,"lastLine":16},{"locFile":"java+method:///smallsql/junit/TestScrollable/testLastWithWhere()","rawLines":"public void testLastWithWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from Scrollable\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable Where 1=0\");\r\n\r\n\t\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n            testLastWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0\") );\r\n            testLastWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0 Order By v\") );\r\n            testLastWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Order By v\") );\r\n            testLastWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v Order By v\") );\r\n\t\t}finally{\r\n            dropTable( con, \"Scrollable\");\r\n\t\t}\r\n\t}","startLine":15,"lastLine":18},{"locFile":"java+method:///smallsql/junit/TestScrollable/testNextWithWhere()","rawLines":"public void testNextWithWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table Scrollable (i counter, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into Scrollable(v) Values('qwert')\");\r\n\t\t\tassertRowCount( 1, \"Select * from Scrollable\");\r\n\t\t\tassertRowCount( 0, \"Select * from Scrollable Where 1=0\");\r\n\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n            testNextWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0\") );\r\n            testNextWithWhereAssert( st.executeQuery(\"Select * from Scrollable Where 1=0 Order By v\") );\r\n            testNextWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v\") );\r\n            testNextWithWhereAssert( st.executeQuery(\"Select v from Scrollable Where 1=0 Group By v Order By v\") );\r\n\t\t}finally{\r\n            dropTable( con, \"Scrollable\");\r\n\t\t}\r\n\t}","startLine":15,"lastLine":18}],"window":4},{"content":"if(value.length == 0 || signum == 0){return 0;}else{if (value.length == 1 && (value[0] > 0)){","cloneLocs":[{"locFile":"java+method:///smallsql/database/MutableNumeric/floatValue()","rawLines":"public float floatValue(){\r\n        if(value.length == 0 || signum == 0){\r\n            return 0;\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                return value[0] / scaleFloatFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                return temp / scaleFloatFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                return temp / scaleFloatFactor[scale] * signum;\r\n            }else{\r\n                return new BigDecimal( new BigInteger( toByteArray() ), scale ).floatValue();\r\n            }\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/MutableNumeric/longValue()","rawLines":"public long longValue(){\r\n        if(value.length == 0 || signum == 0){\r\n            return 0;\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                return Utils.double2long(value[0] / scaleDoubleFactor[scale] * signum);\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                return Utils.double2long(temp / scaleDoubleFactor[scale] * signum);\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                return Utils.double2long(temp / scaleDoubleFactor[scale] * signum);\r\n            }else{\r\n           \t\tif(scale != 0){\r\n           \t\t\tMutableNumeric numeric = new MutableNumeric(this);\r\n           \t\t\tnumeric.setScale(0);\r\n           \t\t\treturn numeric.longValue();\r\n           \t\t}           \t\t\t\r\n            \treturn (signum > 0) ? Long.MAX_VALUE : Long.MIN_VALUE;\r\n            }\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/MutableNumeric/doubleValue()","rawLines":"public double doubleValue(){\r\n        if(value.length == 0 || signum == 0){\r\n            return 0;\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                return value[0] / scaleDoubleFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                return temp / scaleDoubleFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                return temp / scaleDoubleFactor[scale] * signum;\r\n            }else{\r\n                return new BigDecimal( new BigInteger( toByteArray() ), scale ).doubleValue();\r\n            }\r\n        }\r\n    }","startLine":1,"lastLine":4}],"window":4},{"content":"| ((puffer[ offset++ ] & 0xFF) << 16)| ((puffer[ offset++ ] & 0xFF) << 8)|  (puffer[ offset++ ] & 0xFF);}","cloneLocs":[{"locFile":"java+method:///smallsql/database/MemoryStream/readLong()","rawLines":"long readLong(){\r\n\t\treturn (((long)(puffer[ offset++ ] & 0xFF)) << 56)\r\n\t\t\t | (((long)(puffer[ offset++ ] & 0xFF)) << 48)\r\n\t\t\t | (((long)(puffer[ offset++ ] & 0xFF)) << 40)\r\n\t\t\t | (((long)(puffer[ offset++ ] & 0xFF)) << 32)\r\n\t\t\t | ((puffer[ offset++ ] & 0xFF) << 24)\r\n\t\t\t | ((puffer[ offset++ ] & 0xFF) << 16)\r\n\t\t\t | ((puffer[ offset++ ] & 0xFF) << 8)\r\n\t\t\t |  (puffer[ offset++ ] & 0xFF);\r\n\t}","startLine":6,"lastLine":9},{"locFile":"java+method:///smallsql/database/MemoryStream/readInt()","rawLines":"int readInt(){\r\n\t\treturn ((puffer[ offset++ ] & 0xFF) << 24)\r\n\t\t\t | ((puffer[ offset++ ] & 0xFF) << 16)\r\n\t\t\t | ((puffer[ offset++ ] & 0xFF) << 8)\r\n\t\t\t |  (puffer[ offset++ ] & 0xFF);\r\n\t}","startLine":2,"lastLine":5}],"window":4},{"content":"if(complement == 0){signum = 0;value = EMPTY_INTS;}else{","cloneLocs":[{"locFile":"java+constructor:///smallsql/database/MutableNumeric/MutableNumeric(int)","rawLines":"MutableNumeric(int complement){\r\n        if(complement == 0){\r\n            signum = 0;\r\n            value = EMPTY_INTS;\r\n        }else{\r\n            value = new int[1];\r\n            if(complement < 0){\r\n                value[0] = -complement;\r\n                signum = -1;\r\n            }else{\r\n                value[0] = complement;\r\n                signum = 1;\r\n            }\r\n        }\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+constructor:///smallsql/database/MutableNumeric/MutableNumeric(long)","rawLines":"MutableNumeric(long complement){\r\n        if(complement == 0){\r\n            signum = 0;\r\n            value = EMPTY_INTS;\r\n        }else{\r\n            value = new int[2];\r\n            if(complement < 0){\r\n                value[0] = (int)(~(complement >> 32));\r\n                value[1] = (int)(-complement);\r\n                signum = -1;\r\n            }else{\r\n                value[0] = (int)(complement >> 32);\r\n                value[1] = (int)complement;\r\n                signum = 1;\r\n            }\r\n        }\r\n    }","startLine":1,"lastLine":4}],"window":4},{"content":"wasWhiteSpace = false;break;}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":192,"lastLine":195},{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":176,"lastLine":179}],"window":4},{"content":"init();Connection con = AllTests.getConnection();Statement st = con.createStatement();ResultSet rs;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testVarcharEmpty()","rawLines":"public void testVarcharEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vc\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( \"\", rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( table3, rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testVarbinaryEmpty()","rawLines":"public void testVarbinaryEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vb\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vb\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", new byte[0], rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", table3.getBytes(), rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestGroupBy/testGroupBy()","rawLines":"public void testGroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\trs = st.executeQuery(\"Select name FROM \" + table1 + \" Group By name\");\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( STR_VALUE1, rs.getObject(1) ); \r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( STR_VALUE2, rs.getObject(1) ); \r\n\t\t\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_boolean()","rawLines":"public void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestGroupBy/testTest()","rawLines":"public void testTest() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t/*\r\n\t\trs = st.executeQuery(\"Select name FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\tSystem.out.println( rs.getObject(1) ); \r\n\t\t}*/\r\n\t\t\r\n\t\trs = st.executeQuery(\"Select count(id) FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\trs.getObject(1);\r\n\t\t}\r\n\r\n\t\trs = st.executeQuery(\"Select count(*) FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\trs.getObject(1);\r\n\t\t}\r\n\r\n\t\trs = st.executeQuery(\"Select count(*) FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 4, rs.getInt(1));\r\n\r\n\t\trs = st.executeQuery(\"Select count(id) FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 3, rs.getInt(1));\r\n\r\n\t\trs = st.executeQuery(\"Select count(*)+1 FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 5, rs.getInt(1));\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_double()","rawLines":"public void testOrderBy_double() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tDouble oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by d\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Double)rs.getObject(\"d\") ) < 0 );\r\n\t\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_real()","rawLines":"public void testOrderBy_real() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tFloat oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by r\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Float)rs.getObject(\"r\") ) < 0 );\r\n\t\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":1,"lastLine":4}],"window":4},{"content":"if (idx >= size)throw new IndexOutOfBoundsException(\"Index: \"+idx+\", Size: \"+size);return data[idx];}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Expressions/get(int)","rawLines":"final Expression get(int idx){\r\n\t\tif (idx >= size)\r\n\t\t\tthrow new IndexOutOfBoundsException(\"Index: \"+idx+\", Size: \"+size);\r\n\t\treturn data[idx];\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/DataSources/get(int)","rawLines":"final DataSource get(int idx){\r\n\t\tif (idx >= size)\r\n\t\t\tthrow new IndexOutOfBoundsException(\"Index: \"+idx+\", Size: \"+size);\r\n\t\treturn data[idx];\r\n\t}","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/LongList/get(int)","rawLines":"final long get(int idx){\r\n\t\tif (idx >= size)\r\n\t\t\tthrow new IndexOutOfBoundsException(\"Index: \"+idx+\", Size: \"+size);\r\n\t\treturn data[idx];\r\n\t}","startLine":1,"lastLine":4}],"window":4},{"content":"if(fullReturnCounter >= fullRowCount){return false;}right.next();","cloneLocs":[{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":85,"lastLine":88}],"window":4},{"content":"final double getDouble() throws Exception {if(isNull()) return 0;return Double.parseDouble(getString().trim());}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1StringAndBinary/getDouble()","rawLines":"final double getDouble() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Double.parseDouble(getString().trim());\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnString/getDouble()","rawLines":"final double getDouble() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Double.parseDouble(getString().trim());\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"assertNotSame(\"getObject\", value, rs.getObject(\"c\"));assertTrue(\"start\", rs.first());rs.updateObject(\"c\", value, Types.VARCHAR );assertEquals(\"getObject\", value, rs.getObject(\"c\"));","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestResultSet/testUpdateAndScroll()","rawLines":"/**\r\n     * test if scrolling reset the update values\r\n     */\r\n    public void testUpdateAndScroll() throws Exception{\r\n        final Object value = \"UpdateAndScroll\";\r\n        Object value1;\r\n        Object value2;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs = st.executeQuery(\"Select * From ResultSet\");\r\n        \r\n        //method first\r\n        assertTrue(\"start\", rs.last());\r\n        value1 = rs.getObject(\"i\");\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertEquals(\"getObject\", value1, rs.getObject(\"i\"));\r\n        assertTrue(\"first\", rs.first());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method next\r\n        assertTrue(\"start\", rs.first());\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertTrue(\"next\", rs.next());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method previous\r\n        assertTrue(\"start\", rs.last());\r\n        rs.updateObject(\"c\", value );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertTrue(\"previous\", rs.previous());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method last\r\n        assertTrue(\"start\", rs.first());\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertTrue(\"last\", rs.last());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method refresh\r\n        assertTrue(\"start\", rs.first());\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        rs.refreshRow();\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method moveToInsertRow and moveToCurrentRow\r\n        assertTrue(\"start\", rs.first());\r\n        value1 = rs.getObject(\"i\");\r\n        value2 = rs.getObject(\"c\");\r\n        rs.updateObject(\"c\", value);\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        rs.moveToInsertRow();\r\n        assertNull(\"new row\", rs.getObject(\"i\"));\r\n        assertNull(\"new row\", rs.getObject(\"c\"));\r\n        rs.updateObject(\"c\", value);\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        rs.moveToCurrentRow();\r\n        assertEquals(\"getObject\", value1, rs.getObject(\"i\"));\r\n        assertEquals(\"getObject\", value2, rs.getObject(\"c\"));\r\n    }","startLine":32,"lastLine":37},{"locFile":"java+method:///smallsql/junit/TestResultSet/testUpdateAndScroll()","rawLines":"/**\r\n     * test if scrolling reset the update values\r\n     */\r\n    public void testUpdateAndScroll() throws Exception{\r\n        final Object value = \"UpdateAndScroll\";\r\n        Object value1;\r\n        Object value2;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs = st.executeQuery(\"Select * From ResultSet\");\r\n        \r\n        //method first\r\n        assertTrue(\"start\", rs.last());\r\n        value1 = rs.getObject(\"i\");\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertEquals(\"getObject\", value1, rs.getObject(\"i\"));\r\n        assertTrue(\"first\", rs.first());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method next\r\n        assertTrue(\"start\", rs.first());\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertTrue(\"next\", rs.next());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method previous\r\n        assertTrue(\"start\", rs.last());\r\n        rs.updateObject(\"c\", value );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertTrue(\"previous\", rs.previous());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method last\r\n        assertTrue(\"start\", rs.first());\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertTrue(\"last\", rs.last());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method refresh\r\n        assertTrue(\"start\", rs.first());\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        rs.refreshRow();\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method moveToInsertRow and moveToCurrentRow\r\n        assertTrue(\"start\", rs.first());\r\n        value1 = rs.getObject(\"i\");\r\n        value2 = rs.getObject(\"c\");\r\n        rs.updateObject(\"c\", value);\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        rs.moveToInsertRow();\r\n        assertNull(\"new row\", rs.getObject(\"i\"));\r\n        assertNull(\"new row\", rs.getObject(\"c\"));\r\n        rs.updateObject(\"c\", value);\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        rs.moveToCurrentRow();\r\n        assertEquals(\"getObject\", value1, rs.getObject(\"i\"));\r\n        assertEquals(\"getObject\", value2, rs.getObject(\"c\"));\r\n    }","startLine":39,"lastLine":44},{"locFile":"java+method:///smallsql/junit/TestResultSet/testUpdateAndScroll()","rawLines":"/**\r\n     * test if scrolling reset the update values\r\n     */\r\n    public void testUpdateAndScroll() throws Exception{\r\n        final Object value = \"UpdateAndScroll\";\r\n        Object value1;\r\n        Object value2;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs = st.executeQuery(\"Select * From ResultSet\");\r\n        \r\n        //method first\r\n        assertTrue(\"start\", rs.last());\r\n        value1 = rs.getObject(\"i\");\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertEquals(\"getObject\", value1, rs.getObject(\"i\"));\r\n        assertTrue(\"first\", rs.first());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method next\r\n        assertTrue(\"start\", rs.first());\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertTrue(\"next\", rs.next());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method previous\r\n        assertTrue(\"start\", rs.last());\r\n        rs.updateObject(\"c\", value );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertTrue(\"previous\", rs.previous());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method last\r\n        assertTrue(\"start\", rs.first());\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        assertTrue(\"last\", rs.last());\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method refresh\r\n        assertTrue(\"start\", rs.first());\r\n        rs.updateObject(\"c\", value, Types.VARCHAR );\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        rs.refreshRow();\r\n        assertNotSame(\"getObject\", value, rs.getObject(\"c\"));\r\n        \r\n        //method moveToInsertRow and moveToCurrentRow\r\n        assertTrue(\"start\", rs.first());\r\n        value1 = rs.getObject(\"i\");\r\n        value2 = rs.getObject(\"c\");\r\n        rs.updateObject(\"c\", value);\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        rs.moveToInsertRow();\r\n        assertNull(\"new row\", rs.getObject(\"i\"));\r\n        assertNull(\"new row\", rs.getObject(\"c\"));\r\n        rs.updateObject(\"c\", value);\r\n        assertEquals(\"getObject\", value, rs.getObject(\"c\"));\r\n        rs.moveToCurrentRow();\r\n        assertEquals(\"getObject\", value1, rs.getObject(\"i\"));\r\n        assertEquals(\"getObject\", value2, rs.getObject(\"c\"));\r\n    }","startLine":18,"lastLine":23}],"window":4},{"content":"final byte[] getBytes() throws Exception{if(isNull()) return null;return getString().getBytes();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionLCase/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n        if(isNull()) return null;\r\n        return getString().getBytes();\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionUCase/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n        if(isNull()) return null;\r\n        return getString().getBytes();\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"}Expression expr = getValue(columnIndex);wasNull = expr.isNull();if(wasNull) return null;","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getTimestamp(int,java.util.Calendar)","rawLines":"public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getTimestamp(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Timestamp(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/getTime(int,java.util.Calendar)","rawLines":"public Time getTime(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getTime(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Time(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":4,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/getDate(int,java.util.Calendar)","rawLines":"public Date getDate(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getDate(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Date(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":4,"lastLine":7}],"window":4},{"content":"formatNumber( details.day, 2, buf);buf.append('.');formatNumber( details.month+1, 2, buf);buf.append('.');","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":65,"lastLine":68},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":72,"lastLine":75}],"window":4},{"content":"Object obj = getObject();if(obj == null) return null;return obj.toString();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionFloor/getString()","rawLines":"String getString() throws Exception{\r\n        Object obj = getObject();\r\n        if(obj == null) return null;\r\n        return obj.toString();\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnFloat/getString()","rawLines":"final String getString() throws Exception{\r\n        Object obj = getObject();\r\n        if(obj == null) return null;\r\n        return obj.toString();\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/database/ExpressionFunctionAbs/getString()","rawLines":"String getString() throws Exception{\r\n        Object obj = getObject();\r\n        if(obj == null) return null;\r\n        return obj.toString();\r\n    }","startLine":1,"lastLine":4}],"window":4},{"content":"Connection con = AllTests.getConnection();Statement st = con.createStatement();int firstValue = -10000;for(int i=firstValue; i<10000; i++){","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestMoneyRounding/testMoney1()","rawLines":"public void testMoney1() throws Exception{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            int firstValue = -10000;\r\n            for(int i=firstValue; i<10000; i++){\r\n                st.execute(\"Insert into \" + table + \"(a,b) values(\" + (i/10000.0) + \",\" +(i/10000.0) +\")\");\r\n            }\r\n            st.close();\r\n            verify(firstValue);\r\n    }","startLine":1,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestMoneyRounding/testMoney2()","rawLines":"public void testMoney2() throws Exception{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tint firstValue = -10000;\r\n\t\t\tfor(int i=firstValue; i<10000; i++){\r\n\t\t\t\tst.execute(\"Insert into \" + table + \"(a,b) values( (\" + i + \"/10000.0), (\" + i + \"/10000.0) )\");\r\n\t\t\t}\r\n\t\t\tst.close();\r\n\t\t\tverify(firstValue);\r\n\t}","startLine":1,"lastLine":4}],"window":4},{"content":"assertTrue( rs.next() );assertNull(rs.getObject(\"i\"));assertTrue( rs.next() );oldValue = Math.abs( rs.getInt(\"i\") );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_function()","rawLines":"public void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":9,"lastLine":13},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_functionAscDesc()","rawLines":"public void test_functionAscDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\tint oldValue2;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i) Asc, i desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\toldValue2 = rs.getInt(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue2 = rs.getInt(\"i\");\r\n\t\t\tint newValue = Math.abs( newValue2 );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\tif(oldValue == newValue){\r\n\t\t\t\tassertTrue( oldValue2 > newValue2 );\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t\toldValue2 = newValue2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":10,"lastLine":14}],"window":4},{"content":"break;case SQLTokenizer.UNIQUEIDENTIFIER:offset += 16;break;","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":52,"lastLine":55},{"locFile":"java+method:///smallsql/database/StoreImpl/scanObjectOffsets(int%5B%5D,int%5B%5D)","rawLines":"@Override\r\n    void scanObjectOffsets( int[] offsets, int dataTypes[] ){\r\n        offset = PAGE_CONTROL_SIZE;\r\n        for(int i=0; i<offsets.length; i++){\r\n            offsets[i] = offset;\r\n            boolean isNull = readBoolean(); // for isNull\r\n            switch(dataTypes[i]){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                    int count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count;  // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    count = readByte();\r\n\t\t\t\t\toffset += 2;\r\n\t\t\t\t\tif(!isNull) offset += count*4;\r\n                    break;\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count << 1; // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                default: throw new Error(String.valueOf( dataTypes[i] ) );\r\n            }\r\n        }\r\n    }","startLine":54,"lastLine":57}],"window":4},{"content":"assertFalse( rs.isBeforeFirst() );assertTrue( rs.isFirst() );assertTrue( rs.isLast() );assertFalse( rs.isAfterLast() );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOther/testNoFromResult()","rawLines":"public void testNoFromResult() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\t\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY );\r\n\t\tResultSet rs = st.executeQuery(\"Select 12, 'qwert' alias\");\r\n\t\t\r\n\t\tassertRSMetaData( rs, new String[]{\"col1\", \"alias\"}, new int[]{Types.INTEGER, Types.VARCHAR });\r\n\t\t\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertTrue( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.previous() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.previous() );\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.first() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.last() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t}","startLine":26,"lastLine":29},{"locFile":"java+method:///smallsql/junit/TestOther/testNoFromResult()","rawLines":"public void testNoFromResult() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\t\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY );\r\n\t\tResultSet rs = st.executeQuery(\"Select 12, 'qwert' alias\");\r\n\t\t\r\n\t\tassertRSMetaData( rs, new String[]{\"col1\", \"alias\"}, new int[]{Types.INTEGER, Types.VARCHAR });\r\n\t\t\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertTrue( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.previous() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.previous() );\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.first() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.last() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t}","startLine":14,"lastLine":17},{"locFile":"java+method:///smallsql/junit/TestOther/testNoFromResult()","rawLines":"public void testNoFromResult() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\t\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY );\r\n\t\tResultSet rs = st.executeQuery(\"Select 12, 'qwert' alias\");\r\n\t\t\r\n\t\tassertRSMetaData( rs, new String[]{\"col1\", \"alias\"}, new int[]{Types.INTEGER, Types.VARCHAR });\r\n\t\t\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertTrue( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.previous() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.previous() );\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.first() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.last() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t}","startLine":38,"lastLine":41},{"locFile":"java+method:///smallsql/junit/TestOther/testNoFromResult()","rawLines":"public void testNoFromResult() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\t\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY );\r\n\t\tResultSet rs = st.executeQuery(\"Select 12, 'qwert' alias\");\r\n\t\t\r\n\t\tassertRSMetaData( rs, new String[]{\"col1\", \"alias\"}, new int[]{Types.INTEGER, Types.VARCHAR });\r\n\t\t\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertTrue( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.previous() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertFalse( rs.previous() );\r\n\t\tassertTrue( rs.isBeforeFirst() );\r\n\t\tassertFalse( rs.isFirst() );\r\n\t\tassertFalse( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.first() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t\t\r\n\t\tassertTrue( rs.last() );\r\n\t\tassertFalse( rs.isBeforeFirst() );\r\n\t\tassertTrue( rs.isFirst() );\r\n\t\tassertTrue( rs.isLast() );\r\n\t\tassertFalse( rs.isAfterLast() );\r\n\t}","startLine":44,"lastLine":47}],"window":4},{"content":"page.freeLock();}commitPages.clear();transactionTime = System.currentTimeMillis();","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSConnection/commit()","rawLines":"public void commit() throws SQLException {\r\n        log.println(\"Commit\");\r\n        testClosedConnection();\r\n        synchronized(getMonitor()){\r\n    \ttry{\r\n\t            int count = commitPages.size();\r\n\t            for(int i=0; i<count; i++){\r\n\t                TransactionStep page = (TransactionStep)commitPages.get(i);\r\n\t                page.commit();\r\n\t            }\r\n\t\t\t\tfor(int i=0; i<count; i++){\r\n\t\t\t\t    TransactionStep page = (TransactionStep)commitPages.get(i);\r\n\t\t\t\t\tpage.freeLock();\r\n\t\t\t\t}\r\n\t            commitPages.clear();\r\n\t            transactionTime = System.currentTimeMillis();\r\n    \t}catch(Throwable e){\r\n    \t\trollback();\r\n    \t\tthrow SmallSQLException.createFromException(e);\r\n    \t}\r\n        }\r\n    }","startLine":12,"lastLine":15},{"locFile":"java+method:///smallsql/database/SSConnection/rollback()","rawLines":"public void rollback() throws SQLException {\r\n\t\tlog.println(\"Rollback\");\r\n\t\ttestClosedConnection();\r\n        synchronized(getMonitor()){\r\n            int count = commitPages.size();\r\n            for(int i=0; i<count; i++){\r\n                TransactionStep page = (TransactionStep)commitPages.get(i);\r\n                page.rollback();\r\n                page.freeLock();\r\n            }\r\n            commitPages.clear();\r\n\t\t\ttransactionTime = System.currentTimeMillis();\r\n        }\r\n    }","startLine":8,"lastLine":11}],"window":4},{"content":"fail(\"Alter Table should not work on a table with a lock.\");} catch (SQLException ex) {assertSQLException( \"01000\", 0, ex );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestAlterTable/testAddWithTableLock_READ_COMMITTED()","rawLines":"public void testAddWithTableLock_READ_COMMITTED() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        int isolation = con.getTransactionIsolation();\r\n        con.setAutoCommit(false);\r\n        try{\r\n            con.setTransactionIsolation( Connection.TRANSACTION_READ_COMMITTED );\r\n            ResultSet rs = st.executeQuery(\"Select * From \" + table);\r\n            rs.next();\r\n            st.execute(\"Alter Table \" + table + \" Add a Varchar(20)\");\r\n            try {\r\n                rs.next();\r\n                fail(\"Alter Table should not work on a table with a lock.\");\r\n            } catch (SQLException ex) {\r\n                assertSQLException( \"01000\", 0, ex );\r\n            }\r\n        }finally{\r\n            con.setTransactionIsolation(isolation);\r\n            con.setAutoCommit(true);\r\n        }\r\n    }","startLine":12,"lastLine":15},{"locFile":"java+method:///smallsql/junit/TestAlterTable/testAddWithTableLock_REPEATABLE_READ()","rawLines":"public void testAddWithTableLock_REPEATABLE_READ() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        int isolation = con.getTransactionIsolation();\r\n        con.setAutoCommit(false);\r\n        try{\r\n            con.setTransactionIsolation( Connection.TRANSACTION_REPEATABLE_READ );\r\n            ResultSet rs = st.executeQuery(\"Select * From \" + table);\r\n            rs.next();\r\n            try {\r\n                st.execute(\"Alter Table \" + table + \" Add a Varchar(20)\");\r\n                fail(\"Alter Table should not work on a table with a lock.\");\r\n            } catch (SQLException ex) {\r\n                assertSQLException( \"01000\", 0, ex );\r\n            }\r\n            rs.next();\r\n        }finally{\r\n            con.setTransactionIsolation(isolation);\r\n            con.setAutoCommit(true);\r\n        }\r\n    }","startLine":11,"lastLine":14}],"window":4},{"content":"assertTrue( \"To few rows\", rs.next() );assertTrue( \"To few rows\", rs.next() );assertFalse( \"To many rows\", rs.next() );pr.close();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":87,"lastLine":90},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":75,"lastLine":78},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":66,"lastLine":69}],"window":4},{"content":"if(t<0){t += 86400000;d--;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/addDateTimeOffset(long,java.util.TimeZone)","rawLines":"final static long addDateTimeOffset(long datetime, TimeZone timezone){\r\n        int t = (int)(datetime % 86400000);\r\n        int d = (int)(datetime / 86400000);\r\n        if(t<0){\r\n            //Time before 1970 and not a full day\r\n            t += 86400000;\r\n            d--;\r\n        }              \r\n        int millis = t % 1000;\r\n        t /= 1000;\r\n        synchronized(cal){\r\n            cal.setTimeZone( timezone );\r\n            cal.set( 1970, 0, d+1, 0, 0, t );\r\n            cal.set( Calendar.MILLISECOND, millis );\r\n            return cal.getTimeInMillis();\r\n        }\r\n    }","startLine":3,"lastLine":7},{"locFile":"java+constructor:///smallsql/database/DateTime/Details/Details(long)","rawLines":"Details(long time){\r\n\t\t\tint t = (int)(time % 86400000);\r\n\t\t\tint d = (int)(time / 86400000);\r\n\t\t\tif(t<0){\r\n\t\t\t    //Time before 1970 and not a full day\r\n\t\t\t\tt += 86400000;\r\n\t\t\t\td--;\r\n\t\t\t}\t\t\t\t\r\n\t\t\tmillis = t % 1000;\r\n\t\t\tt /= 1000;\r\n\t\t\tsecond = t % 60;\r\n\t\t\tt /= 60;\r\n\t\t\tminute = t % 60;\r\n\t\t\tt /= 60;\r\n\t\t\thour = t % 24;\r\n\r\n\t\t\tyear = 1970 - (int)(t / 365.2425);\r\n\t\t\tboolean isLeap;\r\n\t\t\tdo{\r\n\t\t\t\tisLeap = false;\r\n\t\t\t\tdayofyear = day = d - ((year - 1970)*365 + (year/4) - (year/100) + (year/400) - 477);\r\n\t\t\t\tif(isLeapYear(year)){\r\n\t\t\t\t\t// is leap year\r\n\t\t\t\t\tif(day < 59){\r\n\t\t\t\t\t\tday++;\r\n\t\t\t\t\t\tisLeap = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdayofyear++;\r\n\t\t\t\t}\r\n\t\t\t\tif(day < 0){\r\n\t\t\t\t\tyear--;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}else\r\n\t\t\t\tif(day >= 365){\r\n\t\t\t\t\tyear++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}while(true);\r\n\t\t\t\r\n\t\t\tif(isLeap && day == 59){\r\n\t\t\t\t// 29. Feb\r\n\t\t\t\tmonth = 1;\r\n\t\t\t\tday   = 29;\r\n\t\t\t}else{\r\n\t\t\t\tfor(int m=11; m>=0; m--){\r\n\t\t\t\t\tif(MONTH_DAYS[m] <= day){\r\n\t\t\t\t\t\tmonth = m;\r\n\t\t\t\t\t\tday   = day - MONTH_DAYS[m] + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}","startLine":3,"lastLine":7}],"window":4},{"content":"final float getFloat() throws Exception {if(isNull()) return 0;return Float.parseFloat(getString().trim());}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnP1StringAndBinary/getFloat()","rawLines":"final float getFloat() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Float.parseFloat(getString().trim());\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReturnString/getFloat()","rawLines":"final float getFloat() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\treturn Float.parseFloat(getString().trim());\r\n\t}","startLine":0,"lastLine":3}],"window":4},{"content":"}}catch(Exception e){}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Database/getColumns(smallsql.database.SSConnection,java.lang.String,java.lang.String)","rawLines":"Object[][] getColumns( SSConnection con, String tablePattern, String colPattern) throws Exception{\r\n    \tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(tablePattern);\r\n    \tfor(int i=0; i<tables.size(); i++){\r\n    \t\tString tableName = tables.get(i);\r\n\t\t\ttry{\r\n\t    \t\tTableView tab = getTableView( con, tableName);\r\n\t    \t\tColumns cols = tab.columns;\r\n\t    \t\tfor(int c=0; c<cols.size(); c++){\r\n\t    \t\t\tColumn col = cols.get(c);\r\n\t\t\t\t\tObject[] row = new Object[18];\r\n\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t   \t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\t\r\n\t\t\t\t\trow[3] = col.getName();\t\t\t//COLUMN_NAME\t\r\n\t\t\t\t\trow[4] = Utils.getShort( SQLTokenizer.getSQLDataType( col.getDataType() )); //DATA_TYPE  \r\n\t\t\t\t\trow[5] = SQLTokenizer.getKeyWord( col.getDataType() );\t//TYPE_NAME\r\n\t\t\t\t\trow[6] = Utils.getInteger(col.getColumnSize());//COLUMN_SIZE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//BUFFER_LENGTH\r\n\t\t\t\t\trow[8] = Utils.getInteger(col.getScale());//DECIMAL_DIGITS\r\n\t\t\t\t\trow[9] = Utils.getInteger(10);\t\t//NUM_PREC_RADIX\r\n\t\t\t\t\trow[10]= Utils.getInteger(col.isNullable() ? DatabaseMetaData.columnNullable : DatabaseMetaData.columnNoNulls); //NULLABLE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//REMARKS\r\n\t\t\t\t\trow[12]= col.getDefaultDefinition(); //COLUMN_DEF\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//SQL_DATA_TYPE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//SQL_DATETIME_SUB\r\n\t\t\t\t\trow[15]= row[6];\t\t\t\t//CHAR_OCTET_LENGTH\r\n\t\t\t\t\trow[16]= Utils.getInteger(i); \t//ORDINAL_POSITION\t\t\r\n\t\t\t\t\trow[17]= col.isNullable() ? \"YES\" : \"NO\"; //IS_NULLABLE\t\t\t\t\t\r\n\t\t\t\t\trows.add(row);\r\n\t    \t\t}\r\n\t\t\t}catch(Exception e){\r\n\t\t\t\t//invalid Tables and View will not show \r\n\t\t\t}\r\n    \t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;\r\n    }","startLine":30,"lastLine":34},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getTables(java.lang.String,java.lang.String,java.lang.String,java.lang.String%5B%5D)","rawLines":"public ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types) throws SQLException {\r\n\t\tString[] colNames = {\"TABLE_CAT\",\"TABLE_SCHEM\",\"TABLE_NAME\",\"TABLE_TYPE\",\"REMARKS\",\"TYPE_CAT\",\"TYPE_SCHEM\",\"TYPE_NAME\",\"SELF_REFERENCING_COL_NAME\",\"REF_GENERATION\"};\r\n\t\tDatabase database;\r\n\t\tif(catalog == null){ \r\n\t\t\tdatabase = con.getDatabase(true);\r\n\t\t\tif(database != null)\r\n\t\t\t\tcatalog = database.getName();\r\n    \t}else{\r\n\t\t\tdatabase = Database.getDatabase(catalog, con, false);\r\n    \t}\r\n\t\tArrayList rows = new ArrayList();\r\n\t\tboolean isTypeTable = types == null;\r\n\t\tboolean isTypeView = types == null;\r\n\t\tfor(int i=0; types != null && i<types.length; i++){\r\n\t\t\tif(\"TABLE\".equalsIgnoreCase(types[i])) isTypeTable = true;\r\n\t\t\tif(\"VIEW\" .equalsIgnoreCase(types[i])) isTypeView  = true;\r\n\t\t}\r\n\t\t\r\n\t\tif(database != null){\r\n\t\t\tStrings tables = database.getTables(tableNamePattern);\r\n\t\t\tfor(int i=0; i<tables.size(); i++){\r\n\t\t\t\tString table = tables.get(i);\r\n\t\t\t\tObject[] row = new Object[10];\r\n\t\t\t\trow[0] = catalog;\r\n\t\t\t\trow[2] = table;\r\n\t\t\t\ttry{\r\n\t\t\t\t\tif(database.getTableView( con, table) instanceof View){\r\n\t\t\t\t\t\tif(isTypeView){\r\n\t\t\t\t\t\t\trow[3] = \"VIEW\";\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(isTypeTable){\r\n\t\t\t\t\t\t\trow[3] = \"TABLE\";\t\t\t\t\t\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t//TODO invalid VIEWS does not show because it can't load.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] data = new Object[rows.size()][];\r\n\t\trows.toArray(data);\r\n\t\tCommandSelect cmdSelect = Utils.createMemoryCommandSelect( con, colNames, data);\r\n\t\tExpressions order = new Expressions();\r\n\t\torder.add( new ExpressionName(\"TABLE_TYPE\") );\r\n\t\torder.add( new ExpressionName(\"TABLE_NAME\") );\r\n\t\tcmdSelect.setOrder( order );\r\n\t\treturn new SSResultSet( st, cmdSelect);\r\n    }","startLine":36,"lastLine":40}],"window":4},{"content":"formatNumber( details.month+1, 2, buf);buf.append('-');formatNumber( details.day, 2, buf);buf.append('-');","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":148,"lastLine":151},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":155,"lastLine":158}],"window":4},{"content":"fail(\"NO_GENERATED_KEYS\");}catch(SQLException ex){assertSQLException(\"01000\", 0, ex);}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":8,"lastLine":11},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":8,"lastLine":11}],"window":4},{"content":"factor = 1;}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/MutableNumeric/setScale(int)","rawLines":"void setScale(int newScale){\r\n\t\tif(newScale == scale) return;\r\n\t\tint factor = 1;\r\n\t\tif(newScale > scale){\r\n\t\t\tfor(;newScale>scale; scale++){\r\n\t\t\t\tfactor *=10;\r\n\t\t\t\tif(factor == 1000000000){\r\n\t\t\t\t\tmul(factor);\r\n\t\t\t\t\tfactor = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmul(factor);\r\n\t\t}else{\r\n\t\t\tfor(;newScale<scale; scale--){\r\n\t\t\t\tfactor *=10;\r\n\t\t\t\tif(factor == 1000000000){\r\n\t\t\t\t\tdivImpl(factor);\r\n\t\t\t\t\tfactor = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdivImpl(factor);\t\t\r\n\t\t}\r\n\t}","startLine":8,"lastLine":10},{"locFile":"java+method:///smallsql/database/MutableNumeric/setScale(int)","rawLines":"void setScale(int newScale){\r\n\t\tif(newScale == scale) return;\r\n\t\tint factor = 1;\r\n\t\tif(newScale > scale){\r\n\t\t\tfor(;newScale>scale; scale++){\r\n\t\t\t\tfactor *=10;\r\n\t\t\t\tif(factor == 1000000000){\r\n\t\t\t\t\tmul(factor);\r\n\t\t\t\t\tfactor = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmul(factor);\r\n\t\t}else{\r\n\t\t\tfor(;newScale<scale; scale--){\r\n\t\t\t\tfactor *=10;\r\n\t\t\t\tif(factor == 1000000000){\r\n\t\t\t\t\tdivImpl(factor);\r\n\t\t\t\t\tfactor = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdivImpl(factor);\t\t\r\n\t\t}\r\n\t}","startLine":17,"lastLine":19}],"window":3},{"content":"previousToken();return leftExpr;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/expression(smallsql.database.Command,int)","rawLines":"/**\r\n\t * Read a complex expression that can be build from multiple atomic expressions.\r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n\t * @param previousOperationLevel the level of the left operation.\r\n\t */\r\n    private Expression expression(Command cmd, int previousOperationLevel) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        Expression leftExpr;\r\n        switch(token.value){\r\n            case SQLTokenizer.NOT:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NOT      / 10), ExpressionArithmetic.NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.MINUS:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NEGATIVE / 10), ExpressionArithmetic.NEGATIVE);\r\n            \tbreak;\r\n            case SQLTokenizer.TILDE:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.BIT_NOT  / 10), ExpressionArithmetic.BIT_NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.PARENTHESIS_L:\r\n                leftExpr = expression( cmd, 0);\r\n                token = nextToken(MISSING_PARENTHESIS_R);\r\n                break;\r\n            default:\r\n                leftExpr = expressionSingle( cmd, token);\r\n        }\r\n        boolean isNot = false;\r\n        while((token = nextToken()) != null){\r\n            Expression rightExpr;\r\n            int operation = ExpressionArithmetic.getOperationFromToken(token.value);\r\n            int level = operation / 10;\r\n            if(previousOperationLevel >= level){\r\n                previousToken();\r\n                return leftExpr;\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PLUS:\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.ASTERISK:\r\n                case SQLTokenizer.SLACH:\r\n                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:\r\n                case SQLTokenizer.AND:\r\n                case SQLTokenizer.BIT_AND:\r\n                case SQLTokenizer.BIT_OR:\r\n                case SQLTokenizer.BIT_XOR:\r\n                    rightExpr = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, operation );\r\n                    break;\r\n                case SQLTokenizer.BETWEEN:\r\n                    rightExpr = expression( cmd, ExpressionArithmetic.AND );\r\n                    nextToken( MISSING_AND );\r\n                    Expression rightExpr2 = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, rightExpr2, operation );\r\n                    break;\r\n                case SQLTokenizer.IN:\r\n            \t\tnextToken(MISSING_PARENTHESIS_L);\r\n                \ttoken = nextToken(MISSING_EXPRESSION);\r\n                \tif(token.value == SQLTokenizer.SELECT){\r\n                \t\tCommandSelect cmdSel = select();\r\n\t\t\t\t\t\tleftExpr = new ExpressionInSelect( con, leftExpr, cmdSel, operation );\r\n\t\t\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n                \t}else{\r\n                \t\tpreviousToken();\r\n                \t\tExpressions list = expressionParenthesisList( cmd );\r\n                \t\tleftExpr = new ExpressionArithmetic( leftExpr, list, operation );\r\n                \t}\r\n                    break;\r\n                case SQLTokenizer.IS:\r\n                \ttoken = nextToken(MISSING_NOT_NULL);\r\n                \tif(token.value == SQLTokenizer.NOT){\r\n                \t\tnextToken(MISSING_NULL);\r\n\t\t\t\t\t\toperation++;\r\n                \t}\r\n                \tleftExpr = new ExpressionArithmetic( leftExpr, operation );\r\n                \tbreak;\r\n                case SQLTokenizer.NOT:\r\n                \ttoken = nextToken(MISSING_BETWEEN_IN);\r\n                \tpreviousToken();\r\n                \tisNot = true;\r\n                \tcontinue;\r\n                default:\r\n                        previousToken();\r\n                        return leftExpr;\r\n            }\r\n            if(isNot){\r\n            \tisNot = false;\r\n\t\t\t\tleftExpr =  new ExpressionArithmetic( leftExpr, ExpressionArithmetic.NOT);\r\n            }\r\n        }\r\n        previousToken();\r\n        return leftExpr;\r\n    }","startLine":88,"lastLine":90},{"locFile":"java+method:///smallsql/database/SQLParser/expression(smallsql.database.Command,int)","rawLines":"/**\r\n\t * Read a complex expression that can be build from multiple atomic expressions.\r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n\t * @param previousOperationLevel the level of the left operation.\r\n\t */\r\n    private Expression expression(Command cmd, int previousOperationLevel) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        Expression leftExpr;\r\n        switch(token.value){\r\n            case SQLTokenizer.NOT:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NOT      / 10), ExpressionArithmetic.NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.MINUS:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NEGATIVE / 10), ExpressionArithmetic.NEGATIVE);\r\n            \tbreak;\r\n            case SQLTokenizer.TILDE:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.BIT_NOT  / 10), ExpressionArithmetic.BIT_NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.PARENTHESIS_L:\r\n                leftExpr = expression( cmd, 0);\r\n                token = nextToken(MISSING_PARENTHESIS_R);\r\n                break;\r\n            default:\r\n                leftExpr = expressionSingle( cmd, token);\r\n        }\r\n        boolean isNot = false;\r\n        while((token = nextToken()) != null){\r\n            Expression rightExpr;\r\n            int operation = ExpressionArithmetic.getOperationFromToken(token.value);\r\n            int level = operation / 10;\r\n            if(previousOperationLevel >= level){\r\n                previousToken();\r\n                return leftExpr;\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PLUS:\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.ASTERISK:\r\n                case SQLTokenizer.SLACH:\r\n                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:\r\n                case SQLTokenizer.AND:\r\n                case SQLTokenizer.BIT_AND:\r\n                case SQLTokenizer.BIT_OR:\r\n                case SQLTokenizer.BIT_XOR:\r\n                    rightExpr = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, operation );\r\n                    break;\r\n                case SQLTokenizer.BETWEEN:\r\n                    rightExpr = expression( cmd, ExpressionArithmetic.AND );\r\n                    nextToken( MISSING_AND );\r\n                    Expression rightExpr2 = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, rightExpr2, operation );\r\n                    break;\r\n                case SQLTokenizer.IN:\r\n            \t\tnextToken(MISSING_PARENTHESIS_L);\r\n                \ttoken = nextToken(MISSING_EXPRESSION);\r\n                \tif(token.value == SQLTokenizer.SELECT){\r\n                \t\tCommandSelect cmdSel = select();\r\n\t\t\t\t\t\tleftExpr = new ExpressionInSelect( con, leftExpr, cmdSel, operation );\r\n\t\t\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n                \t}else{\r\n                \t\tpreviousToken();\r\n                \t\tExpressions list = expressionParenthesisList( cmd );\r\n                \t\tleftExpr = new ExpressionArithmetic( leftExpr, list, operation );\r\n                \t}\r\n                    break;\r\n                case SQLTokenizer.IS:\r\n                \ttoken = nextToken(MISSING_NOT_NULL);\r\n                \tif(token.value == SQLTokenizer.NOT){\r\n                \t\tnextToken(MISSING_NULL);\r\n\t\t\t\t\t\toperation++;\r\n                \t}\r\n                \tleftExpr = new ExpressionArithmetic( leftExpr, operation );\r\n                \tbreak;\r\n                case SQLTokenizer.NOT:\r\n                \ttoken = nextToken(MISSING_BETWEEN_IN);\r\n                \tpreviousToken();\r\n                \tisNot = true;\r\n                \tcontinue;\r\n                default:\r\n                        previousToken();\r\n                        return leftExpr;\r\n            }\r\n            if(isNot){\r\n            \tisNot = false;\r\n\t\t\t\tleftExpr =  new ExpressionArithmetic( leftExpr, ExpressionArithmetic.NOT);\r\n            }\r\n        }\r\n        previousToken();\r\n        return leftExpr;\r\n    }","startLine":31,"lastLine":33}],"window":3},{"content":"break;case SQLTokenizer.BINARY:case SQLTokenizer.VARBINARY:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/scanObjectOffsets(int%5B%5D,int%5B%5D)","rawLines":"@Override\r\n    void scanObjectOffsets( int[] offsets, int dataTypes[] ){\r\n        offset = PAGE_CONTROL_SIZE;\r\n        for(int i=0; i<offsets.length; i++){\r\n            offsets[i] = offset;\r\n            boolean isNull = readBoolean(); // for isNull\r\n            switch(dataTypes[i]){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                    int count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count;  // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    count = readByte();\r\n\t\t\t\t\toffset += 2;\r\n\t\t\t\t\tif(!isNull) offset += count*4;\r\n                    break;\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count << 1; // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                default: throw new Error(String.valueOf( dataTypes[i] ) );\r\n            }\r\n        }\r\n    }","startLine":36,"lastLine":38},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":70,"lastLine":72}],"window":3},{"content":"return 0;}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Join/createJoinScrollIndex(smallsql.database.ExpressionArithmetic,smallsql.database.Expressions,smallsql.database.Expressions,int)","rawLines":"private int createJoinScrollIndex(ExpressionArithmetic cond, Expressions leftEx, Expressions rightEx, int operation) throws Exception{\r\n        Expression[] params = cond.getParams();\r\n        int op = cond.getOperation();\r\n        if(op == ExpressionArithmetic.AND){\r\n            Expression param0 = params[0];\r\n            Expression param1 = params[1];\r\n            if(param0 instanceof ExpressionArithmetic && param1 instanceof ExpressionArithmetic){\r\n                op = createJoinScrollIndex((ExpressionArithmetic)param0, leftEx, rightEx, operation);\r\n                if(op == 0){\r\n                    return 0;\r\n                }\r\n                return createJoinScrollIndex((ExpressionArithmetic)param1, leftEx, rightEx, operation);\r\n            }\r\n            return 0;\r\n        }\r\n        if(operation == 0){\r\n            operation = op;\r\n        }\r\n        if(operation != op){\r\n            return 0;\r\n        }\r\n        if(operation == ExpressionArithmetic.EQUALS){\r\n            Expression param0 = params[0];\r\n            Expression param1 = params[1];\r\n            //scan all column that are include in the expression\r\n            Expressions columns0 = Utils.getExpressionNameFromTree(param0);\r\n            Expressions columns1 = Utils.getExpressionNameFromTree(param1);\r\n            if(left.isExpressionsFromThisRowSource(columns0) && right.isExpressionsFromThisRowSource(columns1)){\r\n                leftEx.add( param0 );\r\n                rightEx.add( param1 );\r\n            }else{\r\n                if(left.isExpressionsFromThisRowSource(columns1) && right.isExpressionsFromThisRowSource(columns0)){\r\n                    leftEx.add( param1 );\r\n                    rightEx.add( param0 );\r\n                }else{\r\n                    return 0;\r\n                }\r\n            }\r\n            \r\n            return operation;\r\n        }\r\n        return 0;\r\n    }","startLine":35,"lastLine":37},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getScale()","rawLines":"int getScale(){\r\n\t\tint dataType = getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\tswitch(operation){\r\n\t\t\t\t\tcase ADD:\r\n\t\t\t\t\tcase SUB:\r\n\t\t\t\t\t\treturn Math.max(left.getScale(), right.getScale());\r\n\t\t\t\t\tcase MUL:\r\n\t\t\t\t\t\treturn left.getScale() + right.getScale();\r\n\t\t\t\t\tcase DIV:\r\n\t\t\t\t\t\treturn Math.max(left.getScale()+5, right.getScale()+4);\r\n\t\t\t\t\tcase NEGATIVE:\r\n\t\t\t\t\t\treturn left.getScale();\r\n\t\t\t\t\tcase MOD:\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t}\r\n\t\treturn getScale(dataType);\r\n\t}","startLine":16,"lastLine":18}],"window":3},{"content":"previousToken();return fromSource;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/rowSource(smallsql.database.Command,smallsql.database.DataSources,int)","rawLines":"/**\r\n     * returns a row source. A row source is a Table, Join, View or a row function.\r\n     *\r\n     */\r\n    private RowSource rowSource(Command cmd, DataSources tables, int parenthesis) throws SQLException{\r\n        RowSource fromSource = null;\r\n        fromSource = tableSource(cmd, tables);\r\n\r\n        while(true){\r\n            SQLToken token = nextToken();\r\n            if(token == null) return fromSource;\r\n            switch(token.value){\r\n                case SQLTokenizer.ON:\r\n                    previousToken();\r\n                    return fromSource;\r\n                case SQLTokenizer.CROSS:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break\r\n                case SQLTokenizer.COMMA:\r\n                    fromSource = new Join( Join.CROSS_JOIN, fromSource, rowSource(cmd, tables, 0), null);\r\n                    break;\r\n                case SQLTokenizer.INNER:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break;\r\n                case SQLTokenizer.JOIN:\r\n                    fromSource = join( cmd, tables, fromSource, Join.INNER_JOIN );\r\n                    break;\r\n                case SQLTokenizer.LEFT:\r\n                    token = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n                    fromSource = join( cmd, tables, fromSource, Join.LEFT_JOIN );\r\n                    break;\r\n                case SQLTokenizer.RIGHT:\r\n                \ttoken = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.RIGHT_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n\t\t\t\tcase SQLTokenizer.FULL:\r\n\t\t\t\t\ttoken = nextToken(MISSING_OUTER_JOIN);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.OUTER)\r\n\t\t\t\t\t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.FULL_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.ESCAPE_R:\r\n                    if(parenthesis == token.value) return fromSource;\r\n                    if(parenthesis == 0){\r\n                    \tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                    }\r\n                    throw createSyntaxError( token, Language.STXADD_FROM_PAR_CLOSE );\r\n                default:\r\n                \tif(isKeyword(token)){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                \t}\r\n                    if(!fromSource.hasAlias()){\r\n                        fromSource.setAlias( token.getName( sql ) );\r\n                        break;\r\n                    }\r\n                    throw createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.GROUP, SQLTokenizer.ORDER, SQLTokenizer.HAVING} );\r\n            }\r\n        }\r\n    }","startLine":49,"lastLine":51},{"locFile":"java+method:///smallsql/database/SQLParser/rowSource(smallsql.database.Command,smallsql.database.DataSources,int)","rawLines":"/**\r\n     * returns a row source. A row source is a Table, Join, View or a row function.\r\n     *\r\n     */\r\n    private RowSource rowSource(Command cmd, DataSources tables, int parenthesis) throws SQLException{\r\n        RowSource fromSource = null;\r\n        fromSource = tableSource(cmd, tables);\r\n\r\n        while(true){\r\n            SQLToken token = nextToken();\r\n            if(token == null) return fromSource;\r\n            switch(token.value){\r\n                case SQLTokenizer.ON:\r\n                    previousToken();\r\n                    return fromSource;\r\n                case SQLTokenizer.CROSS:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break\r\n                case SQLTokenizer.COMMA:\r\n                    fromSource = new Join( Join.CROSS_JOIN, fromSource, rowSource(cmd, tables, 0), null);\r\n                    break;\r\n                case SQLTokenizer.INNER:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break;\r\n                case SQLTokenizer.JOIN:\r\n                    fromSource = join( cmd, tables, fromSource, Join.INNER_JOIN );\r\n                    break;\r\n                case SQLTokenizer.LEFT:\r\n                    token = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n                    fromSource = join( cmd, tables, fromSource, Join.LEFT_JOIN );\r\n                    break;\r\n                case SQLTokenizer.RIGHT:\r\n                \ttoken = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.RIGHT_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n\t\t\t\tcase SQLTokenizer.FULL:\r\n\t\t\t\t\ttoken = nextToken(MISSING_OUTER_JOIN);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.OUTER)\r\n\t\t\t\t\t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.FULL_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.ESCAPE_R:\r\n                    if(parenthesis == token.value) return fromSource;\r\n                    if(parenthesis == 0){\r\n                    \tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                    }\r\n                    throw createSyntaxError( token, Language.STXADD_FROM_PAR_CLOSE );\r\n                default:\r\n                \tif(isKeyword(token)){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                \t}\r\n                    if(!fromSource.hasAlias()){\r\n                        fromSource.setAlias( token.getName( sql ) );\r\n                        break;\r\n                    }\r\n                    throw createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.GROUP, SQLTokenizer.ORDER, SQLTokenizer.HAVING} );\r\n            }\r\n        }\r\n    }","startLine":55,"lastLine":57}],"window":3},{"content":"break;default:previousToken();","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/singleSelect()","rawLines":"/**\r\n     * A single SELECT of a UNION or only a simple single SELECT.\r\n     * @return\r\n     * @throws SQLException\r\n     */\r\n    private CommandSelect singleSelect() throws SQLException{\r\n        CommandSelect selCmd = new CommandSelect(con.log);\r\n\t\tSQLToken token;\r\n        // scan for prefix like DISTINCT, ALL and the TOP clause; sample: SELECT TOP 15 ...\r\nSwitch: while(true){\r\n\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.TOP:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tint maxRows = Integer.parseInt(token.getName(sql));\r\n\t\t\t\t\t\tselCmd.setMaxRows(maxRows);\r\n\t\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ALL:\r\n\t\t\t\t\tselCmd.setDistinct(false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.DISTINCT:\r\n\t\t\t\t\tselCmd.setDistinct(true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\tbreak Switch;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        while(true){\r\n            Expression column = expression(selCmd, 0);\r\n            selCmd.addColumnExpression( column );\r\n\r\n            token = nextToken();\r\n            if(token == null) return selCmd; // SELECT without FROM\r\n\r\n            boolean as = false;\r\n            if(token.value == SQLTokenizer.AS){\r\n                token = nextToken(MISSING_EXPRESSION);\r\n                as = true;\r\n            }\r\n\r\n            if(as || (!isKeyword(token))){\r\n            \tString alias = getIdentifier( token);\r\n                column.setAlias( alias );\r\n                token = nextToken();\r\n                if(token == null) return selCmd; // SELECT without FROM\r\n            }\r\n\r\n            switch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        break;\r\n                case SQLTokenizer.FROM:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        from(selCmd);\r\n                        return selCmd;\r\n\r\n                default:\r\n                        if(!isKeyword(token))\r\n                \t\t\tthrow createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.FROM} );\r\n                        previousToken();\r\n                        return selCmd;\r\n            }\r\n        }\r\n    }","startLine":26,"lastLine":28},{"locFile":"java+method:///smallsql/database/SQLParser/from(smallsql.database.CommandSelect)","rawLines":"private void from(CommandSelect cmd) throws SQLException{\r\n\t\tDataSources tables = new DataSources();\r\n        cmd.setTables(tables);\r\n        cmd.setSource( rowSource( cmd, tables, 0 ) );\r\n\r\n\t\tSQLToken token;\r\n        while(null != (token = nextToken())){\r\n            switch(token.value){\r\n                case SQLTokenizer.WHERE:\r\n                    where( cmd );\r\n                    break;\r\n                case SQLTokenizer.GROUP:\r\n                    group( cmd );\r\n                    break;\r\n                case SQLTokenizer.HAVING:\r\n                    having( cmd );\r\n                    break;\r\n                default:\r\n                \tpreviousToken();\r\n                    return;\r\n            }\r\n        }\r\n    }","startLine":16,"lastLine":18},{"locFile":"java+method:///smallsql/database/SQLParser/index(smallsql.database.Command,int,java.lang.String,java.lang.String,java.lang.String)","rawLines":"/**\r\n\t * Parse construct like:<br>\r\n\t * <li>PRIMARY KEY (col1)\r\n\t * <li>UNIQUE (col1, col2)\r\n\t * <li>FOREIGN KEY REFERENCES ref_table(col1)\r\n\t * @param cmd\r\n\t * @param constraintType one of SQLTokenizer.PRIMARY, SQLTokenizer.UNIQUE or SQLTokenizer.FOREIGN.\r\n\t * @param if it a constrain of the current column else null\r\n\t * @return a new IndexDescription\r\n\t */\r\n\tprivate IndexDescription index(Command cmd, int constraintType, String tableName, String contrainName, String columnName) throws SQLException{\r\n\t\tif(constraintType != SQLTokenizer.UNIQUE) nextToken( MISSING_KEY );\r\n\t\tSQLToken token = nextToken();\r\n        if(token != null){\r\n    \t\tswitch(token.value){\r\n    \t\t\tcase SQLTokenizer.CLUSTERED:\r\n    \t\t\tcase SQLTokenizer.NONCLUSTERED:\r\n    \t\t\t\t// ignoring, this tokens form MS SQL Server are ignored\r\n    \t\t\t\tbreak;\r\n                default:\r\n                    previousToken();\r\n    \t\t}\r\n        }else{\r\n            previousToken();\r\n        }\r\n\t\tStrings columns = new Strings();\r\n\t\tExpressions expressions = new Expressions();\r\n\t\tif(columnName != null){\r\n\t\t\t//Constraint for a single column together with the column definition\r\n\t\t\tcolumns.add(columnName);\r\n\t\t\texpressions.add(new ExpressionName(columnName));\r\n\t\t}else{\r\n\t\t\t//Constraint as addition definition\r\n            expressionDefList( cmd, expressions, columns );\r\n\t\t}\r\n\t\treturn new IndexDescription( contrainName, tableName, constraintType, expressions, columns);\r\n\t}","startLine":18,"lastLine":20}],"window":3},{"content":"System.out.print('\\t');}System.out.println();","cloneLocs":[{"locFile":"java+method:///smallsql/tools/CommandLine/printRS(java.sql.ResultSet)","rawLines":"private static void printRS(ResultSet rs) throws SQLException {\r\n        ResultSetMetaData md = rs.getMetaData();\r\n        int count = md.getColumnCount();\r\n        for(int i=1; i<=count; i++){\r\n            System.out.print(md.getColumnLabel(i));\r\n            System.out.print('\\t');\r\n        }\r\n        System.out.println();\r\n        while(rs.next()){\r\n            for(int i=1; i<=count; i++){\r\n                System.out.print(rs.getObject(i));\r\n                System.out.print('\\t');\r\n            }\r\n            System.out.println();\r\n        }\r\n    }","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/tools/CommandLine/printRS(java.sql.ResultSet)","rawLines":"private static void printRS(ResultSet rs) throws SQLException {\r\n        ResultSetMetaData md = rs.getMetaData();\r\n        int count = md.getColumnCount();\r\n        for(int i=1; i<=count; i++){\r\n            System.out.print(md.getColumnLabel(i));\r\n            System.out.print('\\t');\r\n        }\r\n        System.out.println();\r\n        while(rs.next()){\r\n            for(int i=1; i<=count; i++){\r\n                System.out.print(rs.getObject(i));\r\n                System.out.print('\\t');\r\n            }\r\n            System.out.println();\r\n        }\r\n    }","startLine":11,"lastLine":13}],"window":3},{"content":"break;case SQLTokenizer.FLOAT:case SQLTokenizer.DOUBLE:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/initValue(smallsql.database.Expression)","rawLines":"/**\r\n     * Init a summary field with a Mutable \r\n     * @param expr the expression that produce the values which should be summary\r\n     * @throws Exception\r\n     */\r\n\tprivate void initValue(Expression expr) throws Exception{\r\n\t\tdataType = expr.getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tvalue = new MutableInteger(expr.getInt());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tvalue = new MutableLong(expr.getLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\tvalue = new MutableFloat(expr.getFloat());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tvalue = new MutableDouble(expr.getDouble());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tvalue = Money.createFromUnscaledValue(expr.getMoney());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tvalue = new MutableNumeric(expr.getNumeric());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\tvalue = new DateTime(expr.getLong(), dataType);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\t// is used for MAX and MIN\r\n\t\t\t\tvalue = expr.getObject();\r\n\t\t}\r\n\t}","startLine":18,"lastLine":20},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":70,"lastLine":72},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":35,"lastLine":37},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":89,"lastLine":91},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":127,"lastLine":129}],"window":3},{"content":"}else{int idx = internalExpressions.indexOf(expr);if(idx >= 0) return idx;","cloneLocs":[{"locFile":"java+method:///smallsql/database/GroupResult/addInternalExpressionFromSelect(smallsql.database.Expression)","rawLines":"/**\r\n\t * Add a expression to the internal expression list if not exist in this list.\r\n\t * It will be added aggregate functions from the SELECT, HAVING and ORDER BY clause.\r\n\t * @param expr The expression to added.\r\n\t * @return the position in the internal list\r\n\t */\r\n\tfinal private int addInternalExpressionFromSelect(Expression expr) throws SQLException{\r\n\t\tint type = expr.getType();\r\n\t\tif(type == Expression.NAME){\r\n\t\t\tint idx = internalExpressions.indexOf(expr);\r\n\t\t\tif(idx >= 0) return idx;\r\n\t\t\tthrow SmallSQLException.create(Language.GROUP_AGGR_NOTPART, expr);\r\n\t\t}else\r\n\t\tif(type >= Expression.GROUP_BEGIN){\r\n\t\t\tint idx = internalExpressions.indexOf(expr);\r\n\t\t\tif(idx >= 0) return idx;\r\n\t\t\tinternalExpressions.add(expr);\r\n\t\t\treturn internalExpressions.size()-1;\r\n\t\t}else{\r\n\t\t\t//if a function or arithmetic expression is already in the group by the it is OK\r\n\t\t\tint idx = internalExpressions.indexOf(expr);\r\n\t\t\tif(idx >= 0) return idx;\r\n\t\t\tExpression[] params = expr.getParams();\r\n\t\t\tif(params != null){\r\n\t\t\t\tfor(int p=0; p<params.length; p++){\r\n\t\t\t\t\taddInternalExpressionFromSelect( params[p]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}","startLine":18,"lastLine":21},{"locFile":"java+method:///smallsql/database/GroupResult/addInternalExpressionFromGroupBy(smallsql.database.Expression)","rawLines":"/**\r\n\t * Add a expression to the internal expression list if not exist in this list.\r\n\t * It will be added named columns in the GROUP BY clause.\r\n\t * @param expr The expression to added.\r\n\t * @return the position in the internal list\r\n\t */\r\n\tfinal private int addInternalExpressionFromGroupBy(Expression expr) throws SQLException{\r\n\t\tint type = expr.getType();\r\n\t\tif(type >= Expression.GROUP_BEGIN){\r\n\t\t\t\tthrow SmallSQLException.create(Language.GROUP_AGGR_INVALID, expr);\r\n\t\t}else{\r\n\t\t\tint idx = internalExpressions.indexOf(expr);\r\n\t\t\tif(idx >= 0) return idx;\r\n\t\t\tinternalExpressions.add(expr);\r\n\t\t\treturn internalExpressions.size()-1;\r\n\t\t}\r\n\t}","startLine":10,"lastLine":12}],"window":3},{"content":"Connection con = AllTests.getConnection();Statement st = con.createStatement();try{","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestExceptionMethods/testDuplicatedColumnCreate()","rawLines":"public void testDuplicatedColumnCreate() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"Create Table DuplicatedColumn(col INT, Col INT)\");\r\n            fail(\"SQLException 'Duplicated Column' should be throw\");\r\n        }catch(SQLException e){\r\n            assertSQLException(\"01000\", 0, e);\r\n        }\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/junit/TestGroupBy/testViewWidthGroupBy()","rawLines":"/**\r\n\t * A problem can be the metadata from a View.\r\n\t * @throws Exception\r\n\t */\r\n\tpublic void testViewWidthGroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\ttry{\r\n\t\t\tResultSet rs;\r\n\t\t\tst.execute(\"Create View qry\" + table1 + \" as Select name, name as name2, count(*) as count FROM \" + table1 + \" Group By name\");\r\n\t\t\trs = st.executeQuery(\"Select * from qry\" + table1);\r\n\t\t\tassertEquals( \"name\",  rs.getMetaData().getColumnLabel(1) );\r\n\t\t\tassertEquals( \"name2\", rs.getMetaData().getColumnLabel(2) );\r\n\t\t\tassertEquals( \"count\", rs.getMetaData().getColumnLabel(3) );\r\n\t\t}finally{\r\n\t\t\tst.execute(\"Drop View qry\" + table1);\r\n\t\t}\r\n\t}","startLine":6,"lastLine":8},{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentConnectionWrite()","rawLines":"/**\r\n     * Create a table with a single row. In different connections a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentConnectionWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Connection con2 = AllTests.createConnection();\r\n                            Statement st2 = con2.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                            con2.close();\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }","startLine":9,"lastLine":11}],"window":3},{"content":"long time = -System.currentTimeMillis();for (int i=0; i<rowCount; i++){rs.moveToInsertRow();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertEmptyRows(java.sql.Connection)","rawLines":"/**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":11,"lastLine":13},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertRows(java.sql.Connection)","rawLines":"/**\r\n      *  5. Test\r\n      *  Insert rows with the method insertRow().\r\n      */  \r\n    static void test_InsertRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n\t            rs.updateBytes (  \"bi\", byteArray );\r\n\t            rs.updateString(  \"c\" , \"Test\" );\r\n\t            rs.updateDate  (  \"d\" , new Date( System.currentTimeMillis() ) );\r\n\t            rs.updateFloat (  \"de\", (float)1234.56789 );\r\n\t            rs.updateFloat (  \"f\" , (float)9876.54321 );\r\n\t            rs.updateBytes (  \"im\", largeByteArray );\r\n\t            rs.updateInt   (  \"i\" , i );\r\n\t            rs.updateDouble(  \"m\" , 23.45 );\r\n\t            rs.updateDouble(  \"n\" , 567.45 );\r\n\t            rs.updateFloat (  \"r\" , (float)78.89 );\r\n\t            rs.updateTime  (  \"sd\", new Time( System.currentTimeMillis() ) );\r\n\t            rs.updateShort (  \"si\", (short)i );\r\n\t            rs.updateFloat (  \"sm\", (float)34.56 );\r\n\t            rs.updateString(  \"sy\", \"sysname (30) NULL\" );\r\n\t            rs.updateString(  \"t\" , \"ntext NULL, sample to save in the field\" );\r\n\t            rs.updateByte  (  \"ti\", (byte)i );\r\n\t            rs.updateBytes (  \"vb\", byteArray );\r\n\t            rs.updateString(  \"vc\", \"nvarchar (255) NULL\" );\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                  st.execute(\"DELETE FROM \" + tableName);\r\n                  System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            }else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n        \te.printStackTrace();\r\n            try{\r\n                // reset for the next test\r\n                Statement st = con.createStatement();\r\n                st.execute(\"DELETE FROM \" + tableName);\r\n                st.close();\r\n            }catch(Exception ee){/* ignore it */}\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":11,"lastLine":13}],"window":3},{"content":"}else{rowSource.beforeFirst();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SortedResult/afterLast()","rawLines":"void afterLast() throws Exception{\r\n        useSetRowPosition = false;\r\n        if(sortedRowCount > 0){\r\n            scrollStatus.afterLast();\r\n            scrollStatus.getRowOffset(false); //previous position\r\n        }else{\r\n            rowSource.beforeFirst();\r\n        }\r\n        row = sortedRowCount;\r\n        while(next()){\r\n            // scroll to the end if there inserted rows\r\n        }\r\n\t}","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/database/SortedResult/next()","rawLines":"boolean next() throws Exception {\r\n\t\tif(useSetRowPosition) throw SmallSQLException.create(Language.ORDERBY_INTERNAL);\r\n        if(currentInsertedRow() < 0){\r\n    \t\tlong rowPosition = scrollStatus.getRowOffset(true);\r\n    \t\tif(rowPosition >= 0){\r\n                row++;\r\n    \t\t\trowSource.setRowPosition( rowPosition );\r\n    \t\t\treturn true;\r\n    \t\t}\r\n        }\r\n        if(currentInsertedRow() < insertedRows.size()-1){\r\n            row++;\r\n            rowSource.setRowPosition( insertedRows.get( currentInsertedRow() ) );\r\n            return true;\r\n        }\r\n        if(lastRowOffset >= 0){\r\n            rowSource.setRowPosition( lastRowOffset );\r\n        }else{\r\n            rowSource.beforeFirst();\r\n        }\r\n        if(rowSource.next()){\r\n            row++;\r\n            lastRowOffset = rowSource.getRowPosition();\r\n            insertedRows.add( lastRowOffset );\r\n            return true;\r\n        }\r\n        rowSource.noRow();\r\n        row = (getRowCount() > 0) ? getRowCount() + 1 : 0;\r\n\t\treturn false;\r\n\t}","startLine":17,"lastLine":19}],"window":3},{"content":"if( database.isReadOnly() ){throw SmallSQLException.create(Language.DB_READONLY);}","cloneLocs":[{"locFile":"java+method:///smallsql/database/TableView/createFile(smallsql.database.SSConnection,smallsql.database.Database)","rawLines":"/**\r\n\t * Create an empty table or view file that only include the signature.\r\n\t * @param database The database that the table or view should include.\r\n\t * @return A file handle\r\n\t * @throws Exception if any error occur like\r\n\t * <li>file exist already\r\n\t * <li>SecurityException\r\n\t */\r\n\tFileChannel createFile(SSConnection con, Database database) throws Exception{\r\n\t    if( database.isReadOnly() ){\r\n\t        throw SmallSQLException.create(Language.DB_READONLY);\r\n\t    }\r\n\t\tFile file = getFile( database );\r\n\t\tboolean ok = file.createNewFile();\r\n\t\tif(!ok) throw SmallSQLException.create(Language.TABLE_EXISTENT, name);\r\n\t\tFileChannel raFile = Utils.openRaFile( file, database.isReadOnly() );\r\n\t\tcon.add(new CreateFile(file, raFile, con, database));\r\n\t\twriteMagic(raFile);\r\n\t\treturn raFile;\r\n\t}","startLine":9,"lastLine":11},{"locFile":"java+method:///smallsql/database/IndexDescription/createFile(smallsql.database.SSConnection,smallsql.database.Database)","rawLines":"private FileChannel createFile(SSConnection con, Database database) throws Exception{\r\n\t    if( database.isReadOnly() ){\r\n\t        throw SmallSQLException.create(Language.DB_READONLY);\r\n\t    }\r\n\t\tFile file = getFile( database, name );\r\n\t\tboolean ok = file.createNewFile();\r\n\t\tif(!ok) throw SmallSQLException.create(Language.INDEX_EXISTS, name);\r\n\t\tFileChannel randomFile = Utils.openRaFile( file, database.isReadOnly() );\r\n        con.add(new CreateFile(file, randomFile, con, database));\r\n\t\twriteMagic(randomFile);\r\n\t\treturn randomFile;\r\n\t}","startLine":1,"lastLine":3}],"window":3},{"content":"offset = previousOffset;return;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/LongTreeList/setPreviousOffset(smallsql.database.LongTreeListEnum)","rawLines":"/**\r\n\t * Is used from getPrevious(). It set the offset of the previous entry.\r\n\t * If there is no previous entry in this node then set it to -1.\r\n\t * The problem is that \"enum\" point to the next position to optimize getNext().\r\n\t * We need 2 steps forward to find the previous entry. It can occur that\r\n\t * we are in another node. We need to verify it with the start point of the current node.\r\n\t */\r\n\tfinal private void setPreviousOffset(LongTreeListEnum listEnum){\r\n\t\tint previousOffset = listEnum.offsetStack[listEnum.stack] - 2*(2 + (listEnum.stack>=3 ? 0 : pointerSize));\r\n\t\tif(listEnum.stack == 0){\r\n\t\t\toffset = previousOffset;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\toffset = listEnum.offsetStack[listEnum.stack-1] - pointerSize;\r\n\t\tint pointer = getPointer();\r\n\t\tif(pointer <= previousOffset){\r\n\t\t\toffset = previousOffset;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\toffset = -1;\r\n\t}","startLine":16,"lastLine":18},{"locFile":"java+method:///smallsql/database/LongTreeList/setPreviousOffset(smallsql.database.LongTreeListEnum)","rawLines":"/**\r\n\t * Is used from getPrevious(). It set the offset of the previous entry.\r\n\t * If there is no previous entry in this node then set it to -1.\r\n\t * The problem is that \"enum\" point to the next position to optimize getNext().\r\n\t * We need 2 steps forward to find the previous entry. It can occur that\r\n\t * we are in another node. We need to verify it with the start point of the current node.\r\n\t */\r\n\tfinal private void setPreviousOffset(LongTreeListEnum listEnum){\r\n\t\tint previousOffset = listEnum.offsetStack[listEnum.stack] - 2*(2 + (listEnum.stack>=3 ? 0 : pointerSize));\r\n\t\tif(listEnum.stack == 0){\r\n\t\t\toffset = previousOffset;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\toffset = listEnum.offsetStack[listEnum.stack-1] - pointerSize;\r\n\t\tint pointer = getPointer();\r\n\t\tif(pointer <= previousOffset){\r\n\t\t\toffset = previousOffset;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\toffset = -1;\r\n\t}","startLine":10,"lastLine":12}],"window":3},{"content":"break;case SQLTokenizer.CHAR:case SQLTokenizer.NCHAR:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/scanObjectOffsets(int%5B%5D,int%5B%5D)","rawLines":"@Override\r\n    void scanObjectOffsets( int[] offsets, int dataTypes[] ){\r\n        offset = PAGE_CONTROL_SIZE;\r\n        for(int i=0; i<offsets.length; i++){\r\n            offsets[i] = offset;\r\n            boolean isNull = readBoolean(); // for isNull\r\n            switch(dataTypes[i]){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                    int count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count;  // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    count = readByte();\r\n\t\t\t\t\toffset += 2;\r\n\t\t\t\t\tif(!isNull) offset += count*4;\r\n                    break;\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count << 1; // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                default: throw new Error(String.valueOf( dataTypes[i] ) );\r\n            }\r\n        }\r\n    }","startLine":47,"lastLine":49},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":105,"lastLine":107}],"window":3},{"content":"assertTrue( rs.next() );oldValue = rs.getBoolean(\"b\");assertFalse(oldValue);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_boolean()","rawLines":"public void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":14,"lastLine":16},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_boolean()","rawLines":"public void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":9,"lastLine":12}],"window":3},{"content":"case SQLTokenizer.LONGVARCHAR:case SQLTokenizer.LONGNVARCHAR:case SQLTokenizer.LONGVARBINARY:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/getDataTypePrecision(int,int)","rawLines":"static int getDataTypePrecision(int dataType, int defaultValue){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.NULL:\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 1;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 5;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn 7;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 15;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\tif(defaultValue == -1)\r\n\t\t\t\t\treturn 0xFFFF;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                if(defaultValue == -1)\r\n                    return 38;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\treturn 23;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\treturn 8;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn 16;\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\treturn 36;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn Integer.MAX_VALUE;\r\n\t\t}\r\n\t\tif(defaultValue == -1)\r\n\t\t\tthrow new Error(\"Precision:\"+SQLTokenizer.getKeyWord(dataType));\r\n\t\treturn defaultValue;\r\n\t}","startLine":46,"lastLine":48},{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/getDisplaySize(int,int,int)","rawLines":"static int getDisplaySize(int dataType, int precision, int scale){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn 1; // 1 and 0\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 5; //true and false\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 6;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n            case SQLTokenizer.REAL:\r\n                return 13;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 17;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.BLOB:\r\n            case SQLTokenizer.CLOB:\r\n            case SQLTokenizer.NCLOB:\r\n\t\t\t\treturn Integer.MAX_VALUE;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\treturn precision + (scale>0 ? 2 : 1);\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\treturn 2 + precision*2;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                return 21;\r\n\t\t\tdefault:\r\n\t\t\t\treturn precision;\r\n\t\t}\r\n\t}","startLine":20,"lastLine":22}],"window":3},{"content":"node = node.getChildNode(digit);if(node == null) return null;if(nodeList != null) nodeList.add(node);","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/find(smallsql.database.IndexNode,char%5B%5D,java.util.ArrayList)","rawLines":"final private IndexNode find(IndexNode node, char[] key, ArrayList nodeList){\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tnode = node.getChildNode(digit);\r\n\r\n\t\t\tif(node == null) return null;\r\n\t\t\tif(nodeList != null) nodeList.add(node);\r\n\t\t\tif(++i == length){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":7,"lastLine":10},{"locFile":"java+method:///smallsql/database/Index/find(smallsql.database.IndexNode,long,int,java.util.ArrayList)","rawLines":"final private IndexNode find(IndexNode node, long key, int digitCount, ArrayList nodeList){\r\n\t\tfor(int i=digitCount-1; i>=0; i--){\r\n\t\t\tchar digit = (char)(key >> (i<<4));\r\n\t\t\tnode = node.getChildNode(digit);\r\n\t\t\t\r\n\t\t\tif(node == null) return null;\r\n\t\t\tif(nodeList != null) nodeList.add(node);\r\n\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn node;\r\n\t}","startLine":3,"lastLine":6}],"window":3},{"content":"rs.getObject(i);}}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestExceptions/runTest()","rawLines":"public void runTest() throws Exception{\r\n    \tinit();\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n        try{\r\n            rs = st.executeQuery( testValue.sql );\r\n        }catch(SQLException sqle){\r\n            assertTrue( \"There should no syntax error:\"+sqle, SYNTAX == testValue.errorType);\r\n            assertSQLException( testValue.sqlstate, testValue.errorCode, sqle );\r\n        }\r\n        if(testValue.errorType == SYNTAX){\r\n            assertNull(\"There should be a syntax error\", rs);\r\n            return;\r\n        }\r\n        try{\r\n            while(rs.next()){\r\n                for(int i=1; i<=rs.getMetaData().getColumnCount(); i++){\r\n                    rs.getObject(i);\r\n                }\r\n            }\r\n            fail(\"There should be a runtime error\");\r\n        }catch(SQLException sqle){\r\n            assertSQLException( testValue.sqlstate, testValue.errorCode, sqle );\r\n        }\r\n    }","startLine":18,"lastLine":20},{"locFile":"java+method:///smallsql/junit/BasicTestCase/assertRowCount(int,java.sql.ResultSet)","rawLines":"void assertRowCount(int sollCount, ResultSet rs ) throws Exception{\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tint count = 0;\r\n\t\t//System.out.println(sql);\r\n\t\twhile(rs.next()){\r\n\t\t\tcount++;\r\n\t\t\tfor(int i=1; i<=colCount; i++){\r\n\t\t\t\trs.getObject(i);\r\n\t\t\t\t//System.out.print( \" \"+rs.getObject(i));\r\n\t\t\t}\r\n\t\t\t//System.out.println();\r\n\t\t}\r\n\t\tassertEquals( \"Wrong row count\", sollCount, count);\r\n\t\tfor(int i=1; i<=colCount; i++){\r\n\t\t\ttry{\r\n\t\t\t\t// if not a SQLException occur then it is an error\r\n\t\t\t\tfail( \"Column:\"+i+\" Value:\"+String.valueOf(rs.getObject(i)));\r\n\t\t\t}catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\t\t}\r\n\t\tassertFalse( \"Scroll after last\", rs.next() );\r\n\t}","startLine":7,"lastLine":11}],"window":3},{"content":"buf.append(' ');formatNumber( details.year % 100, 2, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":96,"lastLine":98},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":111,"lastLine":113}],"window":3},{"content":"continue;}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/CommandSelect/insertRow(smallsql.database.SSConnection,smallsql.database.Expression%5B%5D)","rawLines":"final void insertRow(SSConnection con, Expression[] newRowSources) throws SQLException{\r\n\t\tif(tables.size() > 1)\r\n\t\t\tthrow SmallSQLException.create(Language.JOIN_INSERT);\r\n\t\tif(tables.size() == 0)\r\n\t\t\tthrow SmallSQLException.create(Language.INSERT_WO_FROM);\r\n\t\t\r\n\t\tint savepoint = con.getSavepoint();\r\n\t\ttry{\r\n\t\t\tTableViewResult result = TableViewResult.getTableViewResult( tables.get(0) );\r\n\t\t\tTableView table = result.getTableView();\r\n\t\t\tColumns tabColumns = table.columns;\r\n\t\t\tint count = tabColumns.size();\r\n\t\t\t\t\t\r\n\t\t\t// order the new Values after it position in the table\r\n\t\t\tExpression[] updateValues = new Expression[count];\r\n\t\t\tif(newRowSources != null){\r\n\t\t\t\tfor(int i=0; i<columnExpressions.size(); i++){\r\n\t\t\t\t\tExpression src = newRowSources[i];\r\n\t\t\t\t\tif(src != null && (!(src instanceof ExpressionValue) || !((ExpressionValue)src).isEmpty())){\t\r\n\t\t\t\t\t\tExpression rsColumn = columnExpressions.get(i); // Column of the ResultSet\r\n\t\t\t\t\t\tif(!rsColumn.isDefinitelyWritable())\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.COL_READONLY, new Integer(i));\r\n\t\t\t\t\t\tExpressionName exp = (ExpressionName)rsColumn;\r\n\t\t\t\t\t\tif(table == exp.getTable()){\r\n\t\t\t\t\t\t\tupdateValues[exp.getColumnIndex()] = src;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdateValues[i] = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t// save the new values if there are new value for this table\r\n\t\t\tresult.insertRow(updateValues);\r\n\t\t}catch(Throwable e){\r\n\t\t\tcon.rollback(savepoint);\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}finally{\r\n\t\t\tif(con.getAutoCommit()) con.commit();\r\n\t\t}\r\n\t}","startLine":25,"lastLine":27},{"locFile":"java+method:///smallsql/database/CommandSelect/updateRow(smallsql.database.SSConnection,smallsql.database.Expression%5B%5D)","rawLines":"final void updateRow(SSConnection con, Expression[] newRowSources) throws SQLException{\r\n\t\tint savepoint = con.getSavepoint();\r\n\t\ttry{\r\n\t\t\t//loop through all tables of this ResultSet \r\n\t\t\tfor(int t=0; t<tables.size(); t++){\r\n\t\t\t\tTableViewResult result = TableViewResult.getTableViewResult( tables.get(t) );\r\n\t\t\t\tTableView table = result.getTableView();\r\n\t\t\t\tColumns tableColumns = table.columns;\r\n\t\t\t\tint count = tableColumns.size();\r\n\t\t\t\t\r\n\t\t\t\t// order the new Values after it position in the table\r\n\t\t\t\tExpression[] updateValues = new Expression[count];\r\n\t\t\t\tboolean isUpdateNeeded = false;\r\n\t\t\t\tfor(int i=0; i<columnExpressions.size(); i++){\r\n\t\t\t\t\tExpression src = newRowSources[i];\r\n\t\t\t\t\tif(src != null && (!(src instanceof ExpressionValue) || !((ExpressionValue)src).isEmpty())){\t\r\n\t\t\t\t\t\tExpression col = columnExpressions.get(i);\r\n\t\t\t\t\t\tif(!col.isDefinitelyWritable())\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.COL_READONLY, new Integer(i));\r\n\t\t\t\t\t\tExpressionName exp = (ExpressionName)col;\r\n\t\t\t\t\t\tif(table == exp.getTable()){\r\n\t\t\t\t\t\t\tupdateValues[exp.getColumnIndex()] = src;\r\n\t\t\t\t\t\t\tisUpdateNeeded = true;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// save the new values if there are new value for this table\r\n\t\t\t\tif(isUpdateNeeded){\r\n\t\t\t\t\tresult.updateRow(updateValues);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}catch(Throwable e){\r\n\t\t\tcon.rollback(savepoint);\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}finally{\r\n\t\t\tif(con.getAutoCommit()) con.commit();\r\n\t\t}\r\n\t}","startLine":23,"lastLine":25}],"window":3},{"content":"case SQLTokenizer.LONGVARBINARY:case SQLTokenizer.BLOB:return readLongBinary();","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getBytes(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBytes()\r\n     */\r\n    @Override\r\n    byte[] getBytes(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    byte[] bytes = new byte[1];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.SMALLINT:\r\n                    bytes = new byte[2];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    bytes = new byte[4];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    bytes = new byte[8];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toByteArray();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString().getBytes();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString().getBytes();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    bytes = new byte[16];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":52,"lastLine":54},{"locFile":"java+method:///smallsql/database/StoreImpl/getObject(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getObject()\r\n     */\r\n    @Override\r\n    Object getObject(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n                    return Utils.getInteger( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return Utils.getInteger( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return Utils.getInteger(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue(readLong());\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME );\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE );\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":48,"lastLine":50}],"window":3},{"content":"this.value  = value;this.offset = tokenStart;this.length = tokenEnd-tokenStart;","cloneLocs":[{"locFile":"java+constructor:///smallsql/database/SQLToken/SQLToken(java.lang.String,int,int,int)","rawLines":"/**\r\n\t * Constructor used for quoted strings \r\n\t */\r\n\tSQLToken (String name, int value, int tokenStart, int tokenEnd){\r\n\t\tthis.value  = value;\r\n\t\tthis.offset = tokenStart;\r\n\t\tthis.length = tokenEnd-tokenStart;\r\n\t\tthis.name   = name;\r\n\t}","startLine":4,"lastLine":6},{"locFile":"java+constructor:///smallsql/database/SQLToken/SQLToken(int,int,int)","rawLines":"SQLToken (int value, int tokenStart, int tokenEnd){\r\n\t\tthis.value  = value;\r\n\t\tthis.offset = tokenStart;\r\n\t\tthis.length = tokenEnd-tokenStart;\r\n\t}","startLine":1,"lastLine":3}],"window":3},{"content":"}else{quoteBuffer.append(c);}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":189,"lastLine":191},{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":163,"lastLine":165}],"window":3},{"content":"con.add(lock);return lock;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Table/requestLockImpl(smallsql.database.SSConnection,int,long)","rawLines":"/**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * In the other case it return null.\r\n     * @param page The fileOffset or -1 for a new page\r\n     * @throws SQLException \r\n     */\r\n\tfinal private TableStorePage requestLockImpl(SSConnection con, int pageOperation, long page) throws SQLException{\r\n\t\tsynchronized(locks){\r\n\t\t\tif(tabLockConnection != null && tabLockConnection != con) return null;\r\n\t\t\tswitch(con.isolationLevel){\r\n\t\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\t\tserializeConnections.put( con, con);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tswitch(pageOperation){\r\n\t\t\t\tcase SQLTokenizer.CREATE:{\r\n\t\t\t\t\t\t// first check if another connection has a lock before creating a table lock\r\n\t\t\t\t\t\tif(locks.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\t//the first StorePage in the linked list must be ever TableStorePageInsert\r\n\t\t\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttabLockConnection = con;\r\n\t\t\t\t\t\ttabLockCount++;\r\n\t\t\t\t\t\tTableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n                case SQLTokenizer.ALTER:{\r\n                    // first check if there is any lock before creating a table lock\r\n                    if(locks.size() > 0 || locksInsert.size() > 0){\r\n                        return null;\r\n                    }\r\n                    if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }\r\n                    tabLockConnection = con;\r\n                    tabLockCount++;\r\n                    TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n                    lock.rollback();\r\n                    return lock;\r\n                }\r\n\t\t\t\tcase SQLTokenizer.INSERT:{\r\n\t\t\t\t\t\t// if there are more as one Connection with a serializable lock then an INSERT is not valid\r\n\t\t\t\t\t\tif(serializeConnections.size() > 1) return null;\r\n\t\t\t\t\t\tif(serializeConnections.size() == 1 && serializeConnections.get(con) == null) return null;\r\n\t\t\t\t\t\tTableStorePageInsert lock = new TableStorePageInsert(con, this, LOCK_INSERT);\r\n\t\t\t\t\t\tlocksInsert.add( lock );\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.SELECT:\r\n\t\t\t\tcase SQLTokenizer.UPDATE:{\r\n\t\t\t\t\t\tLong pageKey = new Long(page); //TODO performance\r\n\t\t\t\t\t\tTableStorePage prevLock = null;\r\n\t\t\t\t\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tTableStorePage usableLock = null;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock.con == con || \r\n\t\t\t\t\t\t\t   con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\t\t\t\t    usableLock = lock;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t    if(lock.lockType == LOCK_WRITE){\r\n\t\t\t\t\t\t\t        return null; // write lock of another Connection\r\n\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprevLock = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(usableLock != null){\r\n\t\t\t\t\t\t    return usableLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlock = new TableStorePage( con, this, LOCK_NONE, page);\r\n\t\t\t\t\t\tif(con.isolationLevel >= Connection.TRANSACTION_REPEATABLE_READ || pageOperation == SQLTokenizer.UPDATE){\r\n\t\t\t\t\t\t\tlock.lockType = pageOperation == SQLTokenizer.UPDATE ? LOCK_WRITE : LOCK_READ;\r\n\t\t\t\t\t\t\tif(prevLock != null){\r\n\t\t\t\t\t\t\t    prevLock.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t    locks.put( pageKey, lock );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lock;\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t// is used for written BLOB and CLOB\r\n\t\t\t\t\t// the difference to INSERT is that page described the size of the byte buffer\r\n\t\t\t\t\treturn new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"pageOperation:\"+pageOperation);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":40,"lastLine":42},{"locFile":"java+method:///smallsql/database/Table/requestLockImpl(smallsql.database.SSConnection,int,long)","rawLines":"/**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * In the other case it return null.\r\n     * @param page The fileOffset or -1 for a new page\r\n     * @throws SQLException \r\n     */\r\n\tfinal private TableStorePage requestLockImpl(SSConnection con, int pageOperation, long page) throws SQLException{\r\n\t\tsynchronized(locks){\r\n\t\t\tif(tabLockConnection != null && tabLockConnection != con) return null;\r\n\t\t\tswitch(con.isolationLevel){\r\n\t\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\t\tserializeConnections.put( con, con);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tswitch(pageOperation){\r\n\t\t\t\tcase SQLTokenizer.CREATE:{\r\n\t\t\t\t\t\t// first check if another connection has a lock before creating a table lock\r\n\t\t\t\t\t\tif(locks.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\t//the first StorePage in the linked list must be ever TableStorePageInsert\r\n\t\t\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttabLockConnection = con;\r\n\t\t\t\t\t\ttabLockCount++;\r\n\t\t\t\t\t\tTableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n                case SQLTokenizer.ALTER:{\r\n                    // first check if there is any lock before creating a table lock\r\n                    if(locks.size() > 0 || locksInsert.size() > 0){\r\n                        return null;\r\n                    }\r\n                    if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }\r\n                    tabLockConnection = con;\r\n                    tabLockCount++;\r\n                    TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n                    lock.rollback();\r\n                    return lock;\r\n                }\r\n\t\t\t\tcase SQLTokenizer.INSERT:{\r\n\t\t\t\t\t\t// if there are more as one Connection with a serializable lock then an INSERT is not valid\r\n\t\t\t\t\t\tif(serializeConnections.size() > 1) return null;\r\n\t\t\t\t\t\tif(serializeConnections.size() == 1 && serializeConnections.get(con) == null) return null;\r\n\t\t\t\t\t\tTableStorePageInsert lock = new TableStorePageInsert(con, this, LOCK_INSERT);\r\n\t\t\t\t\t\tlocksInsert.add( lock );\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.SELECT:\r\n\t\t\t\tcase SQLTokenizer.UPDATE:{\r\n\t\t\t\t\t\tLong pageKey = new Long(page); //TODO performance\r\n\t\t\t\t\t\tTableStorePage prevLock = null;\r\n\t\t\t\t\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tTableStorePage usableLock = null;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock.con == con || \r\n\t\t\t\t\t\t\t   con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\t\t\t\t    usableLock = lock;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t    if(lock.lockType == LOCK_WRITE){\r\n\t\t\t\t\t\t\t        return null; // write lock of another Connection\r\n\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprevLock = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(usableLock != null){\r\n\t\t\t\t\t\t    return usableLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlock = new TableStorePage( con, this, LOCK_NONE, page);\r\n\t\t\t\t\t\tif(con.isolationLevel >= Connection.TRANSACTION_REPEATABLE_READ || pageOperation == SQLTokenizer.UPDATE){\r\n\t\t\t\t\t\t\tlock.lockType = pageOperation == SQLTokenizer.UPDATE ? LOCK_WRITE : LOCK_READ;\r\n\t\t\t\t\t\t\tif(prevLock != null){\r\n\t\t\t\t\t\t\t    prevLock.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t    locks.put( pageKey, lock );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lock;\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t// is used for written BLOB and CLOB\r\n\t\t\t\t\t// the difference to INSERT is that page described the size of the byte buffer\r\n\t\t\t\t\treturn new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"pageOperation:\"+pageOperation);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":67,"lastLine":69},{"locFile":"java+method:///smallsql/database/Table/requestWriteLock(smallsql.database.SSConnection,smallsql.database.TableStorePage)","rawLines":"/**\r\n\t * Request a write lock for a page that is read. It add the resulting StorePage to the list of commits.\r\n     * @throws SQLException\r\n     *             if the connection was closed.\r\n\t */\r\n\tTableStorePage requestWriteLock(SSConnection con, TableStorePage readlock) throws SQLException{\r\n\t\tif(readlock.lockType == LOCK_INSERT){\r\n\t\t\tTableStorePage lock = new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\treadlock.nextLock = lock;\r\n\t\t\tcon.add(lock);\r\n\t\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t\t}\r\n\t\tLong pageKey = new Long(readlock.fileOffset); //TODO performance\r\n\t\tTableStorePage prevLock = null;\r\n\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\twhile(lock != null){\r\n\t\t\tif(lock.con != con) return null; // there is already any lock from another connection, we can not start write\r\n\t\t\tif(lock.lockType < LOCK_WRITE){\r\n\t\t\t\t// if there is only a read lock we can transfer it\r\n\t\t\t\t// this is required for rollback to a savepoint\r\n\t\t\t\tlock.lockType = LOCK_WRITE;\r\n\t\t\t\treturn lock;\r\n\t\t\t}\r\n\t\t\tprevLock = lock;\r\n\t\t\tlock = lock.nextLock;\r\n\t\t}\r\n\t\tlock = new TableStorePage( con, this, LOCK_WRITE, readlock.fileOffset);\r\n\t\tif(prevLock != null){\r\n\t\t    prevLock.nextLock = lock;\r\n\t\t} else {\r\n\t\t    locks.put( pageKey, lock );\r\n\t\t}\r\n\t\tcon.add(lock);\r\n\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t}","startLine":9,"lastLine":11}],"window":3},{"content":"if (comment != NOT_COMMENT) {break;}else if(quote == 0){","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":168,"lastLine":170},{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":34,"lastLine":36},{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":15,"lastLine":17}],"window":3},{"content":"case SQLTokenizer.TINYINT:return 3;case SQLTokenizer.SMALLINT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/getDisplaySize(int,int,int)","rawLines":"static int getDisplaySize(int dataType, int precision, int scale){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn 1; // 1 and 0\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 5; //true and false\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 6;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n            case SQLTokenizer.REAL:\r\n                return 13;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 17;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.BLOB:\r\n            case SQLTokenizer.CLOB:\r\n            case SQLTokenizer.NCLOB:\r\n\t\t\t\treturn Integer.MAX_VALUE;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\treturn precision + (scale>0 ? 2 : 1);\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\treturn 2 + precision*2;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                return 21;\r\n\t\t\tdefault:\r\n\t\t\t\treturn precision;\r\n\t\t}\r\n\t}","startLine":6,"lastLine":8},{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/getDataTypePrecision(int,int)","rawLines":"static int getDataTypePrecision(int dataType, int defaultValue){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.NULL:\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 1;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 5;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn 7;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 15;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\tif(defaultValue == -1)\r\n\t\t\t\t\treturn 0xFFFF;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                if(defaultValue == -1)\r\n                    return 38;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\treturn 23;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\treturn 8;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn 16;\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\treturn 36;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn Integer.MAX_VALUE;\r\n\t\t}\r\n\t\tif(defaultValue == -1)\r\n\t\t\tthrow new Error(\"Precision:\"+SQLTokenizer.getKeyWord(dataType));\r\n\t\treturn defaultValue;\r\n\t}","startLine":7,"lastLine":9}],"window":3},{"content":"}}break;","cloneLocs":[{"locFile":"java+method:///smallsql/database/Table/freeLock(smallsql.database.TableStorePage)","rawLines":"/**\r\n\t * Remove the lock from this table.\r\n\t */\r\n\tvoid freeLock(TableStorePage storePage){\r\n\t\tfinal int lockType = storePage.lockType;\r\n\t\tfinal long fileOffset = storePage.fileOffset;\r\n\t\tsynchronized(locks){\r\n\t\t\ttry{\r\n\t\t\t\tTableStorePage lock;\r\n\t\t\t\tTableStorePage prev;\r\n\t\t\t\tswitch(lockType){\r\n\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();\r\n\t\t\t\t}\r\n\t\t\t}finally{\r\n\t\t\t\tlocks.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":33,"lastLine":35},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":155,"lastLine":157},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":106,"lastLine":108}],"window":3},{"content":"assertNull( rs.getObject(\"c2\") );assertTrue( rs.next() );oldValue = rs.getString(\"c2\");","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/test2Columns()","rawLines":"public void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}","startLine":11,"lastLine":14},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test2Columns()","rawLines":"public void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}","startLine":28,"lastLine":31}],"window":3},{"content":"TableView table = fromEntry.getTableView();int colIdx = table.findColumnIdx(expr.getName());if(colIdx >= 0){","cloneLocs":[{"locFile":"java+method:///smallsql/database/CommandSelect/compileLinkExpressionName(smallsql.database.ExpressionName)","rawLines":"/**\r\n     * Set the connection (link) of a named Expression to the table and the column index.\r\n     * This means a column name in the SQL statement is link to it table source.\r\n     */\r\n    private void compileLinkExpressionName(ExpressionName expr) throws Exception{\r\n        String tableAlias = expr.getTableAlias();\r\n        if(tableAlias != null){\r\n            int t = 0;\r\n            for(; t < tables.size(); t++){\r\n                DataSource fromEntry = tables.get(t);\r\n                if(tableAlias.equalsIgnoreCase(fromEntry.getAlias())){\r\n                    TableView table = fromEntry.getTableView();\r\n                    int colIdx = table.findColumnIdx(expr.getName());\r\n                    if(colIdx >= 0){\r\n                        // Column was find and now we set the DataSouce, column index and TableView.\r\n                        expr.setFrom(fromEntry, colIdx, table);\r\n                        break;\r\n                    }else\r\n                        throw SmallSQLException.create(Language.COL_INVALID_NAME, new Object[]{expr.getName()});\r\n                }\r\n            }\r\n            if(t == tables.size())\r\n                throw SmallSQLException.create(Language.COL_WRONG_PREFIX, tableAlias);\r\n        }else{\r\n            // column name without table name\r\n            boolean isSetFrom = false;\r\n            for(int t = 0; t < tables.size(); t++){\r\n                DataSource fromEntry = tables.get(t);\r\n                TableView table = fromEntry.getTableView();\r\n                int colIdx = table.findColumnIdx(expr.getName());\r\n                if(colIdx >= 0){\r\n                    if(isSetFrom){\r\n                        // Column was already set. This means the column is ambiguous\r\n                        throw SmallSQLException.create(Language.COL_AMBIGUOUS, expr.getName());\r\n                    }\r\n                    // Column was find and now we set the DataSouce, column index and TableView.\r\n                    isSetFrom = true;\r\n                    expr.setFrom(fromEntry, colIdx, table);\r\n                }\r\n            }\r\n            if(!isSetFrom){\r\n                throw SmallSQLException.create(Language.COL_INVALID_NAME, expr.getName());\r\n            }\r\n        }\r\n        compileLinkExpressionParams(expr);\r\n    }","startLine":11,"lastLine":13},{"locFile":"java+method:///smallsql/database/CommandSelect/compileLinkExpressionName(smallsql.database.ExpressionName)","rawLines":"/**\r\n     * Set the connection (link) of a named Expression to the table and the column index.\r\n     * This means a column name in the SQL statement is link to it table source.\r\n     */\r\n    private void compileLinkExpressionName(ExpressionName expr) throws Exception{\r\n        String tableAlias = expr.getTableAlias();\r\n        if(tableAlias != null){\r\n            int t = 0;\r\n            for(; t < tables.size(); t++){\r\n                DataSource fromEntry = tables.get(t);\r\n                if(tableAlias.equalsIgnoreCase(fromEntry.getAlias())){\r\n                    TableView table = fromEntry.getTableView();\r\n                    int colIdx = table.findColumnIdx(expr.getName());\r\n                    if(colIdx >= 0){\r\n                        // Column was find and now we set the DataSouce, column index and TableView.\r\n                        expr.setFrom(fromEntry, colIdx, table);\r\n                        break;\r\n                    }else\r\n                        throw SmallSQLException.create(Language.COL_INVALID_NAME, new Object[]{expr.getName()});\r\n                }\r\n            }\r\n            if(t == tables.size())\r\n                throw SmallSQLException.create(Language.COL_WRONG_PREFIX, tableAlias);\r\n        }else{\r\n            // column name without table name\r\n            boolean isSetFrom = false;\r\n            for(int t = 0; t < tables.size(); t++){\r\n                DataSource fromEntry = tables.get(t);\r\n                TableView table = fromEntry.getTableView();\r\n                int colIdx = table.findColumnIdx(expr.getName());\r\n                if(colIdx >= 0){\r\n                    if(isSetFrom){\r\n                        // Column was already set. This means the column is ambiguous\r\n                        throw SmallSQLException.create(Language.COL_AMBIGUOUS, expr.getName());\r\n                    }\r\n                    // Column was find and now we set the DataSouce, column index and TableView.\r\n                    isSetFrom = true;\r\n                    expr.setFrom(fromEntry, colIdx, table);\r\n                }\r\n            }\r\n            if(!isSetFrom){\r\n                throw SmallSQLException.create(Language.COL_INVALID_NAME, expr.getName());\r\n            }\r\n        }\r\n        compileLinkExpressionParams(expr);\r\n    }","startLine":28,"lastLine":30}],"window":3},{"content":"case SQLTokenizer.TIME:case SQLTokenizer.DATE:case SQLTokenizer.SMALLDATETIME:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":53,"lastLine":55},{"locFile":"java+method:///smallsql/database/StoreImpl/getMoney(int,int)","rawLines":"// is used for faster calculation\r\n    @Override\r\n    long getMoney( int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return (long)(Utils.bytes2double( readBinary() ) * 10000L);\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() * 10000L;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() * 10000L;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() * 10000L;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() * 10000L;\r\n            case SQLTokenizer.REAL:\r\n                    return (long)(readFloat() * 10000L);\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)(readDouble() * 10000L);\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return (long)(readNumeric().doubleValue() * 10000L);\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Money.parseMoney( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Money.parseMoney( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Money.parseMoney( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return (long)(Utils.bytes2double( readLongBinary() ) * 10000L);\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"MONEY\" });\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":50,"lastLine":52},{"locFile":"java+method:///smallsql/database/ExpressionValue/getInt(java.lang.Object,int)","rawLines":"static int getInt(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n                return ((Number)obj).intValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn (int)((DateTime)obj).getTimeMillis();\r\n            default:\r\n\t\t\t\tString str = obj.toString().trim();\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Integer.parseInt( str );\r\n\t\t\t\t}catch(Throwable th){/* A NumberFormatException can occur if it a floating point number */}\r\n\t\t\t\treturn (int)Double.parseDouble( str );\r\n        }\r\n    }","startLine":18,"lastLine":20},{"locFile":"java+method:///smallsql/database/StoreImpl/getBytes(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBytes()\r\n     */\r\n    @Override\r\n    byte[] getBytes(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    byte[] bytes = new byte[1];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.SMALLINT:\r\n                    bytes = new byte[2];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    bytes = new byte[4];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    bytes = new byte[8];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toByteArray();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString().getBytes();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString().getBytes();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    bytes = new byte[16];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":24,"lastLine":26},{"locFile":"java+method:///smallsql/database/StoreImpl/getNumeric(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBigDecimal()\r\n     */\r\n    @Override\r\n    MutableNumeric getNumeric(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":52,"lastLine":54}],"window":3},{"content":"int count = commitPages.size();for(int i=0; i<count; i++){TransactionStep page = (TransactionStep)commitPages.get(i);","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSConnection/commit()","rawLines":"public void commit() throws SQLException {\r\n        log.println(\"Commit\");\r\n        testClosedConnection();\r\n        synchronized(getMonitor()){\r\n    \ttry{\r\n\t            int count = commitPages.size();\r\n\t            for(int i=0; i<count; i++){\r\n\t                TransactionStep page = (TransactionStep)commitPages.get(i);\r\n\t                page.commit();\r\n\t            }\r\n\t\t\t\tfor(int i=0; i<count; i++){\r\n\t\t\t\t    TransactionStep page = (TransactionStep)commitPages.get(i);\r\n\t\t\t\t\tpage.freeLock();\r\n\t\t\t\t}\r\n\t            commitPages.clear();\r\n\t            transactionTime = System.currentTimeMillis();\r\n    \t}catch(Throwable e){\r\n    \t\trollback();\r\n    \t\tthrow SmallSQLException.createFromException(e);\r\n    \t}\r\n        }\r\n    }","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSConnection/rollback()","rawLines":"public void rollback() throws SQLException {\r\n\t\tlog.println(\"Rollback\");\r\n\t\ttestClosedConnection();\r\n        synchronized(getMonitor()){\r\n            int count = commitPages.size();\r\n            for(int i=0; i<count; i++){\r\n                TransactionStep page = (TransactionStep)commitPages.get(i);\r\n                page.rollback();\r\n                page.freeLock();\r\n            }\r\n            commitPages.clear();\r\n\t\t\ttransactionTime = System.currentTimeMillis();\r\n        }\r\n    }","startLine":4,"lastLine":6}],"window":3},{"content":"final byte[] getBytes() throws Exception{if(isNull()) return null;byte[] bytes = param1.getBytes();","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionRTrim/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n        int length = bytes.length;\r\n        while(length>0 && bytes[length-1]==0){\r\n            length--;\r\n        }\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, 0, b, 0, length);\r\n\t\treturn b;\t\t\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionInsert/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n        if(isNull()) return null;\r\n        byte[] bytes = param1.getBytes();\r\n        int start  = Math.min(Math.max( 0, param2.getInt() - 1), bytes.length );\r\n        int length = Math.min(param3.getInt(), bytes.length );\r\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n        buffer.write(bytes,0,start);\r\n        buffer.write(param4.getBytes());\r\n        if(length < 0) \r\n            throw SmallSQLException.create(Language.INSERT_INVALID_LEN, new Integer(length));\r\n        buffer.write(bytes, start+length, bytes.length-start-length);\r\n        return buffer.toByteArray();\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionSubstring/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint byteLen = bytes.length;\r\n\t\tint start  = Math.min( Math.max( 0, param2.getInt() - 1), byteLen);\r\n\t\tint length = param3.getInt();\r\n\t\tif(length < 0) \r\n\t\t\tthrow SmallSQLException.create(Language.SUBSTR_INVALID_LEN, new Integer(length));\r\n\t\tif(start == 0 && byteLen == length) return bytes;\r\n\t\tif(byteLen > length + start){\r\n\t\t\tbyte[] b = new byte[length];\r\n\t\t\tSystem.arraycopy(bytes, start, b, 0, length);\r\n\t\t\treturn b;\t\t\r\n\t\t}else{\r\n\t\t\tbyte[] b = new byte[byteLen - start];\r\n\t\t\tSystem.arraycopy(bytes, start, b, 0, b.length);\r\n\t\t\treturn b;\t\t\r\n\t\t}\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionRepeat/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n        if(isNull()) return null;\r\n        byte[] bytes = param1.getBytes();\r\n        int count  = param2.getInt();\r\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n        for(int i=0; i<count; i++){\r\n            buffer.write(bytes);\r\n        }\r\n        return buffer.toByteArray();\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionLTrim/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n        int start = 0;\r\n        int length = bytes.length;\r\n        while(start<length && bytes[start]==0){\r\n            start++;\r\n        }\r\n        length -= start; \r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, start, b, 0, length);\r\n\t\treturn b;\t\t\r\n\t}","startLine":0,"lastLine":2}],"window":3},{"content":"buf.append(' ');formatNumber( details.year, 4, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":119,"lastLine":121},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":103,"lastLine":105}],"window":3},{"content":"rs.insertRow();rs.beforeFirst();assertTrue( rs.next() );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_withRightWhere()","rawLines":"/**\r\n\t * A row that was inserted and committed with a valid WHERE expression should not count 2 times.\r\n\t */\r\n\tpublic void testInsertRow_withRightWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert2')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where v = 'qwert'\");\r\n\t\t\t\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t}\r\n\t}","startLine":16,"lastLine":19},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_withWrongWhere()","rawLines":"/**\r\n     * If there was insert a row within the ResultSet that not map WHERE than you scroll to this row. If there an Insert\r\n     * outsite the ResultSet that not map the WHERE then you can't scroll this row.\r\n     * \r\n     * @throws Exception\r\n     */\r\n\tpublic void testInsertRow_withWrongWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":20,"lastLine":23}],"window":3},{"content":"if(isNull()) return 0;switch(interval){case SQLTokenizer.SQL_TSI_FRAC_SECOND:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionTimestampDiff/getInt()","rawLines":"int getInt() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\tswitch(interval){\r\n\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() - param1.getLong());\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() /1000 - param1.getLong() /1000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn (int)(param2.getLong() /60000 - param1.getLong() /60000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn (int)(param2.getLong() /3600000 - param1.getLong() /3600000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn (int)(param2.getLong() /86400000 - param1.getLong() /86400000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\tlong day2 = param2.getLong() /86400000;\r\n\t\t\t\tlong day1 = param1.getLong() /86400000;\r\n\t\t\t\t// the 1. Jan 1970 is a Thursday --> 3\r\n\t\t\t\treturn (int)((day2 + 3) / 7 - (day1 + 3) / 7);\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 12 + details2.month) - (details1.year * 12 + details1.month);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 4 + details2.month / 3) - (details1.year * 4 + details1.month / 3);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn details2.year - details1.year;\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionTimestampAdd/getLong()","rawLines":"long getLong() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\tswitch(interval){\r\n\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong();\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 1000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 60000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 3600000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 86400000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 604800000;\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong() * 3;\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.year += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t\t// TODO Auto-generated method stub\r\n\t}","startLine":1,"lastLine":3}],"window":3},{"content":"previousToken();return list;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/expressionTokenList(smallsql.database.Command,int)","rawLines":"/**\r\n     * Read a list of expressions. The list is limit from specific SQL keywords like SELECT, GROUP BY, ORDER BY\r\n     */\r\n    private Expressions expressionTokenList(Command cmd, int listType) throws SQLException{\r\n\t\tExpressions list = new Expressions();\r\n        while(true){\r\n        \tExpression expr = expression(cmd, 0);\r\n            list.add( expr );\r\n            SQLToken token = nextToken();\r\n            \r\n\t\t\tif(listType == SQLTokenizer.ORDER && token != null){\r\n\t\t\t\tswitch(token.value){\r\n\t\t\t\t\tcase SQLTokenizer.DESC:\r\n\t\t\t\t\t\texpr.setAlias(SQLTokenizer.DESC_STR);\r\n\t\t\t\t\t\t//no break;\r\n\t\t\t\t\tcase SQLTokenizer.ASC:\r\n\t\t\t\t\t\ttoken = nextToken();\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(token == null) {\r\n\t\t\t\tpreviousToken();\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\r\n\t\t\tswitch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n\t\t\t\t\tif(isKeyword(token) ){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn list;\r\n\t\t\t\t\t}\r\n                    throw createSyntaxError( token, MISSING_TOKEN_LIST);\r\n            }\r\n        }\r\n    }","startLine":30,"lastLine":32},{"locFile":"java+method:///smallsql/database/SQLParser/expressionTokenList(smallsql.database.Command,int)","rawLines":"/**\r\n     * Read a list of expressions. The list is limit from specific SQL keywords like SELECT, GROUP BY, ORDER BY\r\n     */\r\n    private Expressions expressionTokenList(Command cmd, int listType) throws SQLException{\r\n\t\tExpressions list = new Expressions();\r\n        while(true){\r\n        \tExpression expr = expression(cmd, 0);\r\n            list.add( expr );\r\n            SQLToken token = nextToken();\r\n            \r\n\t\t\tif(listType == SQLTokenizer.ORDER && token != null){\r\n\t\t\t\tswitch(token.value){\r\n\t\t\t\t\tcase SQLTokenizer.DESC:\r\n\t\t\t\t\t\texpr.setAlias(SQLTokenizer.DESC_STR);\r\n\t\t\t\t\t\t//no break;\r\n\t\t\t\t\tcase SQLTokenizer.ASC:\r\n\t\t\t\t\t\ttoken = nextToken();\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(token == null) {\r\n\t\t\t\tpreviousToken();\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\r\n\t\t\tswitch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n\t\t\t\t\tif(isKeyword(token) ){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn list;\r\n\t\t\t\t\t}\r\n                    throw createSyntaxError( token, MISSING_TOKEN_LIST);\r\n            }\r\n        }\r\n    }","startLine":21,"lastLine":23}],"window":3},{"content":"case SQLTokenizer.MONEY:case SQLTokenizer.DECIMAL:case SQLTokenizer.NUMERIC:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/isSignedDataType(int)","rawLines":"static boolean isSignedDataType(int dataType) {\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":6,"lastLine":8},{"locFile":"java+method:///smallsql/database/ExpressionValue/getInt(java.lang.Object,int)","rawLines":"static int getInt(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n                return ((Number)obj).intValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn (int)((DateTime)obj).getTimeMillis();\r\n            default:\r\n\t\t\t\tString str = obj.toString().trim();\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Integer.parseInt( str );\r\n\t\t\t\t}catch(Throwable th){/* A NumberFormatException can occur if it a floating point number */}\r\n\t\t\t\treturn (int)Double.parseDouble( str );\r\n        }\r\n    }","startLine":13,"lastLine":15}],"window":3},{"content":"}elseif (value.length == 2 && (value[0] > 0)){long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);","cloneLocs":[{"locFile":"java+method:///smallsql/database/MutableNumeric/doubleValue()","rawLines":"public double doubleValue(){\r\n        if(value.length == 0 || signum == 0){\r\n            return 0;\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                return value[0] / scaleDoubleFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                return temp / scaleDoubleFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                return temp / scaleDoubleFactor[scale] * signum;\r\n            }else{\r\n                return new BigDecimal( new BigInteger( toByteArray() ), scale ).doubleValue();\r\n            }\r\n        }\r\n    }","startLine":12,"lastLine":15},{"locFile":"java+method:///smallsql/database/MutableNumeric/toString()","rawLines":"public String toString(){\r\n        StringBuffer buf = new StringBuffer();\r\n        if(value.length == 0 || signum == 0){\r\n            buf.append( '0' );\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                buf.append( Integer.toString(value[0]) );\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                buf.append( Long.toString( temp ) );\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                buf.append( Long.toString( temp ) );\r\n            }else{\r\n                return new BigDecimal( new BigInteger( toByteArray() ), scale ).toString();\r\n            }\r\n        }\r\n        if(scale > 0){\r\n            while(buf.length() <= scale) buf.insert( 0, '0' );\r\n            buf.insert( buf.length() - scale, '.' );\r\n        }\r\n        if (signum < 0) buf.insert( 0, '-');\r\n        return buf.toString();\r\n    }","startLine":13,"lastLine":16},{"locFile":"java+method:///smallsql/database/MutableNumeric/floatValue()","rawLines":"public float floatValue(){\r\n        if(value.length == 0 || signum == 0){\r\n            return 0;\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                return value[0] / scaleFloatFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                return temp / scaleFloatFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                return temp / scaleFloatFactor[scale] * signum;\r\n            }else{\r\n                return new BigDecimal( new BigInteger( toByteArray() ), scale ).floatValue();\r\n            }\r\n        }\r\n    }","startLine":12,"lastLine":15},{"locFile":"java+method:///smallsql/database/MutableNumeric/longValue()","rawLines":"public long longValue(){\r\n        if(value.length == 0 || signum == 0){\r\n            return 0;\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                return Utils.double2long(value[0] / scaleDoubleFactor[scale] * signum);\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                return Utils.double2long(temp / scaleDoubleFactor[scale] * signum);\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                return Utils.double2long(temp / scaleDoubleFactor[scale] * signum);\r\n            }else{\r\n           \t\tif(scale != 0){\r\n           \t\t\tMutableNumeric numeric = new MutableNumeric(this);\r\n           \t\t\tnumeric.setScale(0);\r\n           \t\t\treturn numeric.longValue();\r\n           \t\t}           \t\t\t\r\n            \treturn (signum > 0) ? Long.MAX_VALUE : Long.MIN_VALUE;\r\n            }\r\n        }\r\n    }","startLine":12,"lastLine":15}],"window":3},{"content":"Connection con = AllTests.getConnection();Statement st = con.createStatement();ResultSet rs = st.executeQuery(sql);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BasicTestCase/printSQL(java.lang.String)","rawLines":"void printSQL(String sql) throws SQLException{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(sql);\r\n\t\tprintRS( rs );\r\n\t}","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/junit/BasicTestCase/assertEqualsRsValue(java.lang.Object,java.lang.String)","rawLines":"/**\r\n\t * Test a single Value of a the ResultSet that was produce from the SQL\r\n\t */\r\n   \tvoid assertEqualsRsValue(Object obj, String sql) throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(sql);\r\n\t\tassertTrue( \"No row produce\", rs.next());\r\n        assertEqualsRsValue(obj,rs,false);\r\n    }","startLine":4,"lastLine":6},{"locFile":"java+method:///smallsql/junit/BasicTestCase/assertRowCount(int,java.lang.String)","rawLines":"void assertRowCount(int sollCount, String sql ) throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(sql);\r\n        assertRowCount(sollCount,rs);\r\n    }","startLine":1,"lastLine":3}],"window":3},{"content":"}switch(token.value){case SQLTokenizer.COMMA:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/expressionTokenList(smallsql.database.Command,int)","rawLines":"/**\r\n     * Read a list of expressions. The list is limit from specific SQL keywords like SELECT, GROUP BY, ORDER BY\r\n     */\r\n    private Expressions expressionTokenList(Command cmd, int listType) throws SQLException{\r\n\t\tExpressions list = new Expressions();\r\n        while(true){\r\n        \tExpression expr = expression(cmd, 0);\r\n            list.add( expr );\r\n            SQLToken token = nextToken();\r\n            \r\n\t\t\tif(listType == SQLTokenizer.ORDER && token != null){\r\n\t\t\t\tswitch(token.value){\r\n\t\t\t\t\tcase SQLTokenizer.DESC:\r\n\t\t\t\t\t\texpr.setAlias(SQLTokenizer.DESC_STR);\r\n\t\t\t\t\t\t//no break;\r\n\t\t\t\t\tcase SQLTokenizer.ASC:\r\n\t\t\t\t\t\ttoken = nextToken();\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(token == null) {\r\n\t\t\t\tpreviousToken();\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\r\n\t\t\tswitch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n\t\t\t\t\tif(isKeyword(token) ){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn list;\r\n\t\t\t\t\t}\r\n                    throw createSyntaxError( token, MISSING_TOKEN_LIST);\r\n            }\r\n        }\r\n    }","startLine":23,"lastLine":26},{"locFile":"java+method:///smallsql/database/SQLParser/singleSelect()","rawLines":"/**\r\n     * A single SELECT of a UNION or only a simple single SELECT.\r\n     * @return\r\n     * @throws SQLException\r\n     */\r\n    private CommandSelect singleSelect() throws SQLException{\r\n        CommandSelect selCmd = new CommandSelect(con.log);\r\n\t\tSQLToken token;\r\n        // scan for prefix like DISTINCT, ALL and the TOP clause; sample: SELECT TOP 15 ...\r\nSwitch: while(true){\r\n\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.TOP:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tint maxRows = Integer.parseInt(token.getName(sql));\r\n\t\t\t\t\t\tselCmd.setMaxRows(maxRows);\r\n\t\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ALL:\r\n\t\t\t\t\tselCmd.setDistinct(false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.DISTINCT:\r\n\t\t\t\t\tselCmd.setDistinct(true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\tbreak Switch;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        while(true){\r\n            Expression column = expression(selCmd, 0);\r\n            selCmd.addColumnExpression( column );\r\n\r\n            token = nextToken();\r\n            if(token == null) return selCmd; // SELECT without FROM\r\n\r\n            boolean as = false;\r\n            if(token.value == SQLTokenizer.AS){\r\n                token = nextToken(MISSING_EXPRESSION);\r\n                as = true;\r\n            }\r\n\r\n            if(as || (!isKeyword(token))){\r\n            \tString alias = getIdentifier( token);\r\n                column.setAlias( alias );\r\n                token = nextToken();\r\n                if(token == null) return selCmd; // SELECT without FROM\r\n            }\r\n\r\n            switch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        break;\r\n                case SQLTokenizer.FROM:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        from(selCmd);\r\n                        return selCmd;\r\n\r\n                default:\r\n                        if(!isKeyword(token))\r\n                \t\t\tthrow createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.FROM} );\r\n                        previousToken();\r\n                        return selCmd;\r\n            }\r\n        }\r\n    }","startLine":51,"lastLine":54}],"window":3},{"content":"throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/parse(java.lang.String)","rawLines":"static long parse(final String datetime) throws SQLException{\r\n\t\ttry{\r\n\t\t\tfinal int length = datetime.length();\r\n\r\n\t\t\tfinal int year;\r\n\t\t\tfinal int month;\r\n\t\t\tfinal int day;\r\n\t\t\tfinal int hour;\r\n\t\t\tfinal int minute;\r\n\t\t\tfinal int second;\r\n\t\t\tfinal int millis;\r\n\t\t\t\r\n\r\n\t\t\tint idx1 = 0;\r\n\t\t\tint idx2 = datetime.indexOf('-');\r\n\t\t\tif(idx2 > 0){\r\n\t\t\t\tyear = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf('-', idx1);\r\n\t\t\t\tmonth = Integer.parseInt(datetime.substring(idx1, idx2).trim())-1;\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf(' ', idx1);\r\n\t\t\t\tif(idx2 < 0) idx2 = datetime.length();\r\n\t\t\t\tday = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t}else{\r\n\t\t\t\tyear  = 1970;\r\n\t\t\t\tmonth = 0;\r\n\t\t\t\tday   = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tidx1 = idx2+1;\r\n\t\t\tidx2 = datetime.indexOf(':', idx1);\r\n\t\t\tif(idx2>0){\r\n\t\t\t\thour = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf(':', idx1);\r\n\t\t\t\tminute = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf('.', idx1);\r\n\t\t\t\tif(idx2 < 0) idx2 = datetime.length();\r\n\t\t\t\tsecond = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tif(idx1 < length){\r\n\t\t\t\t\tString strMillis = datetime.substring(idx1).trim();\r\n\t\t\t\t\tswitch(strMillis.length()){\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis) * 100;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis) * 10;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis.substring(0,3));\r\n\t\t\t\t\t}\r\n\t\t\t\t}else\r\n\t\t\t\t\tmillis = 0;\r\n\t\t\t}else{\r\n\t\t\t\thour   = 0;\r\n\t\t\t\tminute = 0;\r\n\t\t\t\tsecond = 0;\r\n\t\t\t\tmillis = 0;\t\t\t\t\r\n\t\t\t}\r\n            if(idx1 == 0 && length > 0){\r\n                throw SmallSQLException.create(Language.DATETIME_INVALID);\r\n            }\r\n            \r\n            if(month >= 12){\r\n                throw SmallSQLException.create(Language.MONTH_TOOLARGE, datetime );\r\n            }\r\n            if(day >= 32){\r\n                throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n            }\r\n            if(day == 31){\r\n                switch(month){\r\n                case 1:\r\n                case 3:\r\n                case 5:\r\n                case 8:\r\n                case 10:\r\n                    throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n                }\r\n            }\r\n            if(month == 1){\r\n                if(day == 30){\r\n                    throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n                }\r\n                if(day == 29){\r\n                    if(!isLeapYear(year)){\r\n                        throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n                    }\r\n                }\r\n            }\r\n            if(hour >= 24){\r\n                throw SmallSQLException.create(Language.HOURS_TOOLARGE, datetime );\r\n            }\r\n            if(minute >= 60){\r\n                throw SmallSQLException.create(Language.MINUTES_TOOLARGE, datetime );\r\n            }\r\n            if(second >= 60){\r\n                throw SmallSQLException.create(Language.SECS_TOOLARGE, datetime );\r\n            }\r\n            if(millis >= 1000){\r\n                throw SmallSQLException.create(Language.MILLIS_TOOLARGE, datetime );\r\n            }\r\n\t\t\treturn calcMillis(year, month, day, hour, minute, second, millis);\r\n        }catch(SQLException ex){\r\n            throw ex;\r\n\t\t}catch(Throwable ex){\r\n\t\t\tthrow SmallSQLException.createFromException(Language.DATETIME_INVALID, datetime, ex );\r\n\t\t}\r\n\t}","startLine":87,"lastLine":89},{"locFile":"java+method:///smallsql/database/DateTime/parse(java.lang.String)","rawLines":"static long parse(final String datetime) throws SQLException{\r\n\t\ttry{\r\n\t\t\tfinal int length = datetime.length();\r\n\r\n\t\t\tfinal int year;\r\n\t\t\tfinal int month;\r\n\t\t\tfinal int day;\r\n\t\t\tfinal int hour;\r\n\t\t\tfinal int minute;\r\n\t\t\tfinal int second;\r\n\t\t\tfinal int millis;\r\n\t\t\t\r\n\r\n\t\t\tint idx1 = 0;\r\n\t\t\tint idx2 = datetime.indexOf('-');\r\n\t\t\tif(idx2 > 0){\r\n\t\t\t\tyear = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf('-', idx1);\r\n\t\t\t\tmonth = Integer.parseInt(datetime.substring(idx1, idx2).trim())-1;\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf(' ', idx1);\r\n\t\t\t\tif(idx2 < 0) idx2 = datetime.length();\r\n\t\t\t\tday = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t}else{\r\n\t\t\t\tyear  = 1970;\r\n\t\t\t\tmonth = 0;\r\n\t\t\t\tday   = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tidx1 = idx2+1;\r\n\t\t\tidx2 = datetime.indexOf(':', idx1);\r\n\t\t\tif(idx2>0){\r\n\t\t\t\thour = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf(':', idx1);\r\n\t\t\t\tminute = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf('.', idx1);\r\n\t\t\t\tif(idx2 < 0) idx2 = datetime.length();\r\n\t\t\t\tsecond = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tif(idx1 < length){\r\n\t\t\t\t\tString strMillis = datetime.substring(idx1).trim();\r\n\t\t\t\t\tswitch(strMillis.length()){\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis) * 100;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis) * 10;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis.substring(0,3));\r\n\t\t\t\t\t}\r\n\t\t\t\t}else\r\n\t\t\t\t\tmillis = 0;\r\n\t\t\t}else{\r\n\t\t\t\thour   = 0;\r\n\t\t\t\tminute = 0;\r\n\t\t\t\tsecond = 0;\r\n\t\t\t\tmillis = 0;\t\t\t\t\r\n\t\t\t}\r\n            if(idx1 == 0 && length > 0){\r\n                throw SmallSQLException.create(Language.DATETIME_INVALID);\r\n            }\r\n            \r\n            if(month >= 12){\r\n                throw SmallSQLException.create(Language.MONTH_TOOLARGE, datetime );\r\n            }\r\n            if(day >= 32){\r\n                throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n            }\r\n            if(day == 31){\r\n                switch(month){\r\n                case 1:\r\n                case 3:\r\n                case 5:\r\n                case 8:\r\n                case 10:\r\n                    throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n                }\r\n            }\r\n            if(month == 1){\r\n                if(day == 30){\r\n                    throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n                }\r\n                if(day == 29){\r\n                    if(!isLeapYear(year)){\r\n                        throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n                    }\r\n                }\r\n            }\r\n            if(hour >= 24){\r\n                throw SmallSQLException.create(Language.HOURS_TOOLARGE, datetime );\r\n            }\r\n            if(minute >= 60){\r\n                throw SmallSQLException.create(Language.MINUTES_TOOLARGE, datetime );\r\n            }\r\n            if(second >= 60){\r\n                throw SmallSQLException.create(Language.SECS_TOOLARGE, datetime );\r\n            }\r\n            if(millis >= 1000){\r\n                throw SmallSQLException.create(Language.MILLIS_TOOLARGE, datetime );\r\n            }\r\n\t\t\treturn calcMillis(year, month, day, hour, minute, second, millis);\r\n        }catch(SQLException ex){\r\n            throw ex;\r\n\t\t}catch(Throwable ex){\r\n\t\t\tthrow SmallSQLException.createFromException(Language.DATETIME_INVALID, datetime, ex );\r\n\t\t}\r\n\t}","startLine":96,"lastLine":98}],"window":3},{"content":"final void setParamAt( Expression param, int idx){switch(idx){case 0:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/setParamAt(smallsql.database.Expression,int)","rawLines":"final void setParamAt( Expression param, int idx){\r\n\t\tswitch(idx){\r\n\t\t\tcase 0:\r\n\t\t\t\tleft = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n                if(right != null){\r\n                    right = param;\r\n                }\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n                if(right != null){\r\n                    right2 = param;\r\n                }\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tif(inList != null && idx>0 && idx<=inList.length){\r\n\t\t\tinList[idx-1] = param;\r\n\t\t}\r\n\t\tsuper.setParamAt( param, idx );\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunction/setParamAt(smallsql.database.Expression,int)","rawLines":"final void setParamAt( Expression param, int idx){\r\n\t\tswitch(idx){\r\n\t\t\tcase 0:\r\n\t\t\t\tparam1 = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tparam2 = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tparam3 = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tparam4 = param;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tsuper.setParamAt( param, idx );\r\n\t}","startLine":0,"lastLine":2}],"window":3},{"content":"final int getInt() throws Exception {if(param1.isNull()) return 0;DateTime.Details details = new DateTime.Details(param1.getLong());","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionDayOfYear/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(param1.isNull()) return 0;\r\n\t\tDateTime.Details details = new DateTime.Details(param1.getLong());\r\n\t\treturn details.dayofyear+1;\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionYear/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(param1.isNull()) return 0;\r\n\t\tDateTime.Details details = new DateTime.Details(param1.getLong());\r\n\t\treturn details.year;\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionMinute/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(param1.isNull()) return 0;\r\n\t\tDateTime.Details details = new DateTime.Details(param1.getLong());\r\n\t\treturn details.minute;\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionMonth/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(param1.isNull()) return 0;\r\n\t\tDateTime.Details details = new DateTime.Details(param1.getLong());\r\n\t\treturn details.month+1;\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionHour/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(param1.isNull()) return 0;\r\n\t\tDateTime.Details details = new DateTime.Details(param1.getLong());\r\n\t\treturn details.hour;\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionDayOfMonth/getInt()","rawLines":"final int getInt() throws Exception {\r\n\t\tif(param1.isNull()) return 0;\r\n\t\tDateTime.Details details = new DateTime.Details(param1.getLong());\r\n\t\treturn details.day;\r\n\t}","startLine":0,"lastLine":2}],"window":3},{"content":"}}else fullRightRowCounter++;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":62,"lastLine":65},{"locFile":"java+method:///smallsql/database/JoinScroll/next()","rawLines":"boolean next() throws Exception{\r\n        boolean result;\r\n        if(fullReturnCounter >=0){\r\n            do{\r\n                if(fullReturnCounter >= fullRowCount){\r\n                    return false; \r\n                }\r\n                right.next();\r\n            }while(isFullNotValid[fullReturnCounter++]);\r\n            return true;\r\n        }\r\n        do{\r\n            if(isBeforeFirst){               \r\n                result = left.next();\r\n                if(result){ \r\n                    result = right.first();\r\n                    if(!result){\r\n                        switch(type){\r\n                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                        }\r\n                    }else fullRightRowCounter++;\r\n                }else{\r\n                    // left does not include any row\r\n                    if(type == Join.FULL_JOIN){\r\n                        while(right.next()){\r\n                            fullRightRowCounter++;\r\n                        }\r\n                        fullRowCount = fullRightRowCounter;\r\n                    }\r\n                }\r\n            }else{\r\n                result = right.next();              \r\n                if(!result){\r\n                    switch(type){\r\n                        case Join.LEFT_JOIN:\r\n                        case Join.FULL_JOIN:\r\n                            if(isOuterValid){\r\n                                isOuterValid = false;\r\n                                right.nullRow();\r\n                                return true;\r\n                            }\r\n                            fullRowCount = Math.max( fullRowCount, fullRightRowCounter);\r\n                            fullRightRowCounter = 0;\r\n                    }\r\n                    isOuterValid = true;\r\n                    result = left.next();\r\n                    if(result){ \r\n                        result = right.first();\r\n                        if(!result){\r\n                            switch(type){\r\n                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;\r\n                            }\r\n                        }else fullRightRowCounter++;\r\n                    }\r\n                    \r\n                }else fullRightRowCounter++;\r\n            }\r\n            isBeforeFirst = false;\r\n        }while(result && !getBoolean());\r\n        isOuterValid = false;\r\n        if(type == Join.FULL_JOIN){\r\n            if(fullRightRowCounter >= isFullNotValid.length){\r\n                boolean[] temp = new boolean[fullRightRowCounter << 1];\r\n                System.arraycopy( isFullNotValid, 0, temp, 0, fullRightRowCounter);\r\n                isFullNotValid = temp;\r\n            }\r\n            if(!result){\r\n                if(fullRowCount == 0){\r\n                    return false; \r\n                }\r\n                if(fullReturnCounter<0) {\r\n                    fullReturnCounter = 0;\r\n                    right.first();\r\n                    left.nullRow();\r\n                }\r\n                while(isFullNotValid[fullReturnCounter++]){\r\n                    if(fullReturnCounter >= fullRowCount){\r\n                       return false; \r\n                    }\r\n                    right.next();\r\n                }\r\n                return true;\r\n            }else\r\n                isFullNotValid[fullRightRowCounter-1] = result;\r\n        }\r\n        return result;\r\n    }","startLine":60,"lastLine":62}],"window":3},{"content":"try{if(st.rsType == ResultSet.TYPE_FORWARD_ONLY) throw SmallSQLException.create(Language.RSET_FWDONLY);moveToCurrentRow();","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/first()","rawLines":"public boolean first() throws SQLException {\r\n\t\ttry{\r\n\t\t\tif(st.rsType == ResultSet.TYPE_FORWARD_ONLY) throw SmallSQLException.create(Language.RSET_FWDONLY);\r\n            moveToCurrentRow();\r\n\t\t\treturn getCmd().first();\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/SSResultSet/afterLast()","rawLines":"public void afterLast() throws SQLException {\r\n\t\ttry{\r\n\t\t\tif(st.rsType == ResultSet.TYPE_FORWARD_ONLY) throw SmallSQLException.create(Language.RSET_FWDONLY);\r\n            moveToCurrentRow();\r\n            getCmd().afterLast();\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}","startLine":1,"lastLine":3}],"window":3},{"content":"case SQLTokenizer.NVARCHAR:case SQLTokenizer.BINARY:case SQLTokenizer.VARBINARY:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/getDataTypePrecision(int,int)","rawLines":"static int getDataTypePrecision(int dataType, int defaultValue){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.NULL:\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 1;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 5;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn 7;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 15;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\tif(defaultValue == -1)\r\n\t\t\t\t\treturn 0xFFFF;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                if(defaultValue == -1)\r\n                    return 38;\r\n                return defaultValue;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\treturn 23;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\treturn 8;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn 16;\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\treturn 36;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn Integer.MAX_VALUE;\r\n\t\t}\r\n\t\tif(defaultValue == -1)\r\n\t\t\tthrow new Error(\"Precision:\"+SQLTokenizer.getKeyWord(dataType));\r\n\t\treturn defaultValue;\r\n\t}","startLine":25,"lastLine":27},{"locFile":"java+method:///smallsql/database/SQLParser/datatype(boolean)","rawLines":"/**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }","startLine":54,"lastLine":56}],"window":3},{"content":"buf.append('-');formatNumber( details.year % 100, 2, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":151,"lastLine":153},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":82,"lastLine":84}],"window":3},{"content":"switch(dataType){case SQLTokenizer.BIT:case SQLTokenizer.BOOLEAN:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":16,"lastLine":18},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":66,"lastLine":68},{"locFile":"java+method:///smallsql/database/StoreImpl/getNumeric(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBigDecimal()\r\n     */\r\n    @Override\r\n    MutableNumeric getNumeric(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/ExpressionValue/getBoolean(java.lang.Object,int)","rawLines":"static boolean getBoolean(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return false;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj.equals(Boolean.TRUE));\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).intValue() != 0;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue() != 0;\r\n            default: return Utils.string2boolean( obj.toString() );\r\n        }\r\n    }","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getNumeric()","rawLines":"MutableNumeric getNumeric() throws java.lang.Exception {\r\n        if(isNull()) return null;\r\n        int dataType = getDataType();\t\t\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn new MutableNumeric(getBoolean() ? 1 : 0);\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn new MutableNumeric(getIntImpl());\r\n            case SQLTokenizer.BIGINT:\r\n                return new MutableNumeric(getLongImpl());\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return new MutableNumeric(getFloatImpl());\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n                return new MutableNumeric( getDoubleImpl() );\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return getNumericImpl();\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn new MutableNumeric(getMoneyImpl(),4);\r\n        }\r\n\t\tthrow createUnspportedConversion( SQLTokenizer.DOUBLE);\r\n    }","startLine":3,"lastLine":5},{"locFile":"java+method:///smallsql/database/StoreImpl/getBoolean(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBoolean()\r\n     */\r\n    @Override\r\n    boolean getBoolean(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return false;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean();\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() ) != 0;\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() != 0;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() != 0;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat() != 0;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble() != 0;\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().getSignum() != 0;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Utils.string2boolean( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Utils.string2boolean( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Utils.string2boolean( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() ) != 0;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp() != 0;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime() != 0;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate() != 0;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime() != 0;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                return false;\r\n\t\t\tdefault: \r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BOOLEAN\" });\r\n        }\r\n    }","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/StoreImpl/getObject(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getObject()\r\n     */\r\n    @Override\r\n    Object getObject(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n                    return Utils.getInteger( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return Utils.getInteger( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return Utils.getInteger(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue(readLong());\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME );\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE );\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getMoney()","rawLines":"long getMoney() throws java.lang.Exception {\r\n        if(isNull()) return 0;\r\n        int dataType = getDataType();\t\t\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl() * 10000;\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl() * 10000;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return Utils.doubleToMoney( getFloatImpl() );\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return Utils.doubleToMoney( getDoubleImpl() );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn getMoneyImpl();\r\n        }\r\n\t\tthrow createUnspportedConversion( SQLTokenizer.DOUBLE);\r\n    }","startLine":3,"lastLine":5},{"locFile":"java+method:///smallsql/database/StoreImpl/getMoney(int,int)","rawLines":"// is used for faster calculation\r\n    @Override\r\n    long getMoney( int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return (long)(Utils.bytes2double( readBinary() ) * 10000L);\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() * 10000L;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() * 10000L;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() * 10000L;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() * 10000L;\r\n            case SQLTokenizer.REAL:\r\n                    return (long)(readFloat() * 10000L);\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)(readDouble() * 10000L);\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return (long)(readNumeric().doubleValue() * 10000L);\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Money.parseMoney( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Money.parseMoney( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Money.parseMoney( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return (long)(Utils.bytes2double( readLongBinary() ) * 10000L);\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"MONEY\" });\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":5,"lastLine":7}],"window":3},{"content":"case SQLTokenizer.SMALLINT:case SQLTokenizer.INT:case SQLTokenizer.BIGINT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/getInt(java.lang.Object,int)","rawLines":"static int getInt(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n                return ((Number)obj).intValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn (int)((DateTime)obj).getTimeMillis();\r\n            default:\r\n\t\t\t\tString str = obj.toString().trim();\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Integer.parseInt( str );\r\n\t\t\t\t}catch(Throwable th){/* A NumberFormatException can occur if it a floating point number */}\r\n\t\t\t\treturn (int)Double.parseDouble( str );\r\n        }\r\n    }","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/isSignedDataType(int)","rawLines":"static boolean isSignedDataType(int dataType) {\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/database/ExpressionValue/getLong(java.lang.Object,int)","rawLines":"static long getLong(Object obj, int dataType) throws Exception{\r\n       if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).longValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: \r\n            \tString str = obj.toString();\r\n            \tif(str.indexOf('-') > 0 || str.indexOf(':') > 0)\r\n            \t\treturn DateTime.parse(str);\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Long.parseLong( str );\r\n\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\treturn (long)Double.parseDouble( str );\r\n\t\t\t\t}\r\n        }\r\n    }","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/ExpressionValue/getMoney(java.lang.Object,int)","rawLines":"static long getMoney(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                return (obj == Boolean.TRUE) ? 10000 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).longValue() * 10000;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                return Utils.doubleToMoney(((Number)obj).doubleValue());\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            \treturn ((Money)obj).value;\r\n            default: return Money.parseMoney( obj.toString() );\r\n        }\r\n\t}","startLine":6,"lastLine":8},{"locFile":"java+method:///smallsql/database/ExpressionValue/getBoolean(java.lang.Object,int)","rawLines":"static boolean getBoolean(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return false;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj.equals(Boolean.TRUE));\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).intValue() != 0;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue() != 0;\r\n            default: return Utils.string2boolean( obj.toString() );\r\n        }\r\n    }","startLine":7,"lastLine":9}],"window":3},{"content":"int length = param3.getInt();if(length < 0)throw SmallSQLException.create(Language.SUBSTR_INVALID_LEN, new Integer(length));","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionSubstring/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint byteLen = bytes.length;\r\n\t\tint start  = Math.min( Math.max( 0, param2.getInt() - 1), byteLen);\r\n\t\tint length = param3.getInt();\r\n\t\tif(length < 0) \r\n\t\t\tthrow SmallSQLException.create(Language.SUBSTR_INVALID_LEN, new Integer(length));\r\n\t\tif(start == 0 && byteLen == length) return bytes;\r\n\t\tif(byteLen > length + start){\r\n\t\t\tbyte[] b = new byte[length];\r\n\t\t\tSystem.arraycopy(bytes, start, b, 0, length);\r\n\t\t\treturn b;\t\t\r\n\t\t}else{\r\n\t\t\tbyte[] b = new byte[byteLen - start];\r\n\t\t\tSystem.arraycopy(bytes, start, b, 0, b.length);\r\n\t\t\treturn b;\t\t\r\n\t\t}\r\n\t}","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/database/ExpressionFunctionSubstring/getString()","rawLines":"final String getString() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\tString str = param1.getString();\r\n\t\tint strLen = str.length();\r\n\t\tint start  = Math.min( Math.max( 0, param2.getInt() - 1), strLen);\r\n\t\tint length = param3.getInt();\r\n\t\tif(length < 0) \r\n\t\t\tthrow SmallSQLException.create(Language.SUBSTR_INVALID_LEN, new Integer(length));\r\n\t\tlength = Math.min( length, strLen-start );\r\n\t\treturn str.substring(start, start+length);\r\n\t}","startLine":5,"lastLine":7}],"window":3},{"content":"switch(dataType){case SQLTokenizer.DECIMAL:case SQLTokenizer.NUMERIC:","cloneLocs":[{"locFile":"java+method:///smallsql/database/Column/getScale()","rawLines":"int getScale(){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\treturn scale;\r\n\t\t\tdefault:\r\n\t\t\t\treturn Expression.getScale(dataType);\r\n\t\t}\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getScale()","rawLines":"int getScale(){\r\n\t\tint dataType = getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\tswitch(operation){\r\n\t\t\t\t\tcase ADD:\r\n\t\t\t\t\tcase SUB:\r\n\t\t\t\t\t\treturn Math.max(left.getScale(), right.getScale());\r\n\t\t\t\t\tcase MUL:\r\n\t\t\t\t\t\treturn left.getScale() + right.getScale();\r\n\t\t\t\t\tcase DIV:\r\n\t\t\t\t\t\treturn Math.max(left.getScale()+5, right.getScale()+4);\r\n\t\t\t\t\tcase NEGATIVE:\r\n\t\t\t\t\t\treturn left.getScale();\r\n\t\t\t\t\tcase MOD:\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t}\r\n\t\treturn getScale(dataType);\r\n\t}","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/database/ExpressionValue/getScale()","rawLines":"int getScale(){\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\tMutableNumeric obj = getNumeric();\r\n\t\t\t\treturn (obj == null) ? 0: obj.getScale();\r\n\t\t\tdefault:\r\n\t\t\t\treturn getScale(dataType);\r\n\t\t}\r\n\t}","startLine":1,"lastLine":3}],"window":3},{"content":"try{Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRows(java.sql.Connection)","rawLines":"/**\r\n      *  7. Test\r\n      *  Update rows with the method updateRow().\r\n      */  \r\n    static void test_UpdateRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with updateRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            int colCount = rs.getMetaData().getColumnCount();\r\n            long time = -System.currentTimeMillis();\r\n            int count = 0;\r\n            while(rs.next()){\r\n                for (int i=2; i<=colCount; i++){\r\n                    rs.updateObject( i, rs.getObject(i) );\r\n                }\r\n                rs.updateRow();\r\n                count++;\r\n            }\r\n            time += System.currentTimeMillis();\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were updated.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\" + e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":8,"lastLine":10},{"locFile":"java+method:///smallsql/junit/BenchTest/test_InsertRows(java.sql.Connection)","rawLines":"/**\r\n      *  5. Test\r\n      *  Insert rows with the method insertRow().\r\n      */  \r\n    static void test_InsertRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n\t            rs.updateBytes (  \"bi\", byteArray );\r\n\t            rs.updateString(  \"c\" , \"Test\" );\r\n\t            rs.updateDate  (  \"d\" , new Date( System.currentTimeMillis() ) );\r\n\t            rs.updateFloat (  \"de\", (float)1234.56789 );\r\n\t            rs.updateFloat (  \"f\" , (float)9876.54321 );\r\n\t            rs.updateBytes (  \"im\", largeByteArray );\r\n\t            rs.updateInt   (  \"i\" , i );\r\n\t            rs.updateDouble(  \"m\" , 23.45 );\r\n\t            rs.updateDouble(  \"n\" , 567.45 );\r\n\t            rs.updateFloat (  \"r\" , (float)78.89 );\r\n\t            rs.updateTime  (  \"sd\", new Time( System.currentTimeMillis() ) );\r\n\t            rs.updateShort (  \"si\", (short)i );\r\n\t            rs.updateFloat (  \"sm\", (float)34.56 );\r\n\t            rs.updateString(  \"sy\", \"sysname (30) NULL\" );\r\n\t            rs.updateString(  \"t\" , \"ntext NULL, sample to save in the field\" );\r\n\t            rs.updateByte  (  \"ti\", (byte)i );\r\n\t            rs.updateBytes (  \"vb\", byteArray );\r\n\t            rs.updateString(  \"vc\", \"nvarchar (255) NULL\" );\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                  st.execute(\"DELETE FROM \" + tableName);\r\n                  System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            }else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n        \te.printStackTrace();\r\n            try{\r\n                // reset for the next test\r\n                Statement st = con.createStatement();\r\n                st.execute(\"DELETE FROM \" + tableName);\r\n                st.close();\r\n            }catch(Exception ee){/* ignore it */}\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":8,"lastLine":10}],"window":3},{"content":"final String getString() throws Exception {if(isNull()) return null;String str = param1.getString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionLeft/getString()","rawLines":"final String getString() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\tString str = param1.getString();\r\n\t\tint length = param2.getInt();\r\n\t\tlength = Math.min( length, str.length() );\r\n\t\treturn str.substring(0,length);\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionSubstring/getString()","rawLines":"final String getString() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\tString str = param1.getString();\r\n\t\tint strLen = str.length();\r\n\t\tint start  = Math.min( Math.max( 0, param2.getInt() - 1), strLen);\r\n\t\tint length = param3.getInt();\r\n\t\tif(length < 0) \r\n\t\t\tthrow SmallSQLException.create(Language.SUBSTR_INVALID_LEN, new Integer(length));\r\n\t\tlength = Math.min( length, strLen-start );\r\n\t\treturn str.substring(start, start+length);\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionRTrim/getString()","rawLines":"final String getString() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\tString str = param1.getString();\r\n        int length = str.length();\r\n        while(length>0 && str.charAt(length-1)==' '){\r\n            length--;\r\n        }\r\n\t\treturn str.substring(0,length);\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionInsert/getString()","rawLines":"final String getString() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\tString str = param1.getString();\r\n        int start  = Math.min(Math.max( 0, param2.getInt() - 1), str.length() );\r\n\t\tint length = Math.min(param3.getInt(), str.length() );\r\n        StringBuffer buffer = new StringBuffer();\r\n        buffer.append(str.substring(0,start));\r\n        buffer.append(param4.getString());\r\n        if(length < 0) \r\n            throw SmallSQLException.create(Language.INSERT_INVALID_LEN, new Integer(length));\r\n        buffer.append(str.substring(start+length));\r\n\t\treturn buffer.toString();\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionRight/getString()","rawLines":"final String getString() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\tString str = param1.getString();\r\n\t\tint length  = param2.getInt();\r\n\t\tint start = str.length() - Math.min( length, str.length() );\r\n\t\treturn str.substring(start);\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionRepeat/getString()","rawLines":"final String getString() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\tString str = param1.getString();\r\n        int count  = param2.getInt();\r\n        StringBuffer buffer = new StringBuffer();\r\n        for(int i=0; i<count; i++){\r\n            buffer.append(str);\r\n        }\r\n\t\treturn buffer.toString();\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/ExpressionFunctionLTrim/getString()","rawLines":"final String getString() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\tString str = param1.getString();\r\n        int start = 0;\r\n        while(start<str.length() && str.charAt(start)==' '){\r\n            start++;\r\n        }\r\n\t\treturn str.substring(start);\r\n\t}","startLine":0,"lastLine":2}],"window":3},{"content":"}break;default:","cloneLocs":[{"locFile":"java+method:///smallsql/database/CommandTable/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception{\r\n        Database database = catalog == null ? \r\n                con.getDatabase(false) : \r\n                Database.getDatabase( catalog, con, false );\r\n        switch(tableCommandType){\r\n        case SQLTokenizer.CREATE:\r\n            database.createTable( con, name, columns, indexes, foreignKeys );\r\n            break;\r\n        case SQLTokenizer.ADD:\r\n            con = new SSConnection(con);\r\n            //TODO disable the transaction to reduce memory use.\r\n            Table oldTable = (Table)database.getTableView( con, name);\r\n            \r\n            // Request a TableLock and hold it for the completely ALTER TABLE command\r\n            TableStorePage tableLock = oldTable.requestLock( con, SQLTokenizer.ALTER, -1);\r\n            String newName = \"#\" + System.currentTimeMillis() + this.hashCode();\r\n            try{\r\n                Columns oldColumns = oldTable.columns;\r\n                Columns newColumns = oldColumns.copy();\r\n                for(int i = 0; i < columns.size(); i++){\r\n                    addColumn(newColumns, columns.get(i));\r\n                }\r\n                \r\n                Table newTable = database.createTable( con, newName, newColumns, oldTable.indexes, indexes, foreignKeys );\r\n                StringBuffer buffer = new StringBuffer(256);\r\n                buffer.append(\"INSERT INTO \").append( newName ).append( '(' );\r\n                for(int c=0; c<oldColumns.size(); c++){\r\n                    if(c != 0){\r\n                        buffer.append( ',' );\r\n                    }\r\n                    buffer.append( oldColumns.get(c).getName() );\r\n                }\r\n                buffer.append( \")  SELECT * FROM \" ).append( name );\r\n                con.createStatement().execute( buffer.toString() );\r\n                \r\n                database.replaceTable( oldTable, newTable );\r\n            }catch(Exception ex){\r\n                //Remove all from the new table\r\n                try {\r\n                    database.dropTable(con, newName);\r\n                } catch (Exception ex1) {/* ignore it */}\r\n                try{\r\n                    indexes.drop(database);\r\n                } catch (Exception ex1) {/* ignore it */}\r\n                throw ex;\r\n            }finally{\r\n                tableLock.freeLock();\r\n            }\r\n            break;\r\n        default:\r\n            throw new Error();\r\n        }\r\n    }","startLine":47,"lastLine":49},{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":165,"lastLine":167}],"window":3},{"content":"assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");Savepoint savepoint = con.setSavepoint();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testUpdateAndSavepoint()","rawLines":"/**\r\n     * The difference to testInsertAndUpdate() is that the row was not inserted in the same transaction\r\n     */\r\n    public void testUpdateAndSavepoint() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        try{\r\n            con.createStatement().execute(\"Create Table transactions ( v varchar(20))\");\r\n            assertRowCount(0, \"Select * from transactions\");\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Insert Into transactions(v) Values('qwert')\"));\r\n            assertEqualsRsValue(\"qwert\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            // start the transaction after the row is already insert\r\n            con.setAutoCommit(false);\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert1'\"));\r\n            assertEqualsRsValue(\"qwert1\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert2'\"));\r\n            assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            Savepoint savepoint = con.setSavepoint();\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 3'\"));\r\n            assertEqualsRsValue(\"qwert 3\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 4'\"));\r\n            assertEqualsRsValue(\"qwert 4\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            assertEquals(1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 5'\"));\r\n            assertEqualsRsValue(\"qwert 5\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n            con.rollback(savepoint);\r\n\r\n            con.commit();\r\n            assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n        }finally{\r\n            dropTable(con, \"transactions\");\r\n            con.setAutoCommit(true);\r\n        }\r\n    }","startLine":20,"lastLine":23},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertAndUpdate()","rawLines":"/**\r\n     * Insert a row and update the inserted row in the same transaction. Then make a partial rollback. Test the correct\r\n     * status after of the table after every change of the database.\r\n     * \r\n     * @throws Exception\r\n     *             if an error occur\r\n     */\r\n\tpublic void testInsertAndUpdate() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions ( v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Insert Into transactions(v) Values('qwert')\") );\r\n\t\t\tassertEqualsRsValue(\"qwert\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t\t\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert1'\") );\r\n\t\t\tassertEqualsRsValue(\"qwert1\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t\t\r\n            assertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert2'\") );\r\n            assertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n            assertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n            \r\n\t\t\tSavepoint savepoint = con.setSavepoint();\r\n\t\t\t\r\n\t\t\tassertEquals( 1, con.createStatement().executeUpdate(\"Update transactions set v='qwert 3'\") );\r\n\t\t\tassertEqualsRsValue(\"qwert 3\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\r\n\t\t\tcon.rollback( savepoint );\r\n\t\t\t\r\n\t\t\tcon.commit();\r\n\t\t\tassertEqualsRsValue(\"qwert2\", \"Select * from transactions\");\r\n\t\t\tassertEqualsRsValue(new Integer(1), \"Select count(*) from transactions\");\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":23,"lastLine":26}],"window":3},{"content":"beforeFirst();return false;}else{","cloneLocs":[{"locFile":"java+method:///smallsql/database/Scrollable/absolute(int)","rawLines":"boolean absolute(int row) throws Exception{\r\n\t\tif(row == 0)\r\n\t\t\tthrow SmallSQLException.create(Language.ROW_0_ABSOLUTE);\r\n\t\tif(row < 0){\r\n\t\t\tafterLast();\r\n\t\t\trowIdx = rowList.size() + row;\r\n\t\t\tif(rowIdx < 0){\r\n\t\t\t\tbeforeFirst();\r\n\t\t\t\treturn false;\r\n\t\t\t}else{\r\n\t\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(row <= rowList.size()){\r\n\t\t\trowIdx = row-1;\r\n\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\trowIdx = rowList.size()-1;\r\n\t\tif(rowIdx >= 0)\r\n\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\tboolean result;\r\n\t\twhile((result = next()) && row-1 > rowIdx){/* scroll forward */}\r\n\t\treturn result;\r\n\t}","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/Scrollable/relative(int)","rawLines":"boolean relative(int rows) throws Exception{\r\n\t\tint newRow = rows + rowIdx + 1;\r\n\t\tif(newRow <= 0){\r\n\t\t\tbeforeFirst();\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn absolute(newRow);\r\n\t\t}\r\n\t}","startLine":3,"lastLine":5}],"window":3},{"content":"default:throw new Error();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/caseExpr(smallsql.database.Command)","rawLines":"ExpressionFunctionCase caseExpr(final Command cmd) throws SQLException{\r\n\t\tExpressionFunctionCase expr = new ExpressionFunctionCase();\r\n\t\tSQLToken token = nextToken(MISSING_EXPRESSION);\r\n\t\t\r\n\t\tExpression input = null;\r\n\t\tif(token.value != SQLTokenizer.WHEN){\r\n\t\t\t// simple CASE Syntax\r\n\t\t\tpreviousToken();\r\n\t\t\tinput = expression(cmd, 0);\r\n\t\t\ttoken = nextToken(MISSING_WHEN_ELSE_END);\r\n\t\t}\t\t\t\r\n\t\t\t\r\n\t\twhile(true){\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.WHEN:\t\t\t\t\r\n\t\t\t\t\tExpression condition = expression(cmd, 0);\r\n\t\t\t\t\tif(input != null){\r\n\t\t\t\t\t\t// simple CASE Syntax\r\n\t\t\t\t\t\tcondition = new ExpressionArithmetic( input, condition, ExpressionArithmetic.EQUALS);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken(MISSING_THEN);\r\n\t\t\t\t\tExpression result = expression(cmd, 0);\r\n\t\t\t\t\texpr.addCase(condition, result);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ELSE:\r\n\t\t\t\t\texpr.setElseResult(expression(cmd, 0));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.END:\r\n\t\t\t\t\texpr.setEnd();\r\n\t\t\t\t\treturn expr;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error();\r\n\t\t\t}\r\n\t\t\ttoken = nextToken(MISSING_WHEN_ELSE_END);\r\n\t\t}\r\n    }","startLine":30,"lastLine":32},{"locFile":"java+method:///smallsql/database/SQLParser/setTransaction()","rawLines":"private CommandSet setTransaction() throws SQLException{\r\n        SQLToken token = nextToken( MISSING_ISOLATION );\r\n        token = nextToken( MISSING_LEVEL );\r\n        token = nextToken( COMMANDS_TRANS_LEVEL );\r\n        CommandSet cmd = new CommandSet( con.log, SQLTokenizer.LEVEL );\r\n        switch(token.value){\r\n            case SQLTokenizer.READ:\r\n                token = nextToken( MISSING_COMM_UNCOMM );\r\n                switch(token.value){\r\n                    case SQLTokenizer.COMMITTED:\r\n                        cmd.isolationLevel = Connection.TRANSACTION_READ_COMMITTED;\r\n                        break;\r\n                    case SQLTokenizer.UNCOMMITTED:\r\n                        cmd.isolationLevel = Connection.TRANSACTION_READ_UNCOMMITTED;\r\n                        break;\r\n                    default:\r\n                        throw new Error();\r\n                }\r\n                return cmd;\r\n            case SQLTokenizer.REPEATABLE:\r\n                token = nextToken( MISSING_READ );\r\n                cmd.isolationLevel = Connection.TRANSACTION_REPEATABLE_READ;\r\n                return cmd;\r\n            case SQLTokenizer.SERIALIZABLE:\r\n                cmd.isolationLevel = Connection.TRANSACTION_SERIALIZABLE;\r\n                return cmd;\r\n            default:\r\n                throw new Error();\r\n        }\r\n\r\n\r\n    }","startLine":15,"lastLine":17},{"locFile":"java+method:///smallsql/database/Table/freeLock(smallsql.database.TableStorePage)","rawLines":"/**\r\n\t * Remove the lock from this table.\r\n\t */\r\n\tvoid freeLock(TableStorePage storePage){\r\n\t\tfinal int lockType = storePage.lockType;\r\n\t\tfinal long fileOffset = storePage.fileOffset;\r\n\t\tsynchronized(locks){\r\n\t\t\ttry{\r\n\t\t\t\tTableStorePage lock;\r\n\t\t\t\tTableStorePage prev;\r\n\t\t\t\tswitch(lockType){\r\n\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();\r\n\t\t\t\t}\r\n\t\t\t}finally{\r\n\t\t\t\tlocks.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":67,"lastLine":69}],"window":3},{"content":"}case SQLTokenizer.SQL_TSI_QUARTER:{DateTime.Details details2 = new DateTime.Details(param2.getLong());","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionTimestampAdd/getLong()","rawLines":"long getLong() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\tswitch(interval){\r\n\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong();\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 1000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 60000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 3600000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 86400000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 604800000;\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong() * 3;\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.year += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t\t// TODO Auto-generated method stub\r\n\t}","startLine":19,"lastLine":21},{"locFile":"java+method:///smallsql/database/ExpressionFunctionTimestampDiff/getInt()","rawLines":"int getInt() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\tswitch(interval){\r\n\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() - param1.getLong());\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() /1000 - param1.getLong() /1000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn (int)(param2.getLong() /60000 - param1.getLong() /60000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn (int)(param2.getLong() /3600000 - param1.getLong() /3600000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn (int)(param2.getLong() /86400000 - param1.getLong() /86400000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\tlong day2 = param2.getLong() /86400000;\r\n\t\t\t\tlong day1 = param1.getLong() /86400000;\r\n\t\t\t\t// the 1. Jan 1970 is a Thursday --> 3\r\n\t\t\t\treturn (int)((day2 + 3) / 7 - (day1 + 3) / 7);\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 12 + details2.month) - (details1.year * 12 + details1.month);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 4 + details2.month / 3) - (details1.year * 4 + details1.month / 3);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn details2.year - details1.year;\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":22,"lastLine":24}],"window":3},{"content":"byte[] b = new byte[length];System.arraycopy(bytes, start, b, 0, length);return b;","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionSubstring/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint byteLen = bytes.length;\r\n\t\tint start  = Math.min( Math.max( 0, param2.getInt() - 1), byteLen);\r\n\t\tint length = param3.getInt();\r\n\t\tif(length < 0) \r\n\t\t\tthrow SmallSQLException.create(Language.SUBSTR_INVALID_LEN, new Integer(length));\r\n\t\tif(start == 0 && byteLen == length) return bytes;\r\n\t\tif(byteLen > length + start){\r\n\t\t\tbyte[] b = new byte[length];\r\n\t\t\tSystem.arraycopy(bytes, start, b, 0, length);\r\n\t\t\treturn b;\t\t\r\n\t\t}else{\r\n\t\t\tbyte[] b = new byte[byteLen - start];\r\n\t\t\tSystem.arraycopy(bytes, start, b, 0, b.length);\r\n\t\t\treturn b;\t\t\r\n\t\t}\r\n\t}","startLine":10,"lastLine":12},{"locFile":"java+method:///smallsql/database/ExpressionFunctionLTrim/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n        int start = 0;\r\n        int length = bytes.length;\r\n        while(start<length && bytes[start]==0){\r\n            start++;\r\n        }\r\n        length -= start; \r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, start, b, 0, length);\r\n\t\treturn b;\t\t\r\n\t}","startLine":9,"lastLine":11}],"window":3},{"content":"}catch(SQLException ex){assertSQLException(\"01000\", 0, ex);}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testReadSerialized()","rawLines":"public void testReadSerialized() throws Exception{\r\n        Connection con1 = AllTests.getConnection();\r\n        Connection con2 = AllTests.createConnection();\r\n        try{        \r\n            con1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n            assertRowCount( 0, \"Select * from transactions\");\r\n            con1.createStatement().execute(\"Insert Into transactions(v) Values('qwert2')\");\r\n            assertRowCount( 1, \"Select * from transactions\");\r\n\r\n            con1.setTransactionIsolation( Connection.TRANSACTION_SERIALIZABLE );\r\n            con1.setAutoCommit(false);\r\n\r\n            //create a serialize lock on the table\r\n            ResultSet rs1 = con1.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n            assertTrue( rs1.next() );\r\n            assertEquals( \"Count(*)\", 1, rs1.getInt(1) );\r\n            \r\n            //reading should be possible on a second connection\r\n            ResultSet rs2 = con2.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n            assertTrue( rs2.next() );\r\n            assertEquals( \"Count(*)\", 1, rs2.getInt(1) );\r\n            try{\r\n                con2.createStatement().execute(\"Insert Into transactions(v) Values('qwert3')\");\r\n                fail(\"TRANSACTION_SERIALIZABLE does not lock the table\");\r\n            }catch(SQLException ex){\r\n                assertSQLException(\"01000\", 0, ex);\r\n            }\r\n        }finally{\r\n            con2.close();\r\n            dropTable(con1, \"transactions\");\r\n            con1.setAutoCommit(true);\r\n        }\r\n    }","startLine":24,"lastLine":26},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":9,"lastLine":11},{"locFile":"java+method:///smallsql/junit/TestStatement/testMoreResults()","rawLines":"public void testMoreResults() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        \r\n        ResultSet rs = st.executeQuery(\"Select * From statement\");\r\n        assertEquals( \"getResultSet()\", rs, st.getResultSet() );\r\n        assertEquals( \"getUpdateCount()\", -1, st.getUpdateCount() );\r\n        assertFalse( st.getMoreResults() );\r\n        try{\r\n            rs.next();\r\n            fail(\"ResultSet should be closed\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertNull( \"getResultSet()\", st.getResultSet() );\r\n        assertEquals( \"getUpdateCount()\", -1, st.getUpdateCount() );\r\n        \r\n        \r\n        rs = st.executeQuery(\"Select * From statement\");\r\n        assertEquals( \"getResultSet()\", rs, st.getResultSet() );\r\n        assertEquals( \"getUpdateCount()\", -1, st.getUpdateCount() );\r\n        assertFalse( st.getMoreResults(Statement.KEEP_CURRENT_RESULT) );\r\n        assertTrue(rs.next());\r\n        assertNull( \"getResultSet()\", st.getResultSet() );\r\n        assertEquals( \"getUpdateCount()\", -1, st.getUpdateCount() );\r\n        \r\n        \r\n        int count = st.executeUpdate(\"Update statement set c = c\");\r\n        assertTrue( \"Update Erfolgreich\", count>0 );\r\n        assertNull( \"getResultSet()\", st.getResultSet() );\r\n        assertEquals( \"getUpdateCount()\", count, st.getUpdateCount() );\r\n        assertFalse( st.getMoreResults() );\r\n        assertNull( \"getResultSet()\", st.getResultSet() );\r\n        assertEquals( \"getUpdateCount()\", -1, st.getUpdateCount() );\r\n    }","startLine":11,"lastLine":13},{"locFile":"java+method:///smallsql/junit/TestTransactions/testReadWriteLock()","rawLines":"public void testReadWriteLock() throws Exception{\r\n\t\tConnection con1 = AllTests.getConnection();\r\n\t\tConnection con2 = AllTests.createConnection();\r\n\t\ttry{\t\t\r\n\t\t\tcon1.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tcon1.createStatement().execute(\"Insert Into transactions(v) Values('qwert1')\");\r\n\r\n\t\t\tcon1.setAutoCommit(false);\r\n\t\t\tcon1.createStatement().execute(\"Update transactions Set v = 'qwert'\");\r\n\t\t\t\r\n\t\t\tlong time = System.currentTimeMillis();\r\n\t\t\ttry{\r\n\t\t\t\tcon2.createStatement().executeQuery(\"Select count(*) from transactions\");\r\n\t\t\t}catch(SQLException ex){\r\n\t\t\t    assertSQLException(\"01000\", 0, ex);\r\n\t\t\t}\t\t\r\n\t\t\tassertTrue(\"Wait time to small\", System.currentTimeMillis()-time>=5000);\r\n\t\t}finally{\r\n\t\t    con2.close();\r\n\t\t\tcon1.setAutoCommit(true);\r\n\t\t\tdropTable(con1, \"transactions\");\r\n\t\t}\r\n\t}","startLine":13,"lastLine":15},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":9,"lastLine":11}],"window":3},{"content":"rowSource.setRowPosition( insertedRows.get( currentInsertedRow() ) );return true;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SortedResult/previous()","rawLines":"boolean previous() throws Exception{\r\n        if(useSetRowPosition) throw SmallSQLException.create(Language.ORDERBY_INTERNAL);\r\n        if(currentInsertedRow() == 0){\r\n            scrollStatus.afterLast();\r\n        }\r\n        row--;\r\n        if(currentInsertedRow() >= 0){\r\n            rowSource.setRowPosition( insertedRows.get( currentInsertedRow() ) );\r\n            return true;\r\n        }\r\n        long rowPosition = scrollStatus.getRowOffset(false);\r\n        if(rowPosition >= 0){\r\n            rowSource.setRowPosition( rowPosition );\r\n            return true;\r\n        }else{\r\n            rowSource.noRow();\r\n            row = 0;\r\n            return false;\r\n        }\r\n    }","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/SortedResult/next()","rawLines":"boolean next() throws Exception {\r\n\t\tif(useSetRowPosition) throw SmallSQLException.create(Language.ORDERBY_INTERNAL);\r\n        if(currentInsertedRow() < 0){\r\n    \t\tlong rowPosition = scrollStatus.getRowOffset(true);\r\n    \t\tif(rowPosition >= 0){\r\n                row++;\r\n    \t\t\trowSource.setRowPosition( rowPosition );\r\n    \t\t\treturn true;\r\n    \t\t}\r\n        }\r\n        if(currentInsertedRow() < insertedRows.size()-1){\r\n            row++;\r\n            rowSource.setRowPosition( insertedRows.get( currentInsertedRow() ) );\r\n            return true;\r\n        }\r\n        if(lastRowOffset >= 0){\r\n            rowSource.setRowPosition( lastRowOffset );\r\n        }else{\r\n            rowSource.beforeFirst();\r\n        }\r\n        if(rowSource.next()){\r\n            row++;\r\n            lastRowOffset = rowSource.getRowPosition();\r\n            insertedRows.add( lastRowOffset );\r\n            return true;\r\n        }\r\n        rowSource.noRow();\r\n        row = (getRowCount() > 0) ? getRowCount() + 1 : 0;\r\n\t\treturn false;\r\n\t}","startLine":12,"lastLine":14}],"window":3},{"content":"}case SQLTokenizer.SQL_TSI_YEAR:{DateTime.Details details2 = new DateTime.Details(param2.getLong());","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionTimestampAdd/getLong()","rawLines":"long getLong() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\tswitch(interval){\r\n\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong();\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 1000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 60000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 3600000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 86400000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 604800000;\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong() * 3;\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.year += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t\t// TODO Auto-generated method stub\r\n\t}","startLine":24,"lastLine":26},{"locFile":"java+method:///smallsql/database/ExpressionFunctionTimestampDiff/getInt()","rawLines":"int getInt() throws Exception {\r\n\t\tif(isNull()) return 0;\r\n\t\tswitch(interval){\r\n\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() - param1.getLong());\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() /1000 - param1.getLong() /1000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn (int)(param2.getLong() /60000 - param1.getLong() /60000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn (int)(param2.getLong() /3600000 - param1.getLong() /3600000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn (int)(param2.getLong() /86400000 - param1.getLong() /86400000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\tlong day2 = param2.getLong() /86400000;\r\n\t\t\t\tlong day1 = param1.getLong() /86400000;\r\n\t\t\t\t// the 1. Jan 1970 is a Thursday --> 3\r\n\t\t\t\treturn (int)((day2 + 3) / 7 - (day1 + 3) / 7);\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 12 + details2.month) - (details1.year * 12 + details1.month);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 4 + details2.month / 3) - (details1.year * 4 + details1.month / 3);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn details2.year - details1.year;\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":27,"lastLine":29}],"window":3},{"content":"}catch(Exception e){throw createSyntaxError(token, MISSING_NUMBERVALUE );}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/datatype(boolean)","rawLines":"/**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }","startLine":68,"lastLine":70},{"locFile":"java+method:///smallsql/database/SQLParser/datatype(boolean)","rawLines":"/**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }","startLine":93,"lastLine":95},{"locFile":"java+method:///smallsql/database/SQLParser/datatype(boolean)","rawLines":"/**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }","startLine":103,"lastLine":105}],"window":3},{"content":"case SQLTokenizer.JAVA_OBJECT:ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());ObjectInputStream ois = new ObjectInputStream(bais);","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/getObject(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getObject()\r\n     */\r\n    @Override\r\n    Object getObject(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n                    return Utils.getInteger( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return Utils.getInteger( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return Utils.getInteger(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue(readLong());\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME );\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE );\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":44,"lastLine":46},{"locFile":"java+method:///smallsql/database/StoreImpl/getInt(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getInt()\r\n     */\r\n    @Override\r\n    int getInt(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return (int)readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (int)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (int)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n            \t\tlong longValue = readLong() / 10000;\r\n            \t\treturn Utils.money2int(longValue);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().intValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Integer.parseInt( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Integer.parseInt( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getInt(ois.readObject().toString(), SQLTokenizer.VARCHAR);\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn (int)readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn (int)readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn (int)readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn (int)readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"INT\" });\r\n        }\r\n    }","startLine":45,"lastLine":47},{"locFile":"java+method:///smallsql/database/StoreImpl/getBoolean(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBoolean()\r\n     */\r\n    @Override\r\n    boolean getBoolean(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return false;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean();\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() ) != 0;\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() != 0;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() != 0;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat() != 0;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble() != 0;\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().getSignum() != 0;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Utils.string2boolean( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Utils.string2boolean( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Utils.string2boolean( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() ) != 0;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp() != 0;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime() != 0;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate() != 0;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime() != 0;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                return false;\r\n\t\t\tdefault: \r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BOOLEAN\" });\r\n        }\r\n    }","startLine":44,"lastLine":46},{"locFile":"java+method:///smallsql/database/StoreImpl/getFloat(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getFloat()\r\n     */\r\n    @Override\r\n    float getFloat(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2float( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (float)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / (float)10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / (float)10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().floatValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Float.parseFloat( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Float.parseFloat( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Float.parseFloat( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2float( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"REAL\" });\r\n        }\r\n    }","startLine":44,"lastLine":46},{"locFile":"java+method:///smallsql/database/StoreImpl/getMoney(int,int)","rawLines":"// is used for faster calculation\r\n    @Override\r\n    long getMoney( int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return (long)(Utils.bytes2double( readBinary() ) * 10000L);\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() * 10000L;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() * 10000L;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() * 10000L;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() * 10000L;\r\n            case SQLTokenizer.REAL:\r\n                    return (long)(readFloat() * 10000L);\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)(readDouble() * 10000L);\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return (long)(readNumeric().doubleValue() * 10000L);\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Money.parseMoney( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Money.parseMoney( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Money.parseMoney( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return (long)(Utils.bytes2double( readLongBinary() ) * 10000L);\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"MONEY\" });\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":42,"lastLine":44},{"locFile":"java+method:///smallsql/database/StoreImpl/getDouble(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getDouble()\r\n     */\r\n    @Override\r\n    double getDouble(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2double( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().doubleValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Double.parseDouble( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Double.parseDouble( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Double.parseDouble( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2double( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n        }\r\n    }","startLine":44,"lastLine":46},{"locFile":"java+method:///smallsql/database/StoreImpl/getNumeric(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getBigDecimal()\r\n     */\r\n    @Override\r\n    MutableNumeric getNumeric(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":44,"lastLine":46},{"locFile":"java+method:///smallsql/database/StoreImpl/getString(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getString()\r\n     */\r\n    @Override\r\n    String getString( int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return null;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                    return readBoolean() ? \"1\" : \"0\";\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return String.valueOf( readBoolean() );\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2hex( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return String.valueOf( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return String.valueOf( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return String.valueOf( readInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return String.valueOf( readLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return String.valueOf( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return String.valueOf( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue( readLong() ).toString();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( readInt() ).toString();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toString();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject().toString();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2hex( readLongBinary() );\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME ).toString();\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE ).toString();\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();\r\n        }\r\n    }","startLine":45,"lastLine":47},{"locFile":"java+method:///smallsql/database/StoreImpl/getLong(int,int)","rawLines":"/**\r\n     * It used for ResultSet.getLong()\r\n     */\r\n    @Override\r\n    long getLong(int valueOffset, int dataType) throws Exception{\r\n        this.offset = valueOffset;\r\n        if(readBoolean()) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2long( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (long)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().longValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Long.parseLong( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Long.parseLong( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getLong( ois.readObject().toString(), SQLTokenizer.VARCHAR );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2long( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BIGINT\" });\r\n        }\r\n    }","startLine":44,"lastLine":46}],"window":3},{"content":"Expression expr = getValue(columnIndex);wasNull = expr.isNull();if(wasNull) return null;","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getTime(int)","rawLines":"public Time getTime(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTime( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSResultSet/getTimestamp(int,java.util.Calendar)","rawLines":"public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getTimestamp(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Timestamp(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/getURL(int)","rawLines":"public URL getURL(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new URL( expr.getString() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSResultSet/getTimestamp(int)","rawLines":"public Timestamp getTimestamp(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTimestamp( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/database/SSResultSet/getTime(int,java.util.Calendar)","rawLines":"public Time getTime(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getTime(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Time(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/getDate(int,java.util.Calendar)","rawLines":"public Date getDate(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getDate(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Date(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/database/SSResultSet/getDate(int)","rawLines":"public Date getDate(int columnIndex) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getDate( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":2,"lastLine":4}],"window":3},{"content":"rs.moveToInsertRow();rs.updateString(\"v\", \"qwert2\");rs.insertRow();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_withWrongWhere()","rawLines":"/**\r\n     * If there was insert a row within the ResultSet that not map WHERE than you scroll to this row. If there an Insert\r\n     * outsite the ResultSet that not map the WHERE then you can't scroll this row.\r\n     * \r\n     * @throws Exception\r\n     */\r\n\tpublic void testInsertRow_withWrongWhere() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.setAutoCommit(false);\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t\tcon.setAutoCommit(true);\r\n\t\t}\r\n\t}","startLine":18,"lastLine":20},{"locFile":"java+method:///smallsql/junit/TestTransactions/testInsertRow_Last(java.sql.Connection,boolean)","rawLines":"private void testInsertRow_Last(Connection con, boolean callLastBefore) throws Exception{\r\n\t\ttry{\t\t\t\r\n\t\t\tcon.createStatement().execute(\"Create Table transactions (i int identity, v varchar(20))\");\r\n\t\t\tassertRowCount( 0, \"Select * from transactions\");\r\n\r\n\t\t\tcon.createStatement().execute(\"Insert Into transactions(v) Values('qwert')\");\r\n\r\n\t\t\tResultSet rs = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)\r\n\t\t\t\t\t\t\t\t.executeQuery(\"Select * from transactions Where 1=0\");\r\n\t\t\t\r\n\t\t\tif(callLastBefore) rs.last();\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateString(\"v\", \"qwert2\");\r\n\t\t\trs.insertRow();\r\n\t\t\t\r\n\t\t\trs.last();\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\t\t\tassertTrue( rs.previous() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\t\r\n\t\t\trs.beforeFirst();\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\tassertEquals(\"qwert2\", rs.getString(\"v\"));\r\n\t\t\tassertFalse( rs.next() );\r\n\r\n\t\t}finally{\r\n\t\t\ttry{\r\n\t\t\t\tcon.createStatement().execute(\"Drop Table transactions\");\r\n\t\t\t}catch(Throwable e){e.printStackTrace();}\r\n\t\t}\r\n\t}","startLine":11,"lastLine":13}],"window":3},{"content":"assertNotNull(\"RETURN_GENERATED_KEYS\", rs);assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());assertRowCount(1,rs);","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":34,"lastLine":36},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":35,"lastLine":37},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":47,"lastLine":49},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeysWithPrepare()","rawLines":"public void testGeneratedKeysWithPrepare() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        ResultSet rs;\r\n        \r\n        PreparedStatement pr = con.prepareStatement(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        pr.execute();\r\n        try{\r\n            pr.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, pr.getUpdateCount());\r\n        assertNull(\"getResultSet\", pr.getResultSet());\r\n        pr.close();\r\n        \r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS);\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key5')\", new int[]{2});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        pr.execute();\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        pr = con.prepareStatement(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"});\r\n        assertEquals(1,pr.executeUpdate());\r\n        rs = pr.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":50,"lastLine":52}],"window":3},{"content":"long temp = 0;int v1 = value.length;for(int v2 = val2.length; v2>0; ){","cloneLocs":[{"locFile":"java+method:///smallsql/database/MutableNumeric/add(int%5B%5D)","rawLines":"/**\r\n     * Add the value to the current MutableNumeric Object and change it.\r\n     * The parameter <code>val2</code> has a shorter or equals length.\r\n     * The signum of both values is equals.\r\n     * @param val2 the added value\r\n     */\r\n    private void add( int[] val2){\r\n        long temp = 0;\r\n        int v1 = value.length;\r\n        for(int v2 = val2.length; v2>0; ){\r\n            temp = (value[--v1] & 0xFFFFFFFFL) + (val2 [--v2] & 0xFFFFFFFFL) + (temp >>> 32);\r\n            value[v1] = (int)temp;\r\n        }\r\n        boolean uebertrag = (temp >>> 32) != 0;\r\n        while(v1 > 0 && uebertrag)\r\n            uebertrag = (value[--v1] = value[v1] + 1) == 0;\r\n\r\n        // resize if needed\r\n        if(uebertrag){\r\n\t\t\tresizeValue(1);\r\n        }\r\n    }","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/MutableNumeric/sub(int%5B%5D)","rawLines":"/**\r\n     * Subtract the value to the current MutableNumeric Object and change it.\r\n     * The parameter <code>val2</code> has a shorter or equals length.\r\n     * The signum of both values is equals.\r\n     * @param val2 the subtracted  value\r\n     */\r\n    private void sub(int[] val2){\r\n        long temp = 0;\r\n        int v1 = value.length;\r\n        for(int v2 = val2.length; v2>0; ){\r\n            temp = (value[--v1] & 0xFFFFFFFFL) - (val2 [--v2] & 0xFFFFFFFFL) + (temp >>>= 32);\r\n            value[v1] = (int)temp;\r\n        }\r\n\r\n        boolean uebertrag = (temp >>> 32) != 0;\r\n        while(v1 > 0 && uebertrag)\r\n            uebertrag = (value[--v1] = value[v1] - 1) == -1;\r\n\r\n        if(uebertrag){\r\n            signum = -signum;\r\n            int last = value.length-1;\r\n            for(int i=0; i<=last; i++){\r\n                value[i] = (i == last) ? -value[i] : ~value[i];\r\n            }\r\n        }\r\n    }","startLine":7,"lastLine":9}],"window":3},{"content":"case SQLTokenizer.CHAR:case SQLTokenizer.NCHAR:case SQLTokenizer.BINARY:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/convertExpressionIfNeeded(smallsql.database.Expression,smallsql.database.Expression)","rawLines":"private Expression convertExpressionIfNeeded( Expression expr, Expression other ){\r\n        if(expr == null || other == null){\r\n            return expr;\r\n        }\r\n        switch(expr.getDataType()){\r\n        case SQLTokenizer.CHAR:\r\n        case SQLTokenizer.NCHAR:\r\n        case SQLTokenizer.BINARY:\r\n            switch(other.getDataType()){\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CLOB:\r\n            case SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.VARBINARY:\r\n                ExpressionFunctionRTrim trim = new ExpressionFunctionRTrim();\r\n                trim.setParams(new Expression[]{expr});\r\n                return trim;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.BINARY:\r\n                if(other.getPrecision() > expr.getPrecision()){\r\n                    return new ExpressionFunctionConvert(new ColumnExpression(other), expr, null );\r\n                }\r\n                break; \r\n            }\r\n            break;\r\n        }\r\n        return expr;\r\n    }","startLine":19,"lastLine":21},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/convertExpressionIfNeeded(smallsql.database.Expression,smallsql.database.Expression)","rawLines":"private Expression convertExpressionIfNeeded( Expression expr, Expression other ){\r\n        if(expr == null || other == null){\r\n            return expr;\r\n        }\r\n        switch(expr.getDataType()){\r\n        case SQLTokenizer.CHAR:\r\n        case SQLTokenizer.NCHAR:\r\n        case SQLTokenizer.BINARY:\r\n            switch(other.getDataType()){\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CLOB:\r\n            case SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.VARBINARY:\r\n                ExpressionFunctionRTrim trim = new ExpressionFunctionRTrim();\r\n                trim.setParams(new Expression[]{expr});\r\n                return trim;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.BINARY:\r\n                if(other.getPrecision() > expr.getPrecision()){\r\n                    return new ExpressionFunctionConvert(new ColumnExpression(other), expr, null );\r\n                }\r\n                break; \r\n            }\r\n            break;\r\n        }\r\n        return expr;\r\n    }","startLine":5,"lastLine":7}],"window":3},{"content":"break;case SQLTokenizer.NCHAR:case SQLTokenizer.CHAR:","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":45,"lastLine":47},{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.IndexNode,smallsql.database.Expression,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}","startLine":52,"lastLine":54}],"window":3},{"content":"@Overridevoid writeMagic(FileChannel raFile) throws Exception{ByteBuffer buffer = ByteBuffer.allocate(8);","cloneLocs":[{"locFile":"java+method:///smallsql/database/View/writeMagic(java.nio.channels.FileChannel)","rawLines":"@Override\r\n    void writeMagic(FileChannel raFile) throws Exception{\r\n        ByteBuffer buffer = ByteBuffer.allocate(8);\r\n        buffer.putInt(MAGIC_VIEW);\r\n        buffer.putInt(TABLE_VIEW_VERSION);\r\n        buffer.position(0);\r\n        raFile.write(buffer);\r\n\t}","startLine":0,"lastLine":2},{"locFile":"java+method:///smallsql/database/Table/writeMagic(java.nio.channels.FileChannel)","rawLines":"@Override\r\n    void writeMagic(FileChannel raFile) throws Exception{\r\n        ByteBuffer buffer = ByteBuffer.allocate(8);\r\n        buffer.putInt(MAGIC_TABLE);\r\n        buffer.putInt(TABLE_VIEW_VERSION);\r\n        buffer.position(0);\r\n        raFile.write(buffer);\r\n\t}","startLine":0,"lastLine":2}],"window":3},{"content":"super(FUNCTION);this.left   = left;this.right  = right;","cloneLocs":[{"locFile":"java+constructor:///smallsql/database/ExpressionArithmetic/ExpressionArithmetic(smallsql.database.Expression,smallsql.database.Expression,int)","rawLines":"ExpressionArithmetic( Expression left, Expression right, int operation){\r\n\t\tsuper(FUNCTION);\r\n        this.left   = left;\r\n        this.right  = right;\r\n        this.operation = operation;\r\n        super.setParams( new Expression[]{ left, right });\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+constructor:///smallsql/database/ExpressionArithmetic/ExpressionArithmetic(smallsql.database.Expression,smallsql.database.Expression,smallsql.database.Expression,int)","rawLines":"/**\r\n     * Constructor for BETWEEN\r\n     */\r\n    ExpressionArithmetic( Expression left, Expression right, Expression right2, int operation){\r\n\t\tsuper(FUNCTION);\r\n        this.left   = left;\r\n        this.right  = right;\r\n        this.right2 = right2;\r\n        this.operation = operation;\r\n        super.setParams( new Expression[]{ left, right, right2 });\r\n    }","startLine":4,"lastLine":6}],"window":3},{"content":"locks.put( pageKey, lock );}con.add(lock);","cloneLocs":[{"locFile":"java+method:///smallsql/database/Table/requestWriteLock(smallsql.database.SSConnection,smallsql.database.TableStorePage)","rawLines":"/**\r\n\t * Request a write lock for a page that is read. It add the resulting StorePage to the list of commits.\r\n     * @throws SQLException\r\n     *             if the connection was closed.\r\n\t */\r\n\tTableStorePage requestWriteLock(SSConnection con, TableStorePage readlock) throws SQLException{\r\n\t\tif(readlock.lockType == LOCK_INSERT){\r\n\t\t\tTableStorePage lock = new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\treadlock.nextLock = lock;\r\n\t\t\tcon.add(lock);\r\n\t\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t\t}\r\n\t\tLong pageKey = new Long(readlock.fileOffset); //TODO performance\r\n\t\tTableStorePage prevLock = null;\r\n\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\twhile(lock != null){\r\n\t\t\tif(lock.con != con) return null; // there is already any lock from another connection, we can not start write\r\n\t\t\tif(lock.lockType < LOCK_WRITE){\r\n\t\t\t\t// if there is only a read lock we can transfer it\r\n\t\t\t\t// this is required for rollback to a savepoint\r\n\t\t\t\tlock.lockType = LOCK_WRITE;\r\n\t\t\t\treturn lock;\r\n\t\t\t}\r\n\t\t\tprevLock = lock;\r\n\t\t\tlock = lock.nextLock;\r\n\t\t}\r\n\t\tlock = new TableStorePage( con, this, LOCK_WRITE, readlock.fileOffset);\r\n\t\tif(prevLock != null){\r\n\t\t    prevLock.nextLock = lock;\r\n\t\t} else {\r\n\t\t    locks.put( pageKey, lock );\r\n\t\t}\r\n\t\tcon.add(lock);\r\n\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t}","startLine":30,"lastLine":32},{"locFile":"java+method:///smallsql/database/Table/requestLockImpl(smallsql.database.SSConnection,int,long)","rawLines":"/**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * In the other case it return null.\r\n     * @param page The fileOffset or -1 for a new page\r\n     * @throws SQLException \r\n     */\r\n\tfinal private TableStorePage requestLockImpl(SSConnection con, int pageOperation, long page) throws SQLException{\r\n\t\tsynchronized(locks){\r\n\t\t\tif(tabLockConnection != null && tabLockConnection != con) return null;\r\n\t\t\tswitch(con.isolationLevel){\r\n\t\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\t\tserializeConnections.put( con, con);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tswitch(pageOperation){\r\n\t\t\t\tcase SQLTokenizer.CREATE:{\r\n\t\t\t\t\t\t// first check if another connection has a lock before creating a table lock\r\n\t\t\t\t\t\tif(locks.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\t//the first StorePage in the linked list must be ever TableStorePageInsert\r\n\t\t\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttabLockConnection = con;\r\n\t\t\t\t\t\ttabLockCount++;\r\n\t\t\t\t\t\tTableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n                case SQLTokenizer.ALTER:{\r\n                    // first check if there is any lock before creating a table lock\r\n                    if(locks.size() > 0 || locksInsert.size() > 0){\r\n                        return null;\r\n                    }\r\n                    if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }\r\n                    tabLockConnection = con;\r\n                    tabLockCount++;\r\n                    TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n                    lock.rollback();\r\n                    return lock;\r\n                }\r\n\t\t\t\tcase SQLTokenizer.INSERT:{\r\n\t\t\t\t\t\t// if there are more as one Connection with a serializable lock then an INSERT is not valid\r\n\t\t\t\t\t\tif(serializeConnections.size() > 1) return null;\r\n\t\t\t\t\t\tif(serializeConnections.size() == 1 && serializeConnections.get(con) == null) return null;\r\n\t\t\t\t\t\tTableStorePageInsert lock = new TableStorePageInsert(con, this, LOCK_INSERT);\r\n\t\t\t\t\t\tlocksInsert.add( lock );\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.SELECT:\r\n\t\t\t\tcase SQLTokenizer.UPDATE:{\r\n\t\t\t\t\t\tLong pageKey = new Long(page); //TODO performance\r\n\t\t\t\t\t\tTableStorePage prevLock = null;\r\n\t\t\t\t\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tTableStorePage usableLock = null;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock.con == con || \r\n\t\t\t\t\t\t\t   con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\t\t\t\t    usableLock = lock;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t    if(lock.lockType == LOCK_WRITE){\r\n\t\t\t\t\t\t\t        return null; // write lock of another Connection\r\n\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprevLock = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(usableLock != null){\r\n\t\t\t\t\t\t    return usableLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlock = new TableStorePage( con, this, LOCK_NONE, page);\r\n\t\t\t\t\t\tif(con.isolationLevel >= Connection.TRANSACTION_REPEATABLE_READ || pageOperation == SQLTokenizer.UPDATE){\r\n\t\t\t\t\t\t\tlock.lockType = pageOperation == SQLTokenizer.UPDATE ? LOCK_WRITE : LOCK_READ;\r\n\t\t\t\t\t\t\tif(prevLock != null){\r\n\t\t\t\t\t\t\t    prevLock.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t    locks.put( pageKey, lock );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lock;\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t// is used for written BLOB and CLOB\r\n\t\t\t\t\t// the difference to INSERT is that page described the size of the byte buffer\r\n\t\t\t\t\treturn new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"pageOperation:\"+pageOperation);\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":97,"lastLine":99}],"window":3},{"content":"}}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/CommandSelect/updateRow(smallsql.database.SSConnection,smallsql.database.Expression%5B%5D)","rawLines":"final void updateRow(SSConnection con, Expression[] newRowSources) throws SQLException{\r\n\t\tint savepoint = con.getSavepoint();\r\n\t\ttry{\r\n\t\t\t//loop through all tables of this ResultSet \r\n\t\t\tfor(int t=0; t<tables.size(); t++){\r\n\t\t\t\tTableViewResult result = TableViewResult.getTableViewResult( tables.get(t) );\r\n\t\t\t\tTableView table = result.getTableView();\r\n\t\t\t\tColumns tableColumns = table.columns;\r\n\t\t\t\tint count = tableColumns.size();\r\n\t\t\t\t\r\n\t\t\t\t// order the new Values after it position in the table\r\n\t\t\t\tExpression[] updateValues = new Expression[count];\r\n\t\t\t\tboolean isUpdateNeeded = false;\r\n\t\t\t\tfor(int i=0; i<columnExpressions.size(); i++){\r\n\t\t\t\t\tExpression src = newRowSources[i];\r\n\t\t\t\t\tif(src != null && (!(src instanceof ExpressionValue) || !((ExpressionValue)src).isEmpty())){\t\r\n\t\t\t\t\t\tExpression col = columnExpressions.get(i);\r\n\t\t\t\t\t\tif(!col.isDefinitelyWritable())\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.COL_READONLY, new Integer(i));\r\n\t\t\t\t\t\tExpressionName exp = (ExpressionName)col;\r\n\t\t\t\t\t\tif(table == exp.getTable()){\r\n\t\t\t\t\t\t\tupdateValues[exp.getColumnIndex()] = src;\r\n\t\t\t\t\t\t\tisUpdateNeeded = true;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// save the new values if there are new value for this table\r\n\t\t\t\tif(isUpdateNeeded){\r\n\t\t\t\t\tresult.updateRow(updateValues);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}catch(Throwable e){\r\n\t\t\tcon.rollback(savepoint);\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}finally{\r\n\t\t\tif(con.getAutoCommit()) con.commit();\r\n\t\t}\r\n\t}","startLine":24,"lastLine":26},{"locFile":"java+method:///smallsql/database/CommandInsert/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception {\r\n        // on first time and on change of the table we need to recompile\r\n        if(table == null || tableTimestamp != table.getTimestamp()) compile( con );\r\n\r\n\t\tfinal IndexDescriptions indexes = table.indexes;\r\n\t\t\r\n\t\tupdateCount = 0;\r\n\t\tcmdSel.from.execute();\r\n\t\tcmdSel.beforeFirst();\r\n        \r\n        //Variables for GeneratedKeys\r\n        Strings keyColumnNames = null;\r\n        ArrayList keys = null;\r\n        boolean needGeneratedKeys = st.needGeneratedKeys();\r\n        int generatedKeysType = 0;\r\n\r\n        while(cmdSel.next()){\r\n            if(needGeneratedKeys){\r\n                keyColumnNames = new Strings();\r\n                keys = new ArrayList();\r\n                if(st.getGeneratedKeyNames() != null)\r\n                    generatedKeysType = 1;\r\n                if(st.getGeneratedKeyIndexes() != null)\r\n                    generatedKeysType = 2;\r\n            }\r\n\t        StoreImpl store = table.getStoreInsert( con );\r\n\t        for(int c=0; c<matrix.length; c++){\r\n\t            Column column = table.columns.get(c);\r\n\t            int idx = matrix[c];\r\n\t            Expression valueExpress;\r\n                if(idx >= 0){\r\n                    valueExpress = cmdSel.columnExpressions.get(idx);\r\n                }else{\r\n                    valueExpress = column.getDefaultValue(con);\r\n                    if(needGeneratedKeys && generatedKeysType == 0 && valueExpress != Expression.NULL){\r\n                        keyColumnNames.add(column.getName());\r\n                        keys.add(valueExpress.getObject());\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 1){\r\n                    String[] keyNames = st.getGeneratedKeyNames();\r\n                    for(int i=0; i<keyNames.length; i++){\r\n                        if(column.getName().equalsIgnoreCase(keyNames[i])){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 2){\r\n                    int[] keyIndexes = st.getGeneratedKeyIndexes();\r\n                    for(int i=0; i<keyIndexes.length; i++){\r\n                        if(c+1 == keyIndexes[i]){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\t            store.writeExpression( valueExpress, column );\r\n\t\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\t\tindexes.get(i).writeExpression( c, valueExpress );\r\n\t\t\t\t}\r\n\t        }\r\n\t        store.writeFinsh( con );\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tindexes.get(i).writeFinish( con );\r\n\t\t\t}\r\n\t        updateCount++;\r\n            if(needGeneratedKeys){\r\n                Object[][] data = new Object[1][keys.size()];\r\n                keys.toArray(data[0]);\r\n                st.setGeneratedKeys(new SSResultSet( st, Utils.createMemoryCommandSelect( con, keyColumnNames.toArray(), data)));\r\n            }\r\n        }\r\n    }","startLine":56,"lastLine":58},{"locFile":"java+method:///smallsql/database/CommandInsert/executeImpl(smallsql.database.SSConnection,smallsql.database.SSStatement)","rawLines":"void executeImpl(SSConnection con, SSStatement st) throws Exception {\r\n        // on first time and on change of the table we need to recompile\r\n        if(table == null || tableTimestamp != table.getTimestamp()) compile( con );\r\n\r\n\t\tfinal IndexDescriptions indexes = table.indexes;\r\n\t\t\r\n\t\tupdateCount = 0;\r\n\t\tcmdSel.from.execute();\r\n\t\tcmdSel.beforeFirst();\r\n        \r\n        //Variables for GeneratedKeys\r\n        Strings keyColumnNames = null;\r\n        ArrayList keys = null;\r\n        boolean needGeneratedKeys = st.needGeneratedKeys();\r\n        int generatedKeysType = 0;\r\n\r\n        while(cmdSel.next()){\r\n            if(needGeneratedKeys){\r\n                keyColumnNames = new Strings();\r\n                keys = new ArrayList();\r\n                if(st.getGeneratedKeyNames() != null)\r\n                    generatedKeysType = 1;\r\n                if(st.getGeneratedKeyIndexes() != null)\r\n                    generatedKeysType = 2;\r\n            }\r\n\t        StoreImpl store = table.getStoreInsert( con );\r\n\t        for(int c=0; c<matrix.length; c++){\r\n\t            Column column = table.columns.get(c);\r\n\t            int idx = matrix[c];\r\n\t            Expression valueExpress;\r\n                if(idx >= 0){\r\n                    valueExpress = cmdSel.columnExpressions.get(idx);\r\n                }else{\r\n                    valueExpress = column.getDefaultValue(con);\r\n                    if(needGeneratedKeys && generatedKeysType == 0 && valueExpress != Expression.NULL){\r\n                        keyColumnNames.add(column.getName());\r\n                        keys.add(valueExpress.getObject());\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 1){\r\n                    String[] keyNames = st.getGeneratedKeyNames();\r\n                    for(int i=0; i<keyNames.length; i++){\r\n                        if(column.getName().equalsIgnoreCase(keyNames[i])){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if(needGeneratedKeys && generatedKeysType == 2){\r\n                    int[] keyIndexes = st.getGeneratedKeyIndexes();\r\n                    for(int i=0; i<keyIndexes.length; i++){\r\n                        if(c+1 == keyIndexes[i]){\r\n                            keyColumnNames.add(column.getName());\r\n                            keys.add(valueExpress.getObject());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\t            store.writeExpression( valueExpress, column );\r\n\t\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\t\tindexes.get(i).writeExpression( c, valueExpress );\r\n\t\t\t\t}\r\n\t        }\r\n\t        store.writeFinsh( con );\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tindexes.get(i).writeFinish( con );\r\n\t\t\t}\r\n\t        updateCount++;\r\n            if(needGeneratedKeys){\r\n                Object[][] data = new Object[1][keys.size()];\r\n                keys.toArray(data[0]);\r\n                st.setGeneratedKeys(new SSResultSet( st, Utils.createMemoryCommandSelect( con, keyColumnNames.toArray(), data)));\r\n            }\r\n        }\r\n    }","startLine":46,"lastLine":48},{"locFile":"java+method:///smallsql/junit/BenchTest/test_RowRequestPages(java.sql.Connection)","rawLines":"/**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":45,"lastLine":47},{"locFile":"java+method:///smallsql/database/SSDriver/parse(java.lang.String,java.util.Properties)","rawLines":"/**\r\n     * Parsed the JDBC URL and build together\r\n     * \r\n     * @param url\r\n     *            the JDBC URL\r\n     * @param info\r\n     *            a list of arbitrary properties\r\n     * @return a new Properties object\r\n     */\r\n    private Properties parse(String url, Properties info) throws SQLException {\r\n        Properties props = (Properties)info.clone();\r\n        if(!acceptsURL(url)){\r\n            return props;\r\n        }\r\n        int idx1 = url.indexOf(':', 5); // search after \"jdbc:\"\r\n        int idx2 = url.indexOf('?');\r\n        if(idx1 > 0){\r\n            String dbPath = (idx2 > 0) ? url.substring(idx1 + 1, idx2) : url.substring(idx1 + 1);\r\n            props.setProperty(\"dbpath\", dbPath);\r\n        }\r\n        if(idx2 > 0){\r\n            String propsString = url.substring(idx2 + 1).replace('&', ';');\r\n            StringTokenizer tok = new StringTokenizer(propsString, \";\");\r\n            while(tok.hasMoreTokens()){\r\n                String keyValue = tok.nextToken().trim();\r\n                if(keyValue.length() > 0){\r\n                    idx1 = keyValue.indexOf('=');\r\n                    if(idx1 > 0){\r\n                        String key = keyValue.substring(0, idx1).toLowerCase().trim();\r\n                        String value = keyValue.substring(idx1 + 1).trim();\r\n                        props.put(key, value);\r\n                    }else{\r\n                    \tthrow SmallSQLException.create(Language.CUSTOM_MESSAGE, \"Missing equal in property:\" + keyValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return props;\r\n    }","startLine":34,"lastLine":36},{"locFile":"java+method:///smallsql/database/Database/getCatalogs(smallsql.database.Database)","rawLines":"/**\r\n     * Create a list of all available Databases from the point of the current \r\n     * Database or current working directory\r\n     * @param database - current database\r\n     * @return\r\n     */\r\n    static Object[][] getCatalogs(Database database){\r\n    \tList catalogs = new ArrayList();\r\n    \tFile baseDir = (database != null) ?\r\n    \t\t\t\t\tdatabase.directory.getParentFile() :\r\n\t\t\t\t\t\tnew File(\".\");\r\n\t\tFile dirs[] = baseDir.listFiles();\r\n\t\tif(dirs != null)\r\n\t\t\tfor(int i=0; i<dirs.length; i++){\r\n\t\t\t\tif(dirs[i].isDirectory()){\r\n\t\t\t\t\tif(new File(dirs[i], Utils.MASTER_FILENAME).exists()){\r\n\t\t\t\t\t\tObject[] catalog = new Object[1];\r\n\t\t\t\t\t\tcatalog[0] = dirs[i].getPath();\r\n\t\t\t\t\t\tcatalogs.add(catalog);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tObject[][] result = new Object[catalogs.size()][];\r\n\t\tcatalogs.toArray(result);\r\n\t\treturn result;\r\n    }","startLine":19,"lastLine":21},{"locFile":"java+method:///smallsql/database/SQLParser/expressionSingle(smallsql.database.Command,smallsql.database.SQLToken)","rawLines":"/**\r\n     * This method parse a single expression like 12, 'qwert', 0x3F or a column name.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     */\r\n    private Expression expressionSingle(Command cmd, SQLToken token) throws SQLException{\r\n        boolean isMinus = false;\r\n        if(token != null){\r\n            switch(token.value){\r\n                case SQLTokenizer.NULL:\r\n                        return new ExpressionValue( null, SQLTokenizer.NULL );\r\n                case SQLTokenizer.STRING:\r\n                        return new ExpressionValue( token.getName(null), SQLTokenizer.VARCHAR );\r\n                case SQLTokenizer.IDENTIFIER:\r\n                        {\r\n                        String name = getIdentifier( token );\r\n                        ExpressionName expr =  new ExpressionName( name );\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                            expr.setNameAfterTableAlias( nextIdentifier() );\r\n                        }else{\r\n                            previousToken();\r\n                        }\r\n                        return expr;\r\n                        }\r\n                case SQLTokenizer.TRUE:\r\n                        return new ExpressionValue( Boolean.TRUE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.FALSE:\r\n                        return new ExpressionValue( Boolean.FALSE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.ESCAPE_L:{\r\n                        token = nextToken(COMMANDS_ESCAPE);\r\n                        SQLToken para = nextToken(MISSING_EXPRESSION);\r\n                        Expression expr;\r\n                        switch(token.value){\r\n                            case SQLTokenizer.D: // date escape sequence\r\n                            \texpr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.DATE), SQLTokenizer.DATE );\r\n                            \tbreak;\r\n                            case SQLTokenizer.T: // time escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIME), SQLTokenizer.TIME );\r\n                            \tbreak;\r\n                            case SQLTokenizer.TS: // timestamp escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP );\r\n                            \tbreak;\r\n                            case SQLTokenizer.FN: // function escape sequence\r\n                            \tnextToken(MISSING_PARENTHESIS_L);\r\n                            \texpr = function(cmd, para, true);\r\n                            \tbreak;\r\n                            case SQLTokenizer.CALL: // call escape sequence\r\n                                throw new java.lang.UnsupportedOperationException(\"call escape sequence\");\r\n                            default: throw new Error();\r\n                        }\r\n                        token = nextToken( ESCAPE_MISSING_CLOSE );\r\n                        return expr;\r\n                }\r\n                case SQLTokenizer.QUESTION:\r\n                        ExpressionValue param = new ExpressionValue();\r\n                        cmd.addParameter( param );\r\n                        return param;\r\n                case SQLTokenizer.CASE:\r\n                \t\treturn caseExpr(cmd);\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.PLUS:\r\n                        // sign detection\r\n                        do{\r\n                            if(token.value == SQLTokenizer.MINUS)\r\n                                    isMinus = !isMinus;\r\n                            token = nextToken();\r\n                            if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        }while(token.value == SQLTokenizer.MINUS || token.value == SQLTokenizer.PLUS);\r\n                        // no Break\r\n                default:\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.PARENTHESIS_L){\r\n                            if(isMinus)\r\n                                return new ExpressionArithmetic( function( cmd, token, false ),  ExpressionArithmetic.NEGATIVE );\r\n                            return function( cmd, token, false );\r\n                        }else{\r\n                            // constant expression or identifier\r\n                            char chr1 = sql[ token.offset ];\r\n\t\t\t\t\t\t\tif(chr1 == '$'){\r\n\t\t\t\t\t\t\t\tpreviousToken();\r\n\t                            String tok = new String(sql, token.offset+1, token.length-1);\r\n                                if(isMinus) tok = \"-\" + tok;\r\n\t\t\t\t\t\t\t\treturn new ExpressionValue( new Money(Double.parseDouble(tok)), SQLTokenizer.MONEY );\r\n\t\t\t\t\t\t\t}\r\n                            String tok = new String(sql, token.offset, token.length);\r\n                            if((chr1 >= '0' && '9' >= chr1) || chr1 == '.'){\r\n                                previousToken();\r\n                                // first character is a digit\r\n                                if(token.length>1 && (sql[ token.offset +1 ] | 0x20) == 'x'){\r\n                                    // binary data as hex\r\n                                    if(isMinus) {\r\n                \t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_OPER_MINUS);\r\n                                    }\r\n                                    return new ExpressionValue( Utils.hex2bytes( sql, token.offset+2, token.length-2), SQLTokenizer.VARBINARY );\r\n                                }\r\n                                if(isMinus) tok = \"-\" + tok;\r\n                                if(Utils.indexOf( '.', sql, token.offset, token.length ) >= 0 ||\r\n                                   Utils.indexOf( 'e', sql, token.offset, token.length ) >= 0){\r\n                                    return new ExpressionValue( new Double(tok), SQLTokenizer.DOUBLE );\r\n                                }else{\r\n                                    try{\r\n                                        return new ExpressionValue( new Integer(tok), SQLTokenizer.INT );\r\n                                    }catch(NumberFormatException e){\r\n                                        return new ExpressionValue( new Long(tok), SQLTokenizer.BIGINT );\r\n                                    }\r\n                                }\r\n                            }else{\r\n                                // identifier\r\n                                checkValidIdentifier( tok, token );\r\n                                ExpressionName expr = new ExpressionName(tok);\r\n                                if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                                    expr.setNameAfterTableAlias( nextIdentifier() );\r\n                                }else{\r\n                                    previousToken();\r\n                                }\r\n                                if(isMinus)\r\n                                    return new ExpressionArithmetic( expr,  ExpressionArithmetic.NEGATIVE );\r\n                                return expr;\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return null;\r\n    }","startLine":120,"lastLine":122},{"locFile":"java+method:///smallsql/database/DateTime/parse(java.lang.String)","rawLines":"static long parse(final String datetime) throws SQLException{\r\n\t\ttry{\r\n\t\t\tfinal int length = datetime.length();\r\n\r\n\t\t\tfinal int year;\r\n\t\t\tfinal int month;\r\n\t\t\tfinal int day;\r\n\t\t\tfinal int hour;\r\n\t\t\tfinal int minute;\r\n\t\t\tfinal int second;\r\n\t\t\tfinal int millis;\r\n\t\t\t\r\n\r\n\t\t\tint idx1 = 0;\r\n\t\t\tint idx2 = datetime.indexOf('-');\r\n\t\t\tif(idx2 > 0){\r\n\t\t\t\tyear = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf('-', idx1);\r\n\t\t\t\tmonth = Integer.parseInt(datetime.substring(idx1, idx2).trim())-1;\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf(' ', idx1);\r\n\t\t\t\tif(idx2 < 0) idx2 = datetime.length();\r\n\t\t\t\tday = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t}else{\r\n\t\t\t\tyear  = 1970;\r\n\t\t\t\tmonth = 0;\r\n\t\t\t\tday   = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tidx1 = idx2+1;\r\n\t\t\tidx2 = datetime.indexOf(':', idx1);\r\n\t\t\tif(idx2>0){\r\n\t\t\t\thour = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf(':', idx1);\r\n\t\t\t\tminute = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tidx2 = datetime.indexOf('.', idx1);\r\n\t\t\t\tif(idx2 < 0) idx2 = datetime.length();\r\n\t\t\t\tsecond = Integer.parseInt(datetime.substring(idx1, idx2).trim());\r\n\t\t\t\t\r\n\t\t\t\tidx1 = idx2+1;\r\n\t\t\t\tif(idx1 < length){\r\n\t\t\t\t\tString strMillis = datetime.substring(idx1).trim();\r\n\t\t\t\t\tswitch(strMillis.length()){\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis) * 100;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis) * 10;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tmillis = Integer.parseInt(strMillis.substring(0,3));\r\n\t\t\t\t\t}\r\n\t\t\t\t}else\r\n\t\t\t\t\tmillis = 0;\r\n\t\t\t}else{\r\n\t\t\t\thour   = 0;\r\n\t\t\t\tminute = 0;\r\n\t\t\t\tsecond = 0;\r\n\t\t\t\tmillis = 0;\t\t\t\t\r\n\t\t\t}\r\n            if(idx1 == 0 && length > 0){\r\n                throw SmallSQLException.create(Language.DATETIME_INVALID);\r\n            }\r\n            \r\n            if(month >= 12){\r\n                throw SmallSQLException.create(Language.MONTH_TOOLARGE, datetime );\r\n            }\r\n            if(day >= 32){\r\n                throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n            }\r\n            if(day == 31){\r\n                switch(month){\r\n                case 1:\r\n                case 3:\r\n                case 5:\r\n                case 8:\r\n                case 10:\r\n                    throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n                }\r\n            }\r\n            if(month == 1){\r\n                if(day == 30){\r\n                    throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n                }\r\n                if(day == 29){\r\n                    if(!isLeapYear(year)){\r\n                        throw SmallSQLException.create(Language.DAYS_TOOLARGE, datetime );\r\n                    }\r\n                }\r\n            }\r\n            if(hour >= 24){\r\n                throw SmallSQLException.create(Language.HOURS_TOOLARGE, datetime );\r\n            }\r\n            if(minute >= 60){\r\n                throw SmallSQLException.create(Language.MINUTES_TOOLARGE, datetime );\r\n            }\r\n            if(second >= 60){\r\n                throw SmallSQLException.create(Language.SECS_TOOLARGE, datetime );\r\n            }\r\n            if(millis >= 1000){\r\n                throw SmallSQLException.create(Language.MILLIS_TOOLARGE, datetime );\r\n            }\r\n\t\t\treturn calcMillis(year, month, day, hour, minute, second, millis);\r\n        }catch(SQLException ex){\r\n            throw ex;\r\n\t\t}catch(Throwable ex){\r\n\t\t\tthrow SmallSQLException.createFromException(Language.DATETIME_INVALID, datetime, ex );\r\n\t\t}\r\n\t}","startLine":97,"lastLine":99},{"locFile":"java+method:///smallsql/database/SSDatabaseMetaData/getTables(java.lang.String,java.lang.String,java.lang.String,java.lang.String%5B%5D)","rawLines":"public ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types) throws SQLException {\r\n\t\tString[] colNames = {\"TABLE_CAT\",\"TABLE_SCHEM\",\"TABLE_NAME\",\"TABLE_TYPE\",\"REMARKS\",\"TYPE_CAT\",\"TYPE_SCHEM\",\"TYPE_NAME\",\"SELF_REFERENCING_COL_NAME\",\"REF_GENERATION\"};\r\n\t\tDatabase database;\r\n\t\tif(catalog == null){ \r\n\t\t\tdatabase = con.getDatabase(true);\r\n\t\t\tif(database != null)\r\n\t\t\t\tcatalog = database.getName();\r\n    \t}else{\r\n\t\t\tdatabase = Database.getDatabase(catalog, con, false);\r\n    \t}\r\n\t\tArrayList rows = new ArrayList();\r\n\t\tboolean isTypeTable = types == null;\r\n\t\tboolean isTypeView = types == null;\r\n\t\tfor(int i=0; types != null && i<types.length; i++){\r\n\t\t\tif(\"TABLE\".equalsIgnoreCase(types[i])) isTypeTable = true;\r\n\t\t\tif(\"VIEW\" .equalsIgnoreCase(types[i])) isTypeView  = true;\r\n\t\t}\r\n\t\t\r\n\t\tif(database != null){\r\n\t\t\tStrings tables = database.getTables(tableNamePattern);\r\n\t\t\tfor(int i=0; i<tables.size(); i++){\r\n\t\t\t\tString table = tables.get(i);\r\n\t\t\t\tObject[] row = new Object[10];\r\n\t\t\t\trow[0] = catalog;\r\n\t\t\t\trow[2] = table;\r\n\t\t\t\ttry{\r\n\t\t\t\t\tif(database.getTableView( con, table) instanceof View){\r\n\t\t\t\t\t\tif(isTypeView){\r\n\t\t\t\t\t\t\trow[3] = \"VIEW\";\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(isTypeTable){\r\n\t\t\t\t\t\t\trow[3] = \"TABLE\";\t\t\t\t\t\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t//TODO invalid VIEWS does not show because it can't load.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] data = new Object[rows.size()][];\r\n\t\trows.toArray(data);\r\n\t\tCommandSelect cmdSelect = Utils.createMemoryCommandSelect( con, colNames, data);\r\n\t\tExpressions order = new Expressions();\r\n\t\torder.add( new ExpressionName(\"TABLE_TYPE\") );\r\n\t\torder.add( new ExpressionName(\"TABLE_NAME\") );\r\n\t\tcmdSelect.setOrder( order );\r\n\t\treturn new SSResultSet( st, cmdSelect);\r\n    }","startLine":39,"lastLine":41},{"locFile":"java+method:///smallsql/database/TableResult/moveToRow()","rawLines":"/**\r\n     * Move to the row in the filePos. A value of -1 for filePos is invalid at this call point.\r\n     */\r\n    final private boolean moveToRow() throws Exception{\r\n    \tif(filePos >= 0x4000000000000000L){\r\n    \t\tstore = ((StorePageLink)insertStorePages.get( (int)(filePos & 0x3FFFFFFFFFFFFFFFL) )).getStore( table, con, lock);\r\n    \t}else{\r\n    \t\tstore = (filePos < maxFileOffset) ? table.getStore( con, filePos, lock ) : null;\r\n\t\t\tif(store == null){\r\n\t\t\t\tif(insertStorePages.size() > 0){\t\t\t\r\n\t\t\t\t\tfilePos = 0x4000000000000000L;\r\n\t\t\t\t\tstore = ((StorePageLink)insertStorePages.get( (int)(filePos & 0x3FFFFFFFFFFFFFFFL) )).getStore( table, con, lock);\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t}\r\n\t\tif(store != null){\r\n\t\t\tif(!store.isValidPage()){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tstore.scanObjectOffsets( offsets, dataTypes );\r\n\t\t\tafterLastValidFilePos = store.getNextPagePos();\r\n\t\t\treturn true;\r\n\t\t}else{\r\n\t\t\tfilePos = -1;\r\n\t\t\tnoRow();\r\n\t\t\treturn false;\r\n\t\t}\r\n    }","startLine":12,"lastLine":14}],"window":3},{"content":"assertTrue(rs.next());assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));assertFalse(rs.next());","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestDBMetaData/testGetBestRowIdentifier()","rawLines":"public void testGetBestRowIdentifier() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblBestRow1\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblBestRow1(id1 counter primary key, v nvarchar(100))\");\r\n        String[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n        int[] colTypes = {Types.SMALLINT, Types.VARCHAR, Types.INTEGER, Types.VARCHAR, Types.INTEGER, Types.NULL, Types.SMALLINT, Types.SMALLINT};\r\n        \r\n        ResultSet rs = md.getBestRowIdentifier(null, null, \"tblBestRow1\", DatabaseMetaData.bestRowSession, true);        \r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames2 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"KEY_SEQ\", \"PK_NAME\"};\r\n        int[] colTypes2 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.VARCHAR};\r\n        rs = md.getPrimaryKeys(null, null, \"tblBestRow1\");        \r\n        assertRSMetaData(rs, colNames2, colTypes2);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames3 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"NON_UNIQUE\", \"INDEX_QUALIFIER\", \"INDEX_NAME\", \"TYPE\", \"ORDINAL_POSITION\", \"COLUMN_NAME\", \"ASC_OR_DESC\", \"CARDINALITY\", \"PAGES\", \"FILTER_CONDITION\"};\r\n        int[] colTypes3 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.BOOLEAN, Types.NULL, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.NULL, Types.NULL, Types.NULL, Types.NULL};\r\n        rs = md.getIndexInfo(null, null, \"tblBestRow1\", true, true);        \r\n        assertRSMetaData(rs, colNames3, colTypes3);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblBestRow1\");\r\n    }","startLine":19,"lastLine":21},{"locFile":"java+method:///smallsql/junit/TestDBMetaData/testGetBestRowIdentifier()","rawLines":"public void testGetBestRowIdentifier() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblBestRow1\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblBestRow1(id1 counter primary key, v nvarchar(100))\");\r\n        String[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n        int[] colTypes = {Types.SMALLINT, Types.VARCHAR, Types.INTEGER, Types.VARCHAR, Types.INTEGER, Types.NULL, Types.SMALLINT, Types.SMALLINT};\r\n        \r\n        ResultSet rs = md.getBestRowIdentifier(null, null, \"tblBestRow1\", DatabaseMetaData.bestRowSession, true);        \r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames2 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"KEY_SEQ\", \"PK_NAME\"};\r\n        int[] colTypes2 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.VARCHAR};\r\n        rs = md.getPrimaryKeys(null, null, \"tblBestRow1\");        \r\n        assertRSMetaData(rs, colNames2, colTypes2);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames3 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"NON_UNIQUE\", \"INDEX_QUALIFIER\", \"INDEX_NAME\", \"TYPE\", \"ORDINAL_POSITION\", \"COLUMN_NAME\", \"ASC_OR_DESC\", \"CARDINALITY\", \"PAGES\", \"FILTER_CONDITION\"};\r\n        int[] colTypes3 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.BOOLEAN, Types.NULL, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.NULL, Types.NULL, Types.NULL, Types.NULL};\r\n        rs = md.getIndexInfo(null, null, \"tblBestRow1\", true, true);        \r\n        assertRSMetaData(rs, colNames3, colTypes3);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblBestRow1\");\r\n    }","startLine":27,"lastLine":29},{"locFile":"java+method:///smallsql/junit/TestDBMetaData/testGetBestRowIdentifier()","rawLines":"public void testGetBestRowIdentifier() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblBestRow1\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblBestRow1(id1 counter primary key, v nvarchar(100))\");\r\n        String[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n        int[] colTypes = {Types.SMALLINT, Types.VARCHAR, Types.INTEGER, Types.VARCHAR, Types.INTEGER, Types.NULL, Types.SMALLINT, Types.SMALLINT};\r\n        \r\n        ResultSet rs = md.getBestRowIdentifier(null, null, \"tblBestRow1\", DatabaseMetaData.bestRowSession, true);        \r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames2 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"KEY_SEQ\", \"PK_NAME\"};\r\n        int[] colTypes2 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.VARCHAR};\r\n        rs = md.getPrimaryKeys(null, null, \"tblBestRow1\");        \r\n        assertRSMetaData(rs, colNames2, colTypes2);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames3 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"NON_UNIQUE\", \"INDEX_QUALIFIER\", \"INDEX_NAME\", \"TYPE\", \"ORDINAL_POSITION\", \"COLUMN_NAME\", \"ASC_OR_DESC\", \"CARDINALITY\", \"PAGES\", \"FILTER_CONDITION\"};\r\n        int[] colTypes3 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.BOOLEAN, Types.NULL, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.NULL, Types.NULL, Types.NULL, Types.NULL};\r\n        rs = md.getIndexInfo(null, null, \"tblBestRow1\", true, true);        \r\n        assertRSMetaData(rs, colNames3, colTypes3);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblBestRow1\");\r\n    }","startLine":11,"lastLine":13}],"window":3},{"content":"store.page = storePage.page;store.sharedPageData = true;store.readPageHeader();","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/createStore(smallsql.database.Table,smallsql.database.StorePage,int,long)","rawLines":"/**\r\n     * Follow types of StoreImpl are possible:\r\n     * INSERT: A page that will be include new data. filePos is not define yet.\r\n     * CREATE: A special type of INSERT\r\n     * SELECT: Only read operations are possible.\r\n     * UPDATE: Has a filePos, if the new size is to small then the old page must be deleted and a new added.\r\n     * DELETE: Has no cache else only the filePos to write the flag.\r\n    */\r\n    static StoreImpl createStore( Table table, StorePage storePage, int type, long filePos ) throws SQLException{\r\n        try {\r\n            StoreImpl store = new StoreImpl(table, storePage, type, filePos);\r\n            switch(type){\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                    // is used for storing of LONGVARBINARY and LONGVARCHAR\r\n                    store.page = new byte[(int)filePos + PAGE_CONTROL_SIZE];\r\n                    store.filePos = -1;\r\n                    break;\r\n                case SQLTokenizer.INSERT:\r\n                case SQLTokenizer.CREATE:\r\n                    store.page = new byte[DEFAULT_PAGE_SIZE];\r\n                    break;\r\n                case SQLTokenizer.SELECT:\r\n                case SQLTokenizer.UPDATE:\r\n            \tcase SQLTokenizer.DELETE:\r\n                    if(storePage.page == null){\r\n                        FileChannel raFile = storePage.raFile;\r\n                        synchronized(raFile){\r\n                            if(filePos >= raFile.size() - PAGE_CONTROL_SIZE){\r\n                                return null;\r\n                            }\r\n                            raFile.position(filePos);\r\n                            synchronized(page_control){\r\n                                pageControlBuffer.position(0);\r\n                                raFile.read(pageControlBuffer);\r\n                                store.page = page_control;\r\n                                store.readPageHeader();\r\n                            }\r\n                            store.page = new byte[store.sizeUsed];\r\n                            raFile.position(filePos);\r\n                            ByteBuffer buffer = ByteBuffer.wrap(store.page);\r\n                            raFile.read(buffer);\r\n                        }\r\n                    }else{\r\n                        store.page = storePage.page;\r\n                        store.sharedPageData = true;\r\n                        store.readPageHeader();\r\n                    }\r\n                    store = store.loadUpdatedStore();\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            store.offset = PAGE_CONTROL_SIZE;\r\n            return store;\r\n        } catch (Throwable th) {\r\n            throw SmallSQLException.createFromException(th);\r\n        }\r\n    }","startLine":43,"lastLine":45},{"locFile":"java+method:///smallsql/database/StoreImpl/recreateStore(smallsql.database.Table,smallsql.database.StorePage,int)","rawLines":"/**\r\n     * Recreate a StoreImpl from an uncommitted StorePage.\r\n     */\r\n\tstatic StoreImpl recreateStore( Table table, StorePage storePage, int type) throws Exception{\r\n\t\tStoreImpl store = new StoreImpl(table, storePage, type, -1);\r\n\t\tstore.page = storePage.page;\r\n\t\tstore.sharedPageData = true;\r\n\t\tstore.readPageHeader();\r\n\t\tstore = store.loadUpdatedStore();\r\n\t\tstore.offset = PAGE_CONTROL_SIZE;\r\n\t\treturn store;\r\n\t}","startLine":5,"lastLine":7}],"window":3},{"content":"for(int i=0; i<columnExpressions.size(); i++){Expression src = newRowSources[i];if(src != null && (!(src instanceof ExpressionValue) || !((ExpressionValue)src).isEmpty())){","cloneLocs":[{"locFile":"java+method:///smallsql/database/CommandSelect/updateRow(smallsql.database.SSConnection,smallsql.database.Expression%5B%5D)","rawLines":"final void updateRow(SSConnection con, Expression[] newRowSources) throws SQLException{\r\n\t\tint savepoint = con.getSavepoint();\r\n\t\ttry{\r\n\t\t\t//loop through all tables of this ResultSet \r\n\t\t\tfor(int t=0; t<tables.size(); t++){\r\n\t\t\t\tTableViewResult result = TableViewResult.getTableViewResult( tables.get(t) );\r\n\t\t\t\tTableView table = result.getTableView();\r\n\t\t\t\tColumns tableColumns = table.columns;\r\n\t\t\t\tint count = tableColumns.size();\r\n\t\t\t\t\r\n\t\t\t\t// order the new Values after it position in the table\r\n\t\t\t\tExpression[] updateValues = new Expression[count];\r\n\t\t\t\tboolean isUpdateNeeded = false;\r\n\t\t\t\tfor(int i=0; i<columnExpressions.size(); i++){\r\n\t\t\t\t\tExpression src = newRowSources[i];\r\n\t\t\t\t\tif(src != null && (!(src instanceof ExpressionValue) || !((ExpressionValue)src).isEmpty())){\t\r\n\t\t\t\t\t\tExpression col = columnExpressions.get(i);\r\n\t\t\t\t\t\tif(!col.isDefinitelyWritable())\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.COL_READONLY, new Integer(i));\r\n\t\t\t\t\t\tExpressionName exp = (ExpressionName)col;\r\n\t\t\t\t\t\tif(table == exp.getTable()){\r\n\t\t\t\t\t\t\tupdateValues[exp.getColumnIndex()] = src;\r\n\t\t\t\t\t\t\tisUpdateNeeded = true;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// save the new values if there are new value for this table\r\n\t\t\t\tif(isUpdateNeeded){\r\n\t\t\t\t\tresult.updateRow(updateValues);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}catch(Throwable e){\r\n\t\t\tcon.rollback(savepoint);\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}finally{\r\n\t\t\tif(con.getAutoCommit()) con.commit();\r\n\t\t}\r\n\t}","startLine":13,"lastLine":15},{"locFile":"java+method:///smallsql/database/CommandSelect/insertRow(smallsql.database.SSConnection,smallsql.database.Expression%5B%5D)","rawLines":"final void insertRow(SSConnection con, Expression[] newRowSources) throws SQLException{\r\n\t\tif(tables.size() > 1)\r\n\t\t\tthrow SmallSQLException.create(Language.JOIN_INSERT);\r\n\t\tif(tables.size() == 0)\r\n\t\t\tthrow SmallSQLException.create(Language.INSERT_WO_FROM);\r\n\t\t\r\n\t\tint savepoint = con.getSavepoint();\r\n\t\ttry{\r\n\t\t\tTableViewResult result = TableViewResult.getTableViewResult( tables.get(0) );\r\n\t\t\tTableView table = result.getTableView();\r\n\t\t\tColumns tabColumns = table.columns;\r\n\t\t\tint count = tabColumns.size();\r\n\t\t\t\t\t\r\n\t\t\t// order the new Values after it position in the table\r\n\t\t\tExpression[] updateValues = new Expression[count];\r\n\t\t\tif(newRowSources != null){\r\n\t\t\t\tfor(int i=0; i<columnExpressions.size(); i++){\r\n\t\t\t\t\tExpression src = newRowSources[i];\r\n\t\t\t\t\tif(src != null && (!(src instanceof ExpressionValue) || !((ExpressionValue)src).isEmpty())){\t\r\n\t\t\t\t\t\tExpression rsColumn = columnExpressions.get(i); // Column of the ResultSet\r\n\t\t\t\t\t\tif(!rsColumn.isDefinitelyWritable())\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.COL_READONLY, new Integer(i));\r\n\t\t\t\t\t\tExpressionName exp = (ExpressionName)rsColumn;\r\n\t\t\t\t\t\tif(table == exp.getTable()){\r\n\t\t\t\t\t\t\tupdateValues[exp.getColumnIndex()] = src;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdateValues[i] = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t// save the new values if there are new value for this table\r\n\t\t\tresult.insertRow(updateValues);\r\n\t\t}catch(Throwable e){\r\n\t\t\tcon.rollback(savepoint);\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}finally{\r\n\t\t\tif(con.getAutoCommit()) con.commit();\r\n\t\t}\r\n\t}","startLine":16,"lastLine":18}],"window":3},{"content":"}switch(token.value){case SQLTokenizer.PARENTHESIS_R:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/createTable()","rawLines":"private CommandTable createTable() throws SQLException{\r\n        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmdCreate = new CommandTable( con.log, catalog, tableName, SQLTokenizer.CREATE );\r\n        SQLToken token = nextToken( MISSING_PARENTHESIS_L );\r\n\r\n        nextCol:\r\n        while(true){\r\n            token = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\r\n\t\t\tString constraintName;\r\n            if(token.value == SQLTokenizer.CONSTRAINT){\r\n            \t// reading a CONSTRAINT with name\r\n\t\t    \tconstraintName = nextIdentifier();\r\n\t\t\t\ttoken = nextToken( MISSING_KEYTYPE );\r\n            }else{\r\n\t\t\t\tconstraintName = null;\r\n            }\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\tcase SQLTokenizer.FOREIGN:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, tableName, constraintName, null);\r\n                    if(token.value == SQLTokenizer.FOREIGN){\r\n                        nextToken( MISSING_REFERENCES );\r\n                        String pk = nextIdentifier();\r\n                        Expressions expressions = new Expressions();\r\n                        Strings columns = new Strings();\r\n                        expressionDefList( cmdCreate, expressions, columns );\r\n                        IndexDescription pkIndex = new IndexDescription( null, pk, SQLTokenizer.UNIQUE, expressions, columns);\r\n                        ForeignKey foreignKey = new ForeignKey(pk, pkIndex, tableName, index);\r\n                        cmdCreate.addForeingnKey(foreignKey);\r\n                    }else{\r\n                        cmdCreate.addIndex( index );\r\n                    }\r\n\t\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tswitch(token.value){\r\n\t\t\t\t\t\tcase SQLTokenizer.PARENTHESIS_R:\r\n\t\t\t\t\t\t\treturn cmdCreate;\r\n\t\t\t\t\t\tcase SQLTokenizer.COMMA:\r\n\t\t\t\t\t\t\tcontinue nextCol;\r\n\t\t\t\t\t}\r\n            }\r\n            // the token is a column name\r\n\t\t\ttoken = addColumn( token, cmdCreate );\r\n            if(token == null){\r\n                throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    return cmdCreate;\r\n                case SQLTokenizer.COMMA:\r\n                    continue nextCol;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n        }\r\n    }","startLine":50,"lastLine":52},{"locFile":"java+method:///smallsql/database/SQLParser/addColumn(smallsql.database.SQLToken,smallsql.database.CommandTable)","rawLines":"/**\r\n     * Parse a Column and add it to the Command. If the column is unique or primary\r\n     * then an index is added.\r\n     * @param token the SQLToken with the column name\r\n     * @return the token of the delimiter\r\n     */\r\n    private SQLToken addColumn(SQLToken token, CommandTable cmdCreate) throws SQLException{\r\n        String colName = getIdentifier( token );\r\n        Column col = datatype(false);\r\n        col.setName( colName );\r\n\r\n\t\ttoken = nextToken();\r\n        boolean nullableWasSet = false;\r\n        boolean defaultWasSet = col.isAutoIncrement(); // with data type COUNTER already this value is set\r\n        while(true){\r\n            if(token == null){\r\n                cmdCreate.addColumn( col );\r\n                return null;\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.COMMA:\r\n                    cmdCreate.addColumn( col );\r\n                    return token;\r\n                case SQLTokenizer.DEFAULT:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tint offset = token.offset + token.length;\r\n                    token = nextToken();\r\n                    if(token != null) offset = token.offset;\r\n\t\t\t\t\tpreviousToken();                    \r\n\t\t\t\t\tExpression expr = expression(cmdCreate, 0);\r\n\t\t\t\t\tSQLToken last = lastToken();\r\n\t\t\t\t\tint length = last.offset + last.length - offset;\r\n\t\t\t\t\tString def = new String( sql, offset, length );\r\n                    col.setDefaultValue( expr, def );\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.IDENTITY:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    col.setAutoIncrement(true);\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NULL:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    //col.setNullable(true); is already default\r\n                    nullableWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NOT:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    token = nextToken( MISSING_NULL );\r\n                    col.setNullable(false);\r\n                    nullableWasSet = true;\r\n                    break;\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, cmdCreate.name, null, colName);\r\n\t\t\t\t\tcmdCreate.addIndex( index );\r\n\t\t\t\t\tbreak;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_OPTIONS_DATATYPE);\r\n            }\r\n            token = nextToken();\r\n        }\r\n    }","startLine":18,"lastLine":20}],"window":3},{"content":"case SQLTokenizer.SMALLMONEY:case SQLTokenizer.MONEY:case SQLTokenizer.DECIMAL:","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/isSignedDataType(int)","rawLines":"static boolean isSignedDataType(int dataType) {\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/database/SQLTokenizer/getSQLDataType(int)","rawLines":"static final int getSQLDataType(int type){\r\n\t\t// on change of this map the order from getTypeInfo need to be change\r\n\t\tswitch(type){\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\t\treturn Types.BIT;\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\treturn Types.BOOLEAN;\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\t\treturn Types.BINARY;\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\t\treturn Types.VARBINARY;\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t\treturn Types.LONGVARBINARY;\r\n\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\treturn Types.BLOB;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\treturn Types.TINYINT;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\treturn Types.SMALLINT;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\treturn Types.INTEGER;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\treturn Types.BIGINT;\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\treturn Types.DECIMAL;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\treturn Types.NUMERIC;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\treturn Types.REAL;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\treturn Types.FLOAT;\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\treturn Types.DOUBLE;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\treturn Types.DATE;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\treturn Types.TIME;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\treturn Types.TIMESTAMP;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\t\treturn Types.CHAR;\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\t\treturn Types.VARCHAR;\r\n\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\treturn Types.LONGVARCHAR;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n\t\t\t\t\t\treturn Types.CLOB;\r\n\t\t\tcase SQLTokenizer.JAVA_OBJECT:\r\n\t\t\t\t\t\treturn Types.JAVA_OBJECT;\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\treturn -11;\r\n\t\t\tcase SQLTokenizer.NULL:\r\n\t\t\t\t\t\treturn Types.NULL;\r\n\t\t\tdefault: throw new Error(\"DataType:\"+type);\r\n\t\t}\r\n\t}","startLine":23,"lastLine":25}],"window":3},{"content":"assertEquals(3, rs.getRow());assertTrue(rs.isLast());assertFalse(rs.isFirst());","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelativeAssert(java.sql.ResultSet)","rawLines":"private void testAbsoluteRelativeAssert(ResultSet rs) throws SQLException{\r\n        assertEquals(0, rs.getRow());\r\n        \r\n        assertTrue(rs.absolute(2));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n\r\n        assertTrue(rs.relative(-1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n\r\n        assertTrue(rs.absolute(1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n        assertTrue(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(1));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.absolute(-1));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(0));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertTrue(rs.last());\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n    }","startLine":42,"lastLine":44},{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelativeAssert(java.sql.ResultSet)","rawLines":"private void testAbsoluteRelativeAssert(ResultSet rs) throws SQLException{\r\n        assertEquals(0, rs.getRow());\r\n        \r\n        assertTrue(rs.absolute(2));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n\r\n        assertTrue(rs.relative(-1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n\r\n        assertTrue(rs.absolute(1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n        assertTrue(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(1));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.absolute(-1));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(0));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertTrue(rs.last());\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n    }","startLine":24,"lastLine":26},{"locFile":"java+method:///smallsql/junit/TestScrollable/testAbsoluteRelativeAssert(java.sql.ResultSet)","rawLines":"private void testAbsoluteRelativeAssert(ResultSet rs) throws SQLException{\r\n        assertEquals(0, rs.getRow());\r\n        \r\n        assertTrue(rs.absolute(2));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n\r\n        assertTrue(rs.relative(-1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n\r\n        assertTrue(rs.absolute(1));\r\n        assertEquals(\"qwert1\", rs.getString(\"v\"));\r\n        assertEquals(1, rs.getRow());\r\n        assertTrue(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(1));\r\n        assertEquals(\"qwert2\", rs.getString(\"v\"));\r\n        assertEquals(2, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.absolute(-1));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertTrue(rs.relative(0));\r\n        assertEquals(\"qwert3\", rs.getString(\"v\"));\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertTrue(rs.last());\r\n        assertEquals(3, rs.getRow());\r\n        assertTrue(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n\r\n        assertFalse(rs.absolute(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertFalse(rs.isBeforeFirst());\r\n        assertTrue(rs.isAfterLast());\r\n\r\n        assertFalse(rs.relative(-4));\r\n        assertEquals(0, rs.getRow());\r\n        assertFalse(rs.isLast());\r\n        assertFalse(rs.isFirst());\r\n        assertTrue(rs.isBeforeFirst());\r\n        assertFalse(rs.isAfterLast());\r\n    }","startLine":30,"lastLine":32}],"window":3},{"content":"try{Expression expr = getValue(columnIndex);wasNull = expr.isNull();","cloneLocs":[{"locFile":"java+method:///smallsql/database/SSResultSet/getFloat(int)","rawLines":"public float getFloat(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getFloat();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/SSResultSet/getLong(int)","rawLines":"public long getLong(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/SSResultSet/getInt(int)","rawLines":"public int getInt(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getInt();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/SSResultSet/getDouble(int)","rawLines":"public double getDouble(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getDouble();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/SSResultSet/getBoolean(int)","rawLines":"public boolean getBoolean(int columnIndex) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            return expr.getBoolean();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }","startLine":1,"lastLine":3}],"window":3},{"content":"assertRSMetaData(rs, colNames, colTypes);assertTrue(rs.next());assertFalse(rs.next());","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestDBMetaData/testGetCrossReference()","rawLines":"public void testGetCrossReference() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        \r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblCross1(id1 counter primary key, v nvarchar(100))\");\r\n        //st.execute(\"Create Table tblCross2(id2 counter foreign key REFERENCES tblCross1(id1), v nvarchar(100))\");\r\n        st.execute(\"Create Table tblCross2(id2 int , v nvarchar(100), foreign key (id2) REFERENCES tblCross1(id1))\");\r\n        String[] colNames = {\"PKTABLE_CAT\", \"PKTABLE_SCHEM\", \"PKTABLE_NAME\", \"PKCOLUMN_NAME\", \"FKTABLE_CAT\", \"FKTABLE_SCHEM\", \"FKTABLE_NAME\", \"FKCOLUMN_NAME\", \"KEY_SEQ\", \"UPDATE_RULE\", \"DELETE_RULE\", \"FK_NAME\", \"PK_NAME\", \"DEFERRABILITY\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT };\r\n        \r\n        ResultSet rs = md.getCrossReference(null,null,\"tblCross1\",null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getImportedKeys(null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getExportedKeys(null,null,\"tblCross1\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n    }","startLine":19,"lastLine":21},{"locFile":"java+method:///smallsql/junit/TestDBMetaData/testGetCrossReference()","rawLines":"public void testGetCrossReference() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        \r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblCross1(id1 counter primary key, v nvarchar(100))\");\r\n        //st.execute(\"Create Table tblCross2(id2 counter foreign key REFERENCES tblCross1(id1), v nvarchar(100))\");\r\n        st.execute(\"Create Table tblCross2(id2 int , v nvarchar(100), foreign key (id2) REFERENCES tblCross1(id1))\");\r\n        String[] colNames = {\"PKTABLE_CAT\", \"PKTABLE_SCHEM\", \"PKTABLE_NAME\", \"PKCOLUMN_NAME\", \"FKTABLE_CAT\", \"FKTABLE_SCHEM\", \"FKTABLE_NAME\", \"FKCOLUMN_NAME\", \"KEY_SEQ\", \"UPDATE_RULE\", \"DELETE_RULE\", \"FK_NAME\", \"PK_NAME\", \"DEFERRABILITY\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT };\r\n        \r\n        ResultSet rs = md.getCrossReference(null,null,\"tblCross1\",null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getImportedKeys(null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getExportedKeys(null,null,\"tblCross1\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n    }","startLine":24,"lastLine":26},{"locFile":"java+method:///smallsql/junit/TestDBMetaData/testGetCrossReference()","rawLines":"public void testGetCrossReference() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        \r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblCross1(id1 counter primary key, v nvarchar(100))\");\r\n        //st.execute(\"Create Table tblCross2(id2 counter foreign key REFERENCES tblCross1(id1), v nvarchar(100))\");\r\n        st.execute(\"Create Table tblCross2(id2 int , v nvarchar(100), foreign key (id2) REFERENCES tblCross1(id1))\");\r\n        String[] colNames = {\"PKTABLE_CAT\", \"PKTABLE_SCHEM\", \"PKTABLE_NAME\", \"PKCOLUMN_NAME\", \"FKTABLE_CAT\", \"FKTABLE_SCHEM\", \"FKTABLE_NAME\", \"FKCOLUMN_NAME\", \"KEY_SEQ\", \"UPDATE_RULE\", \"DELETE_RULE\", \"FK_NAME\", \"PK_NAME\", \"DEFERRABILITY\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT };\r\n        \r\n        ResultSet rs = md.getCrossReference(null,null,\"tblCross1\",null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getImportedKeys(null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getExportedKeys(null,null,\"tblCross1\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n    }","startLine":14,"lastLine":16}],"window":3},{"content":"}elseif (value.length == 1){long temp = value[0] & 0xFFFFFFFFL;","cloneLocs":[{"locFile":"java+method:///smallsql/database/MutableNumeric/doubleValue()","rawLines":"public double doubleValue(){\r\n        if(value.length == 0 || signum == 0){\r\n            return 0;\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                return value[0] / scaleDoubleFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                return temp / scaleDoubleFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                return temp / scaleDoubleFactor[scale] * signum;\r\n            }else{\r\n                return new BigDecimal( new BigInteger( toByteArray() ), scale ).doubleValue();\r\n            }\r\n        }\r\n    }","startLine":7,"lastLine":10},{"locFile":"java+method:///smallsql/database/MutableNumeric/toString()","rawLines":"public String toString(){\r\n        StringBuffer buf = new StringBuffer();\r\n        if(value.length == 0 || signum == 0){\r\n            buf.append( '0' );\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                buf.append( Integer.toString(value[0]) );\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                buf.append( Long.toString( temp ) );\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                buf.append( Long.toString( temp ) );\r\n            }else{\r\n                return new BigDecimal( new BigInteger( toByteArray() ), scale ).toString();\r\n            }\r\n        }\r\n        if(scale > 0){\r\n            while(buf.length() <= scale) buf.insert( 0, '0' );\r\n            buf.insert( buf.length() - scale, '.' );\r\n        }\r\n        if (signum < 0) buf.insert( 0, '-');\r\n        return buf.toString();\r\n    }","startLine":8,"lastLine":11},{"locFile":"java+method:///smallsql/database/MutableNumeric/floatValue()","rawLines":"public float floatValue(){\r\n        if(value.length == 0 || signum == 0){\r\n            return 0;\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                return value[0] / scaleFloatFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                return temp / scaleFloatFactor[scale] * signum;\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                return temp / scaleFloatFactor[scale] * signum;\r\n            }else{\r\n                return new BigDecimal( new BigInteger( toByteArray() ), scale ).floatValue();\r\n            }\r\n        }\r\n    }","startLine":7,"lastLine":10},{"locFile":"java+method:///smallsql/database/MutableNumeric/longValue()","rawLines":"public long longValue(){\r\n        if(value.length == 0 || signum == 0){\r\n            return 0;\r\n        }else{\r\n            if (value.length == 1 && (value[0] > 0)){\r\n                // simple Integer Value\r\n                return Utils.double2long(value[0] / scaleDoubleFactor[scale] * signum);\r\n            }else\r\n            if (value.length == 1){\r\n                // overflow Integer Value\r\n                long temp = value[0] & 0xFFFFFFFFL;\r\n                return Utils.double2long(temp / scaleDoubleFactor[scale] * signum);\r\n            }else\r\n            if (value.length == 2 && (value[0] > 0)){\r\n                // simple Long Value\r\n                long temp = (((long)value[0]) << 32) | (value[1] & 0xFFFFFFFFL);\r\n                return Utils.double2long(temp / scaleDoubleFactor[scale] * signum);\r\n            }else{\r\n           \t\tif(scale != 0){\r\n           \t\t\tMutableNumeric numeric = new MutableNumeric(this);\r\n           \t\t\tnumeric.setScale(0);\r\n           \t\t\treturn numeric.longValue();\r\n           \t\t}           \t\t\t\r\n            \treturn (signum > 0) ? Long.MAX_VALUE : Long.MIN_VALUE;\r\n            }\r\n        }\r\n    }","startLine":7,"lastLine":10}],"window":3},{"content":"}store.setCurrentOffsetInPage(offsetInPage + size);}","cloneLocs":[{"locFile":"java+constructor:///smallsql/database/View/View(smallsql.database.SSConnection,java.lang.String,java.nio.channels.FileChannel,long)","rawLines":"/**\r\n\t * Constructor for loading an existing view. \r\n\t */\r\n\tView(SSConnection con, String name, FileChannel raFile, long offset) throws Exception{\r\n\t\tsuper( name, new Columns() );\r\n\t\tStorePage storePage = new StorePage( null, -1, raFile, offset);\r\n\t\tStoreImpl store = StoreImpl.createStore( null, storePage, SQLTokenizer.SELECT, offset);\r\n\t\tsql = store.readString();\r\n\t\t\r\n\t\t// read additional informations\r\n\t\tint type;\r\n\t\twhile((type = store.readInt()) != 0){\r\n\t\t\tint offsetInPage = store.getCurrentOffsetInPage();\r\n\t\t\tint size = store.readInt();\r\n\t\t\tswitch(type){\r\n\t\t\t\t//currently there are no additinal informations, see write()\r\n\t\t\t}\r\n\t\t\tstore.setCurrentOffsetInPage(offsetInPage + size);\r\n\t\t}\r\n\t\t\r\n\t\traFile.close();\r\n\t\tcommandSelect = (CommandSelect)new SQLParser().parse(con, sql);\r\n\t\tcreateColumns(con);\r\n\t}","startLine":16,"lastLine":18},{"locFile":"java+constructor:///smallsql/database/Table/Table(smallsql.database.Database,smallsql.database.SSConnection,java.lang.String,java.nio.channels.FileChannel,long,int)","rawLines":"/**\r\n\t * Constructor for read existing tables.\r\n\t */\r\n    Table( Database database, SSConnection con, String name, FileChannel raFile, long offset, int tableFormatVersion) throws Exception{\r\n        super( name, new Columns() );\r\n        this.database = database;\r\n        this.raFile   = raFile;\r\n\t\tthis.firstPage = offset;\r\n\t\tStoreImpl store = getStore(con, firstPage, SQLTokenizer.SELECT);\r\n        if(store == null){\r\n            throw SmallSQLException.create(Language.TABLE_FILE_INVALID, getFile(database));\r\n        }\r\n\t\tint count = store.readInt();\r\n\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tcolumns.add( store.readColumn(tableFormatVersion) );\r\n\t\t}\r\n\t\tindexes = new IndexDescriptions();\r\n        references = new ForeignKeys();\r\n\t\t\r\n\t\t// read additional informations\r\n\t\tint type;\r\n\t\twhile((type = store.readInt()) != 0){\r\n\t\t\tint offsetInPage = store.getCurrentOffsetInPage();\r\n\t\t\tint size = store.readInt();\r\n\t\t\tswitch(type){\r\n\t\t\t\tcase INDEX:\r\n\t\t\t\t\tindexes.add( IndexDescription.load( database, this, store) );\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tstore.setCurrentOffsetInPage(offsetInPage + size);\r\n\t\t}\r\n\t\t\r\n\t\tfirstPage = store.getNextPagePos();\r\n    }","startLine":29,"lastLine":31}],"window":3},{"content":"}break;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/convertExpressionIfNeeded(smallsql.database.Expression,smallsql.database.Expression)","rawLines":"private Expression convertExpressionIfNeeded( Expression expr, Expression other ){\r\n        if(expr == null || other == null){\r\n            return expr;\r\n        }\r\n        switch(expr.getDataType()){\r\n        case SQLTokenizer.CHAR:\r\n        case SQLTokenizer.NCHAR:\r\n        case SQLTokenizer.BINARY:\r\n            switch(other.getDataType()){\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CLOB:\r\n            case SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.VARBINARY:\r\n                ExpressionFunctionRTrim trim = new ExpressionFunctionRTrim();\r\n                trim.setParams(new Expression[]{expr});\r\n                return trim;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.BINARY:\r\n                if(other.getPrecision() > expr.getPrecision()){\r\n                    return new ExpressionFunctionConvert(new ColumnExpression(other), expr, null );\r\n                }\r\n                break; \r\n            }\r\n            break;\r\n        }\r\n        return expr;\r\n    }","startLine":26,"lastLine":28},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/setParamAt(smallsql.database.Expression,int)","rawLines":"final void setParamAt( Expression param, int idx){\r\n\t\tswitch(idx){\r\n\t\t\tcase 0:\r\n\t\t\t\tleft = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n                if(right != null){\r\n                    right = param;\r\n                }\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n                if(right != null){\r\n                    right2 = param;\r\n                }\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tif(inList != null && idx>0 && idx<=inList.length){\r\n\t\t\tinList[idx-1] = param;\r\n\t\t}\r\n\t\tsuper.setParamAt( param, idx );\r\n\t}","startLine":13,"lastLine":15},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/convertExpressionIfNeeded(smallsql.database.Expression,smallsql.database.Expression)","rawLines":"private Expression convertExpressionIfNeeded( Expression expr, Expression other ){\r\n        if(expr == null || other == null){\r\n            return expr;\r\n        }\r\n        switch(expr.getDataType()){\r\n        case SQLTokenizer.CHAR:\r\n        case SQLTokenizer.NCHAR:\r\n        case SQLTokenizer.BINARY:\r\n            switch(other.getDataType()){\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CLOB:\r\n            case SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.VARBINARY:\r\n                ExpressionFunctionRTrim trim = new ExpressionFunctionRTrim();\r\n                trim.setParams(new Expression[]{expr});\r\n                return trim;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.BINARY:\r\n                if(other.getPrecision() > expr.getPrecision()){\r\n                    return new ExpressionFunctionConvert(new ColumnExpression(other), expr, null );\r\n                }\r\n                break; \r\n            }\r\n            break;\r\n        }\r\n        return expr;\r\n    }","startLine":24,"lastLine":26},{"locFile":"java+method:///smallsql/database/Utils/like(java.lang.String,java.lang.String)","rawLines":"static boolean like(String value, String pattern){\r\n\t\tif(value == null || pattern == null) return false;\r\n\t\tif(pattern.length() == 0) return true;\r\n\r\n\t\tint mIdx = 0;//index in mask Array\r\n\t\tint sIdx = 0;//index in search Array\r\n\t\tboolean range = false;\r\n\t\tweiter:\r\n\t\twhile(pattern.length() > mIdx && value.length() > sIdx) {\r\n\t\t\tchar m = Character.toUpperCase(pattern.charAt(mIdx++));\r\n\t\t\tswitch(m) {\r\n\t\t\t\tcase '%':\r\n\t\t\t\t\trange = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '_':\r\n\t\t\t\t\tsIdx++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif(range) {//% wildcard is active\r\n\t\t\t\t\t\tfor(; sIdx < value.length(); sIdx++) {\r\n\t\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) == m) break;//Counter mustn't increment before break\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(sIdx >= value.length()) return false;\r\n\t\t\t\t\t\tint lastmIdx = mIdx - 1;\r\n\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t\twhile(pattern.length() > mIdx && value.length() > sIdx) {\r\n\t\t\t\t\t\t\tm = Character.toUpperCase(pattern.charAt(mIdx++));\r\n\t\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) != m) {\r\n\t\t\t\t\t\t\t\tif(m == '%' || m == '_') {\r\n\t\t\t\t\t\t\t\t\tmIdx--;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmIdx = lastmIdx;\r\n\t\t\t\t\t\t\t\tcontinue weiter;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trange = false;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) != m) return false;\r\n\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(pattern.length() > mIdx) {\r\n            //Search mask is not too ends yet it may only '%' be contained \r\n\t\t\tif(Character.toUpperCase(pattern.charAt(mIdx++)) != '%') return false;\r\n\t\t}\r\n\t\twhile(value.length() > sIdx && !range) return false;\r\n\t\treturn true;\r\n\t}","startLine":41,"lastLine":43},{"locFile":"java+method:///smallsql/database/SQLParser/datatype(boolean)","rawLines":"/**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }","startLine":112,"lastLine":114}],"window":3},{"content":"if(size >= data.length ){resize(size << 1);}","cloneLocs":[{"locFile":"java+method:///smallsql/database/LongList/add(long)","rawLines":"final void add(long value){\r\n\t\tif(size >= data.length ){\r\n\t\t\tresize(size << 1);\r\n\t\t}\r\n\t\tdata[ size++ ] = value;\r\n\t}","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/IndexDescriptions/add(smallsql.database.IndexDescription)","rawLines":"final void add(IndexDescription descr) throws SQLException{\r\n\t\tif(size >= data.length ){\r\n\t\t\tresize(size << 1);\r\n\t\t}\r\n        if(hasPrimary && descr.isPrimary()){\r\n            throw SmallSQLException.create(Language.PK_ONLYONE);\r\n        }\r\n        hasPrimary = descr.isPrimary();\r\n\t\tdata[size++] = descr;\r\n\t}","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/Expressions/add(smallsql.database.Expression)","rawLines":"final void add(Expression expr){\r\n\t\tif(size >= data.length ){\r\n\t\t\tresize(size << 1);\r\n\t\t}\r\n\t\tdata[size++] = expr;\r\n\t}","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/Expressions/add(int,smallsql.database.Expression)","rawLines":"final void add(int idx, Expression expr){\r\n\t\tif(size >= data.length ){\r\n\t\t\tresize(size << 1);\r\n\t\t}\r\n\t\tSystem.arraycopy( data, idx, data, idx+1, (size++)-idx);\r\n\t\tdata[idx] = expr;\r\n\t}","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/Strings/add(java.lang.String)","rawLines":"final void add(String descr){\r\n\t\tif(size >= data.length ){\r\n\t\t\tresize(size << 1);\r\n\t\t}\r\n\t\tdata[size++] = descr;\r\n\t}","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/database/ForeignKeys/add(smallsql.database.ForeignKey)","rawLines":"final void add(ForeignKey foreignKey){\r\n\t\tif(size >= data.length ){\r\n\t\t\tresize(size << 1);\r\n\t\t}\r\n\t\tdata[size++] = foreignKey;\r\n\t}","startLine":1,"lastLine":3}],"window":3},{"content":"buf.append('/');formatNumber( details.year % 100, 2, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":26,"lastLine":28},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":54,"lastLine":56}],"window":3},{"content":"Connection con = AllTests.getConnection();Statement st = con.createStatement();ResultSet rs;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOrderBy/testVarcharEmpty()","rawLines":"public void testVarcharEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vc\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( \"\", rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( table3, rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testVarbinaryEmpty()","rawLines":"public void testVarbinaryEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vb\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vb\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", new byte[0], rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", table3.getBytes(), rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestGroupBy/testGroupBy()","rawLines":"public void testGroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\trs = st.executeQuery(\"Select name FROM \" + table1 + \" Group By name\");\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( STR_VALUE1, rs.getObject(1) ); \r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( STR_VALUE2, rs.getObject(1) ); \r\n\t\t\r\n\t}","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/test_boolean()","rawLines":"public void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestStatement/testGeneratedKeys()","rawLines":"public void testGeneratedKeys() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key1')\", Statement.NO_GENERATED_KEYS);\r\n        try{\r\n            st.getGeneratedKeys();\r\n            fail(\"NO_GENERATED_KEYS\");\r\n        }catch(SQLException ex){\r\n            assertSQLException(\"01000\", 0, ex);\r\n        }\r\n        assertEquals(\"UpdateCount\", 1, st.getUpdateCount());\r\n        assertNull(\"getResultSet\", st.getResultSet());\r\n        \r\n        st.execute(\"Insert Into statement(c) Values('key2')\", Statement.RETURN_GENERATED_KEYS);\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertTrue(rs.next());\r\n        assertEqualsRsValue( new Long(rs.getLong(1)), rs, false );\r\n        assertFalse(rs.next());\r\n\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key3')\", Statement.RETURN_GENERATED_KEYS));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key4')\", new int[]{2,1});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key5')\", new int[]{2}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n\r\n        st.execute(\"Insert Into statement(c) Values('key6')\", new String[]{\"c\",\"i\"});\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",2,rs.getMetaData().getColumnCount());\r\n        assertRowCount(1,rs);\r\n\r\n        assertEquals(1,st.executeUpdate(\"Insert Into statement(c) Values('key7')\", new String[]{\"i\"}));\r\n        rs = st.getGeneratedKeys();\r\n        assertNotNull(\"RETURN_GENERATED_KEYS\", rs);\r\n        assertEquals(\"ColumnCount\",1,rs.getMetaData().getColumnCount());\r\n        assertEquals(\"ColumnCount\",\"i\",rs.getMetaData().getColumnName(1));\r\n        assertRowCount(1,rs);\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/junit/TestGroupBy/testTest()","rawLines":"public void testTest() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t/*\r\n\t\trs = st.executeQuery(\"Select name FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\tSystem.out.println( rs.getObject(1) ); \r\n\t\t}*/\r\n\t\t\r\n\t\trs = st.executeQuery(\"Select count(id) FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\trs.getObject(1);\r\n\t\t}\r\n\r\n\t\trs = st.executeQuery(\"Select count(*) FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\trs.getObject(1);\r\n\t\t}\r\n\r\n\t\trs = st.executeQuery(\"Select count(*) FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 4, rs.getInt(1));\r\n\r\n\t\trs = st.executeQuery(\"Select count(id) FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 3, rs.getInt(1));\r\n\r\n\t\trs = st.executeQuery(\"Select count(*)+1 FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 5, rs.getInt(1));\r\n\t}","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_double()","rawLines":"public void testOrderBy_double() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tDouble oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by d\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Double)rs.getObject(\"d\") ) < 0 );\r\n\t\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":2,"lastLine":4},{"locFile":"java+method:///smallsql/junit/TestOrderBy/testOrderBy_real()","rawLines":"public void testOrderBy_real() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tFloat oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by r\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Float)rs.getObject(\"r\") ) < 0 );\r\n\t\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}","startLine":2,"lastLine":4}],"window":3},{"content":"return true;}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Scrollable/previous()","rawLines":"boolean previous() throws Exception{\r\n\t\tif(rowIdx > -1){\r\n\t\t\trowIdx--;\r\n\t\t\tif(rowIdx > -1 && rowIdx < rowList.size()){\r\n\t\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\trowSource.beforeFirst();\r\n\t\treturn false;\r\n\t}","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/database/SortedResult/next()","rawLines":"boolean next() throws Exception {\r\n\t\tif(useSetRowPosition) throw SmallSQLException.create(Language.ORDERBY_INTERNAL);\r\n        if(currentInsertedRow() < 0){\r\n    \t\tlong rowPosition = scrollStatus.getRowOffset(true);\r\n    \t\tif(rowPosition >= 0){\r\n                row++;\r\n    \t\t\trowSource.setRowPosition( rowPosition );\r\n    \t\t\treturn true;\r\n    \t\t}\r\n        }\r\n        if(currentInsertedRow() < insertedRows.size()-1){\r\n            row++;\r\n            rowSource.setRowPosition( insertedRows.get( currentInsertedRow() ) );\r\n            return true;\r\n        }\r\n        if(lastRowOffset >= 0){\r\n            rowSource.setRowPosition( lastRowOffset );\r\n        }else{\r\n            rowSource.beforeFirst();\r\n        }\r\n        if(rowSource.next()){\r\n            row++;\r\n            lastRowOffset = rowSource.getRowPosition();\r\n            insertedRows.add( lastRowOffset );\r\n            return true;\r\n        }\r\n        rowSource.noRow();\r\n        row = (getRowCount() > 0) ? getRowCount() + 1 : 0;\r\n\t\treturn false;\r\n\t}","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/Join/createJoinScrollIndex()","rawLines":"/**\r\n     * Create a ScrollJoin that based on a index. \r\n     * There must not exist a index on a table. If there is no index then a index will be created.\r\n     * @return null if it is not possible to create a ScrollJoin based on a Index\r\n     */\r\n    private boolean createJoinScrollIndex() throws Exception{\r\n        if(type == CROSS_JOIN){\r\n            return false;\r\n        }\r\n        if(type != INNER_JOIN){\r\n            // TODO currently only INNER JOIN are implemented\r\n            return false;\r\n        }\r\n        if(condition instanceof ExpressionArithmetic){\r\n            ExpressionArithmetic cond = (ExpressionArithmetic)condition;\r\n            Expressions leftEx = new Expressions();\r\n            Expressions rightEx = new Expressions();\r\n            int operation = createJoinScrollIndex(cond, leftEx, rightEx, 0);\r\n            if(operation != 0){\r\n                scroll = new JoinScrollIndex( type, left, right, leftEx, rightEx, operation);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","startLine":20,"lastLine":22},{"locFile":"java+method:///smallsql/database/Scrollable/absolute(int)","rawLines":"boolean absolute(int row) throws Exception{\r\n\t\tif(row == 0)\r\n\t\t\tthrow SmallSQLException.create(Language.ROW_0_ABSOLUTE);\r\n\t\tif(row < 0){\r\n\t\t\tafterLast();\r\n\t\t\trowIdx = rowList.size() + row;\r\n\t\t\tif(rowIdx < 0){\r\n\t\t\t\tbeforeFirst();\r\n\t\t\t\treturn false;\r\n\t\t\t}else{\r\n\t\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(row <= rowList.size()){\r\n\t\t\trowIdx = row-1;\r\n\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\trowIdx = rowList.size()-1;\r\n\t\tif(rowIdx >= 0)\r\n\t\t\trowSource.setRowPosition( rowList.get(rowIdx) );\r\n\t\tboolean result;\r\n\t\twhile((result = next()) && row-1 > rowIdx){/* scroll forward */}\r\n\t\treturn result;\r\n\t}","startLine":11,"lastLine":13},{"locFile":"java+method:///smallsql/database/Distinct/next()","rawLines":"final boolean next() throws Exception {\r\n\t\twhile(true){\r\n\t\t\tboolean isNext = rowSource.next();\r\n\t\t\tif(!isNext) return false;\r\n\r\n\t\t\tLong oldRowOffset = (Long)index.findRows(distinctColumns, true, null);\r\n\t\t\tlong newRowOffset = rowSource.getRowPosition();\r\n\t\t\tif(oldRowOffset == null){\r\n\t\t\t\tindex.addValues( newRowOffset, distinctColumns);\r\n\t\t\t\trow++;\r\n\t\t\t\treturn true;\r\n\t\t\t}else\r\n\t\t\tif(oldRowOffset.longValue() == newRowOffset){\r\n\t\t\t\trow++;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":14,"lastLine":16}],"window":3},{"content":"int count = 0;while(rs.next()){count++;","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BasicTestCase/assertRowCount(int,java.sql.ResultSet)","rawLines":"void assertRowCount(int sollCount, ResultSet rs ) throws Exception{\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tint count = 0;\r\n\t\t//System.out.println(sql);\r\n\t\twhile(rs.next()){\r\n\t\t\tcount++;\r\n\t\t\tfor(int i=1; i<=colCount; i++){\r\n\t\t\t\trs.getObject(i);\r\n\t\t\t\t//System.out.print( \" \"+rs.getObject(i));\r\n\t\t\t}\r\n\t\t\t//System.out.println();\r\n\t\t}\r\n\t\tassertEquals( \"Wrong row count\", sollCount, count);\r\n\t\tfor(int i=1; i<=colCount; i++){\r\n\t\t\ttry{\r\n\t\t\t\t// if not a SQLException occur then it is an error\r\n\t\t\t\tfail( \"Column:\"+i+\" Value:\"+String.valueOf(rs.getObject(i)));\r\n\t\t\t}catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\t\t}\r\n\t\tassertFalse( \"Scroll after last\", rs.next() );\r\n\t}","startLine":2,"lastLine":5},{"locFile":"java+method:///smallsql/junit/TestThreads/testConcurrentRead()","rawLines":"/**\r\n     * Test the concurrently read of a table\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentRead() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n\r\n        // Any table from another test that include rows.\r\n        final String sql = \"Select * From table_OrderBy1\";\r\n\r\n        // calculate the row count of this table\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs = st.executeQuery(\"Select * From table_OrderBy1\");\r\n        int count = 0;\r\n        while(rs.next()){\r\n            count++;\r\n        }\r\n        final int rowCount = count;\r\n\r\n        // start threads that check the row count\r\n        for(int i = 0; i < 200; i++){\r\n            Thread thread = new Thread(new Runnable(){\r\n\r\n                public void run(){\r\n                    try{\r\n                        assertRowCount(rowCount, sql);\r\n                    }catch(Throwable ex){\r\n                        throwable = ex;\r\n                    }\r\n                }\r\n\r\n            });\r\n            threadList.add(thread);\r\n            thread.start();\r\n        }\r\n\r\n        // wait until all threads are finish\r\n        for(int i = 0; i < threadList.size(); i++){\r\n            Thread thread = (Thread)threadList.get(i);\r\n            thread.join(5000);\r\n        }\r\n\r\n        // throw the exception if one occur\r\n        if(throwable != null){\r\n            throw throwable;\r\n        }\r\n    }","startLine":17,"lastLine":19}],"window":3},{"content":"case SQLTokenizer.REAL:case SQLTokenizer.FLOAT:case SQLTokenizer.DOUBLE:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/getInt(java.lang.Object,int)","rawLines":"static int getInt(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n                return ((Number)obj).intValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn (int)((DateTime)obj).getTimeMillis();\r\n            default:\r\n\t\t\t\tString str = obj.toString().trim();\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Integer.parseInt( str );\r\n\t\t\t\t}catch(Throwable th){/* A NumberFormatException can occur if it a floating point number */}\r\n\t\t\t\treturn (int)Double.parseDouble( str );\r\n        }\r\n    }","startLine":10,"lastLine":12},{"locFile":"java+method:///smallsql/database/ExpressionValue/getMoney(java.lang.Object,int)","rawLines":"static long getMoney(Object obj, int dataType) throws Exception{\r\n        if(obj == null) return 0;\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n                return (obj == Boolean.TRUE) ? 10000 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).longValue() * 10000;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                return Utils.doubleToMoney(((Number)obj).doubleValue());\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            \treturn ((Money)obj).value;\r\n            default: return Money.parseMoney( obj.toString() );\r\n        }\r\n\t}","startLine":10,"lastLine":12},{"locFile":"java+method:///smallsql/database/SSResultSetMetaData/isSignedDataType(int)","rawLines":"static boolean isSignedDataType(int dataType) {\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","startLine":9,"lastLine":11}],"window":3},{"content":"token = nextToken(MISSING_OUTER_JOIN);if(token.value == SQLTokenizer.OUTER)token = nextToken(MISSING_JOIN);","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/rowSource(smallsql.database.Command,smallsql.database.DataSources,int)","rawLines":"/**\r\n     * returns a row source. A row source is a Table, Join, View or a row function.\r\n     *\r\n     */\r\n    private RowSource rowSource(Command cmd, DataSources tables, int parenthesis) throws SQLException{\r\n        RowSource fromSource = null;\r\n        fromSource = tableSource(cmd, tables);\r\n\r\n        while(true){\r\n            SQLToken token = nextToken();\r\n            if(token == null) return fromSource;\r\n            switch(token.value){\r\n                case SQLTokenizer.ON:\r\n                    previousToken();\r\n                    return fromSource;\r\n                case SQLTokenizer.CROSS:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break\r\n                case SQLTokenizer.COMMA:\r\n                    fromSource = new Join( Join.CROSS_JOIN, fromSource, rowSource(cmd, tables, 0), null);\r\n                    break;\r\n                case SQLTokenizer.INNER:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break;\r\n                case SQLTokenizer.JOIN:\r\n                    fromSource = join( cmd, tables, fromSource, Join.INNER_JOIN );\r\n                    break;\r\n                case SQLTokenizer.LEFT:\r\n                    token = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n                    fromSource = join( cmd, tables, fromSource, Join.LEFT_JOIN );\r\n                    break;\r\n                case SQLTokenizer.RIGHT:\r\n                \ttoken = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.RIGHT_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n\t\t\t\tcase SQLTokenizer.FULL:\r\n\t\t\t\t\ttoken = nextToken(MISSING_OUTER_JOIN);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.OUTER)\r\n\t\t\t\t\t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.FULL_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.ESCAPE_R:\r\n                    if(parenthesis == token.value) return fromSource;\r\n                    if(parenthesis == 0){\r\n                    \tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                    }\r\n                    throw createSyntaxError( token, Language.STXADD_FROM_PAR_CLOSE );\r\n                default:\r\n                \tif(isKeyword(token)){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                \t}\r\n                    if(!fromSource.hasAlias()){\r\n                        fromSource.setAlias( token.getName( sql ) );\r\n                        break;\r\n                    }\r\n                    throw createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.GROUP, SQLTokenizer.ORDER, SQLTokenizer.HAVING} );\r\n            }\r\n        }\r\n    }","startLine":34,"lastLine":36},{"locFile":"java+method:///smallsql/database/SQLParser/rowSource(smallsql.database.Command,smallsql.database.DataSources,int)","rawLines":"/**\r\n     * returns a row source. A row source is a Table, Join, View or a row function.\r\n     *\r\n     */\r\n    private RowSource rowSource(Command cmd, DataSources tables, int parenthesis) throws SQLException{\r\n        RowSource fromSource = null;\r\n        fromSource = tableSource(cmd, tables);\r\n\r\n        while(true){\r\n            SQLToken token = nextToken();\r\n            if(token == null) return fromSource;\r\n            switch(token.value){\r\n                case SQLTokenizer.ON:\r\n                    previousToken();\r\n                    return fromSource;\r\n                case SQLTokenizer.CROSS:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break\r\n                case SQLTokenizer.COMMA:\r\n                    fromSource = new Join( Join.CROSS_JOIN, fromSource, rowSource(cmd, tables, 0), null);\r\n                    break;\r\n                case SQLTokenizer.INNER:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break;\r\n                case SQLTokenizer.JOIN:\r\n                    fromSource = join( cmd, tables, fromSource, Join.INNER_JOIN );\r\n                    break;\r\n                case SQLTokenizer.LEFT:\r\n                    token = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n                    fromSource = join( cmd, tables, fromSource, Join.LEFT_JOIN );\r\n                    break;\r\n                case SQLTokenizer.RIGHT:\r\n                \ttoken = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.RIGHT_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n\t\t\t\tcase SQLTokenizer.FULL:\r\n\t\t\t\t\ttoken = nextToken(MISSING_OUTER_JOIN);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.OUTER)\r\n\t\t\t\t\t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.FULL_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.ESCAPE_R:\r\n                    if(parenthesis == token.value) return fromSource;\r\n                    if(parenthesis == 0){\r\n                    \tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                    }\r\n                    throw createSyntaxError( token, Language.STXADD_FROM_PAR_CLOSE );\r\n                default:\r\n                \tif(isKeyword(token)){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                \t}\r\n                    if(!fromSource.hasAlias()){\r\n                        fromSource.setAlias( token.getName( sql ) );\r\n                        break;\r\n                    }\r\n                    throw createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.GROUP, SQLTokenizer.ORDER, SQLTokenizer.HAVING} );\r\n            }\r\n        }\r\n    }","startLine":28,"lastLine":30},{"locFile":"java+method:///smallsql/database/SQLParser/rowSource(smallsql.database.Command,smallsql.database.DataSources,int)","rawLines":"/**\r\n     * returns a row source. A row source is a Table, Join, View or a row function.\r\n     *\r\n     */\r\n    private RowSource rowSource(Command cmd, DataSources tables, int parenthesis) throws SQLException{\r\n        RowSource fromSource = null;\r\n        fromSource = tableSource(cmd, tables);\r\n\r\n        while(true){\r\n            SQLToken token = nextToken();\r\n            if(token == null) return fromSource;\r\n            switch(token.value){\r\n                case SQLTokenizer.ON:\r\n                    previousToken();\r\n                    return fromSource;\r\n                case SQLTokenizer.CROSS:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break\r\n                case SQLTokenizer.COMMA:\r\n                    fromSource = new Join( Join.CROSS_JOIN, fromSource, rowSource(cmd, tables, 0), null);\r\n                    break;\r\n                case SQLTokenizer.INNER:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break;\r\n                case SQLTokenizer.JOIN:\r\n                    fromSource = join( cmd, tables, fromSource, Join.INNER_JOIN );\r\n                    break;\r\n                case SQLTokenizer.LEFT:\r\n                    token = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n                    fromSource = join( cmd, tables, fromSource, Join.LEFT_JOIN );\r\n                    break;\r\n                case SQLTokenizer.RIGHT:\r\n                \ttoken = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.RIGHT_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n\t\t\t\tcase SQLTokenizer.FULL:\r\n\t\t\t\t\ttoken = nextToken(MISSING_OUTER_JOIN);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.OUTER)\r\n\t\t\t\t\t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.FULL_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.ESCAPE_R:\r\n                    if(parenthesis == token.value) return fromSource;\r\n                    if(parenthesis == 0){\r\n                    \tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                    }\r\n                    throw createSyntaxError( token, Language.STXADD_FROM_PAR_CLOSE );\r\n                default:\r\n                \tif(isKeyword(token)){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                \t}\r\n                    if(!fromSource.hasAlias()){\r\n                        fromSource.setAlias( token.getName( sql ) );\r\n                        break;\r\n                    }\r\n                    throw createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.GROUP, SQLTokenizer.ORDER, SQLTokenizer.HAVING} );\r\n            }\r\n        }\r\n    }","startLine":40,"lastLine":42}],"window":3},{"content":"final int getInt() throws Exception {if(isNull()) return 0;String str = param1.getString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionCharLen/getInt()","rawLines":"final int getInt() throws Exception {\r\n        if(isNull()) return 0;\r\n\r\n        String str = param1.getString();\r\n\t\t\r\n\t\treturn str.length();\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionBitLen/getInt()","rawLines":"final int getInt() throws Exception {\r\n        if(isNull()) return 0;\r\n\r\n        String str = param1.getString();\r\n\t\t\r\n\t\treturn str.length() * BYTES_PER_CHAR * 8;\r\n\t}","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/database/ExpressionFunctionOctetLen/getInt()","rawLines":"final int getInt() throws Exception {\r\n        if(isNull()) return 0;\r\n\r\n        String str = param1.getString();\r\n\t\t\r\n\t\treturn str.length() * BYTES_PER_CHAR;\r\n\t}","startLine":0,"lastLine":3}],"window":3},{"content":"while(rs.next()){rs.getObject(1);}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestGroupBy/testTest()","rawLines":"public void testTest() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t/*\r\n\t\trs = st.executeQuery(\"Select name FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\tSystem.out.println( rs.getObject(1) ); \r\n\t\t}*/\r\n\t\t\r\n\t\trs = st.executeQuery(\"Select count(id) FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\trs.getObject(1);\r\n\t\t}\r\n\r\n\t\trs = st.executeQuery(\"Select count(*) FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\trs.getObject(1);\r\n\t\t}\r\n\r\n\t\trs = st.executeQuery(\"Select count(*) FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 4, rs.getInt(1));\r\n\r\n\t\trs = st.executeQuery(\"Select count(id) FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 3, rs.getInt(1));\r\n\r\n\t\trs = st.executeQuery(\"Select count(*)+1 FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 5, rs.getInt(1));\r\n\t}","startLine":17,"lastLine":19},{"locFile":"java+method:///smallsql/junit/TestGroupBy/testTest()","rawLines":"public void testTest() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t/*\r\n\t\trs = st.executeQuery(\"Select name FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\tSystem.out.println( rs.getObject(1) ); \r\n\t\t}*/\r\n\t\t\r\n\t\trs = st.executeQuery(\"Select count(id) FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\trs.getObject(1);\r\n\t\t}\r\n\r\n\t\trs = st.executeQuery(\"Select count(*) FROM \" + table1 + \" Group By name\");\r\n\t\twhile(rs.next()){\r\n\t\t\trs.getObject(1);\r\n\t\t}\r\n\r\n\t\trs = st.executeQuery(\"Select count(*) FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 4, rs.getInt(1));\r\n\r\n\t\trs = st.executeQuery(\"Select count(id) FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 3, rs.getInt(1));\r\n\r\n\t\trs = st.executeQuery(\"Select count(*)+1 FROM \" + table1);\r\n\t\tassertTrue(rs.next());\r\n\t\tassertEquals( 5, rs.getInt(1));\r\n\t}","startLine":12,"lastLine":14}],"window":3},{"content":"Connection con = AllTests.getConnection();dropTable(con,\"testUpdate\");Statement st = con.createStatement();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestDeleteUpdate/testUpdate1()","rawLines":"public void testUpdate1() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tdropTable(con,\"testUpdate\");\r\n\t\tStatement st = con.createStatement();\r\n\t\tst.execute(\"create table testUpdate(id int default 15, value int)\");\r\n\t\tfor(int i=0; i<10; i++){\r\n\t\t\tst.execute(\"Insert into testUpdate Values(\"+i+','+i+\")\");\r\n\t\t}\r\n\t\tassertRowCount( 10, \"Select * from testUpdate\");\r\n\t\t\r\n\t\tint updateCount;\r\n\t\tupdateCount = st.executeUpdate(\"update testUpdate set value=103 Where id=3\");\r\n\t\tassertEqualsRsValue( new Integer(103), \"Select value from testUpdate Where id=3\");\r\n\t\tassertRowCount( 10, \"Select value from testUpdate\");\r\n\t\tassertEquals( 1, updateCount);\r\n\t\t\r\n\t\tupdateCount = st.executeUpdate(\"update testUpdate set value=104 Where id=3\");\r\n\t\tassertEqualsRsValue( new Integer(104), \"Select value from testUpdate Where id=3\");\r\n\t\tassertRowCount( 10, \"Select value from testUpdate\");\r\n\t\tassertEquals( 1, updateCount);\r\n\t\t\r\n\t\tupdateCount = st.executeUpdate(\"delete from testUpdate Where id=3\");\r\n\t\tassertRowCount( 9, \"Select * from testUpdate\");\r\n\t\tassertEquals( 1, updateCount);\r\n\r\n\t\tupdateCount = st.executeUpdate(\"update testUpdate set value=27 Where id<5\");\r\n\t\tassertEquals( 4, updateCount);\r\n\r\n\t\tdropTable(con,\"testUpdate\");\r\n\t}","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/junit/TestDeleteUpdate/testUpdate2()","rawLines":"public void testUpdate2() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tdropTable(con,\"testUpdate\");\r\n\t\tStatement st = con.createStatement();\r\n\t\tst.execute(\"create table testUpdate(id int default 15, value1 varchar(100), value2 int)\");\r\n\t\tfor(int i=0; i<10; i++){\r\n\t\t\tst.execute(\"Insert into testUpdate Values(\"+i+','+(i*100)+','+i+\")\");\r\n\t\t}\r\n\t\tassertRowCount( 10, \"Select * from testUpdate\");\r\n\t\t\r\n\t\tst.execute(\"update testUpdate set value1=13 Where id=3\");\r\n\t\tassertEqualsRsValue( \"13\", \"Select value1 from testUpdate Where id=3\");\r\n\t\tassertRowCount( 10, \"Select * from testUpdate\");\r\n\t\t\r\n\t\tst.execute(\"update testUpdate set value1=1040 Where id=3\");\r\n\t\tassertEqualsRsValue( \"1040\", \"Select value1 from testUpdate Where id=3\");\r\n\t\tassertRowCount( 10, \"Select * from testUpdate\");\r\n\t\t\r\n\t\tst.execute(\"update testUpdate set value1=10400 Where id=3\");\r\n\t\tassertEqualsRsValue( \"10400\", \"Select value1 from testUpdate Where id=3\");\r\n\t\tassertRowCount( 10, \"Select * from testUpdate\");\r\n\t\t\r\n\t\tst.execute(\"update testUpdate set value1=13,id=3 Where id=3\");\r\n\t\tassertEqualsRsValue( \"13\", \"Select value1 from testUpdate Where id=3\");\r\n\t\tassertRowCount( 10, \"Select * from testUpdate\");\r\n\t\t\r\n\t\tst.execute(\"delete from testUpdate Where id=3\");\r\n\t\tassertRowCount( 9, \"Select * from testUpdate\");\r\n\r\n\t\tdropTable(con,\"testUpdate\");\r\n\t}","startLine":1,"lastLine":3}],"window":3},{"content":"if(init) return;Connection con = AllTests.getConnection();Statement st = con.createStatement();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/setUp()","rawLines":"protected void setUp() throws Exception{\r\n    \tif(init) return;\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tdropTable( con, \"statement\");\r\n\t\tst.execute(\"Create Table statement (c varchar(30), i counter)\");\r\n\t\tinit = true;\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/junit/TestExceptions/init()","rawLines":"private void init() throws Exception{\r\n    \tif(init) return;\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tdropTable( con, \"exceptions\");\r\n\t\tst.execute(\"Create Table exceptions (c varchar(30), i int)\");\r\n\t\tinit = true;\r\n    }","startLine":1,"lastLine":3},{"locFile":"java+method:///smallsql/junit/TestResultSet/setUp()","rawLines":"protected void setUp() throws Exception{\r\n    \tif(init) return;\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tdropTable( con, \"ResultSet\");\r\n\t\tst.execute(\"Create Table ResultSet (i int identity, c varchar(30))\");\r\n        \r\n        st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs = st.executeQuery(\"Select * From ResultSet\");\r\n        \r\n        rs.moveToInsertRow();\r\n        rs.insertRow();\r\n        rs.moveToInsertRow();\r\n        rs.insertRow();\r\n\t\tinit = true;\r\n    }","startLine":1,"lastLine":3}],"window":3},{"content":"break;case SQLTokenizer.DOUBLE:case SQLTokenizer.FLOAT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":17,"lastLine":19},{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.IndexNode,smallsql.database.Expression,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}","startLine":23,"lastLine":25}],"window":3},{"content":"if(length == 0){return str1;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionFunctionReplace/getString()","rawLines":"final String getString() throws Exception {\r\n\t\tif(isNull()) return null;\r\n\t\tString str1 = param1.getString();\r\n\t\tString str2  = param2.getString();\r\n        int length = str2.length();\r\n        if(length == 0){\r\n            return str1;\r\n        }\r\n        String str3  = param3.getString();\r\n        StringBuffer buffer = new StringBuffer();\r\n        int idx1 = 0;\r\n        int idx2 = str1.indexOf(str2,idx1);\r\n        while(idx2 >= 0){\r\n            buffer.append(str1.substring(idx1,idx2));\r\n            buffer.append(str3);\r\n            idx1 = idx2 + length;\r\n            idx2 = str1.indexOf(str2,idx1);\r\n        }\r\n        if(idx1 > 0){\r\n            buffer.append(str1.substring(idx1));\r\n            return buffer.toString();\r\n        }\r\n\t\treturn str1;\r\n\t}","startLine":5,"lastLine":7},{"locFile":"java+method:///smallsql/database/ExpressionFunctionReplace/getBytes()","rawLines":"final byte[] getBytes() throws Exception{\r\n\t\tif(isNull()) return null;\r\n        byte[] str1 = param1.getBytes();\r\n        byte[] str2  = param2.getBytes();\r\n        int length = str2.length;\r\n        if(length == 0){\r\n            return str1;\r\n        }\r\n        byte[] str3  = param3.getBytes();\r\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n        int idx1 = 0;\r\n        int idx2 = Utils.indexOf(str2,str1,idx1);\r\n        while(idx2 > 0){\r\n            buffer.write(str1,idx1,idx2-idx1);\r\n            buffer.write(str3);\r\n            idx1 = idx2 + length;\r\n            idx2 = Utils.indexOf(str2,str1,idx1);\r\n        }\r\n        if(idx1 > 0){\r\n            buffer.write(str1,idx1,str1.length-idx1);\r\n            return buffer.toByteArray();\r\n        }\r\n        return str1;\r\n\t}","startLine":5,"lastLine":7}],"window":3},{"content":"break;case SQLTokenizer.NUMERIC:case SQLTokenizer.DECIMAL:","cloneLocs":[{"locFile":"java+method:///smallsql/database/StoreImpl/scanObjectOffsets(int%5B%5D,int%5B%5D)","rawLines":"@Override\r\n    void scanObjectOffsets( int[] offsets, int dataTypes[] ){\r\n        offset = PAGE_CONTROL_SIZE;\r\n        for(int i=0; i<offsets.length; i++){\r\n            offsets[i] = offset;\r\n            boolean isNull = readBoolean(); // for isNull\r\n            switch(dataTypes[i]){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                    int count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count;  // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    count = readByte();\r\n\t\t\t\t\toffset += 2;\r\n\t\t\t\t\tif(!isNull) offset += count*4;\r\n                    break;\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count << 1; // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                default: throw new Error(String.valueOf( dataTypes[i] ) );\r\n            }\r\n        }\r\n    }","startLine":41,"lastLine":43},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":55,"lastLine":57},{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.IndexNode,smallsql.database.Expression,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}","startLine":67,"lastLine":69},{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":60,"lastLine":62},{"locFile":"java+method:///smallsql/database/ExpressionValue/initValue(smallsql.database.Expression)","rawLines":"/**\r\n     * Init a summary field with a Mutable \r\n     * @param expr the expression that produce the values which should be summary\r\n     * @throws Exception\r\n     */\r\n\tprivate void initValue(Expression expr) throws Exception{\r\n\t\tdataType = expr.getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tvalue = new MutableInteger(expr.getInt());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tvalue = new MutableLong(expr.getLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\tvalue = new MutableFloat(expr.getFloat());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tvalue = new MutableDouble(expr.getDouble());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tvalue = Money.createFromUnscaledValue(expr.getMoney());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tvalue = new MutableNumeric(expr.getNumeric());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\tvalue = new DateTime(expr.getLong(), dataType);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\t// is used for MAX and MIN\r\n\t\t\t\tvalue = expr.getObject();\r\n\t\t}\r\n\t}","startLine":26,"lastLine":28},{"locFile":"java+method:///smallsql/database/StoreImpl/writeExpression(smallsql.database.Expression,smallsql.database.Column)","rawLines":"/**\r\n     * Here are pass only Expression instead of Objects to optimize \r\n     * it for native data (no object).\r\n     * The value of offset must be correctly. \r\n     * @param expr the value that should be written\r\n     * @param column a description of the target column\r\n     * @throws Exception if any error occur like conversions or io exceptions\r\n     */\r\n    void writeExpression( Expression expr, Column column) throws Exception{\r\n        boolean isNull = expr.isNull();\r\n        if(isNull && !column.isNullable()){\r\n            throw SmallSQLException.create(Language.VALUE_NULL_INVALID, column.getName());\r\n        }\r\n        int dataType = column.getDataType();\r\n        if(isNull){\r\n            writeBoolean(true); //true - is null\r\n            switch(dataType){\r\n                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();\r\n            }\r\n            return;\r\n        }\r\n        writeBoolean(false); // false - is not null\r\n       \tcolumn.setNewAutoIncrementValue(expr);\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    writeBoolean( expr.getBoolean() );\r\n                    break;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    writeBinary( expr.getBytes(), column.getPrecision(), dataType != SQLTokenizer.BINARY );\r\n                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:\r\n                    writeShort( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:\r\n                    writeLong( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.REAL:\r\n                    writeFloat( expr.getFloat() );\r\n                    break;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    writeDouble( expr.getDouble() );\r\n                    break;\r\n            case SQLTokenizer.MONEY:\r\n                    writeLong( expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    writeInt( (int)expr.getMoney() );\r\n                    break;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t\tMutableNumeric numeric = expr.getNumeric();\r\n            \t\tnumeric.setScale( column.getScale() );\r\n                    writeNumeric( numeric );\r\n                    break;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), false );\r\n                    break;\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    writeString( expr.getString(), column.getDisplaySize(), true );\r\n                    break;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    writeLongString( expr.getString() );\r\n                    break;\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    // FIXME a MemoryStream can be faster because there are no additional array copy\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n                    oos.writeObject( expr.getObject() );\r\n                    writeLongBinary( baos.toByteArray() );\r\n                    break;\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    writeLongBinary( expr.getBytes() );\r\n                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\tbyte[] bytes = expr.getBytes();\r\n                        if(bytes.length != 16) throw SmallSQLException.create(Language.BYTEARR_INVALID_SIZE, String.valueOf(bytes.length));\r\n                        writeBytes( bytes );\r\n\t\t\t\t\tdefault:\r\n                        writeBytes( Utils.unique2bytes(expr.getString()) );\r\n\t\t\t\t\t}\r\n                    break;\r\n            default: throw new Error(String.valueOf(column.getDataType()));\r\n        }\r\n    }","startLine":99,"lastLine":101},{"locFile":"java+method:///smallsql/database/SQLParser/datatype(boolean)","rawLines":"/**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }","startLine":83,"lastLine":85}],"window":3},{"content":"break;case SQLTokenizer.BIT:case SQLTokenizer.BOOLEAN:","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.IndexNode,smallsql.database.Expression,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}","startLine":63,"lastLine":65},{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":56,"lastLine":58}],"window":3},{"content":"case SQLTokenizer.TINYINT:case SQLTokenizer.SMALLINT:case SQLTokenizer.INT:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":117,"lastLine":119},{"locFile":"java+method:///smallsql/database/ExpressionValue/initValue(smallsql.database.Expression)","rawLines":"/**\r\n     * Init a summary field with a Mutable \r\n     * @param expr the expression that produce the values which should be summary\r\n     * @throws Exception\r\n     */\r\n\tprivate void initValue(Expression expr) throws Exception{\r\n\t\tdataType = expr.getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tvalue = new MutableInteger(expr.getInt());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tvalue = new MutableLong(expr.getLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\tvalue = new MutableFloat(expr.getFloat());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tvalue = new MutableDouble(expr.getDouble());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tvalue = Money.createFromUnscaledValue(expr.getMoney());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tvalue = new MutableNumeric(expr.getNumeric());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\tvalue = new DateTime(expr.getLong(), dataType);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\t// is used for MAX and MIN\r\n\t\t\t\tvalue = expr.getObject();\r\n\t\t}\r\n\t}","startLine":8,"lastLine":10},{"locFile":"java+method:///smallsql/database/ExpressionFunctionAbs/getObject()","rawLines":"Object getObject() throws Exception{\r\n\t\tif(param1.isNull()) return null;\r\n        Object para1 = param1.getObject();\r\n        switch(param1.getDataType()){\r\n        case SQLTokenizer.FLOAT:\r\n        case SQLTokenizer.DOUBLE:\r\n            double dValue = ((Double)para1).doubleValue();\r\n            return (dValue<0) ? new Double(-dValue) : para1;\r\n        case SQLTokenizer.REAL:\r\n            double fValue = ((Float)para1).floatValue();\r\n            return (fValue<0) ? new Float(-fValue) : para1;\r\n        case SQLTokenizer.BIGINT:\r\n            long lValue = ((Number)para1).longValue();\r\n            return (lValue<0) ? new Long(-lValue) : para1;\r\n        case SQLTokenizer.TINYINT:\r\n        case SQLTokenizer.SMALLINT:\r\n        case SQLTokenizer.INT:\r\n            int iValue = ((Number)para1).intValue();\r\n            return (iValue<0) ? new Integer(-iValue) : para1;\r\n        case SQLTokenizer.NUMERIC:\r\n        case SQLTokenizer.DECIMAL:\r\n            MutableNumeric nValue = (MutableNumeric)para1;\r\n            if(nValue.getSignum() <0) nValue.setSignum(1);\r\n            return nValue;\r\n        case SQLTokenizer.MONEY:\r\n            Money mValue = (Money)para1;\r\n            if(mValue.value <0) mValue.value = -mValue.value;\r\n            return mValue;\r\n        default: throw createUnspportedDataType(param1.getDataType());\r\n        }\r\n    }","startLine":14,"lastLine":16},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getNumeric()","rawLines":"MutableNumeric getNumeric() throws java.lang.Exception {\r\n        if(isNull()) return null;\r\n        int dataType = getDataType();\t\t\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn new MutableNumeric(getBoolean() ? 1 : 0);\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn new MutableNumeric(getIntImpl());\r\n            case SQLTokenizer.BIGINT:\r\n                return new MutableNumeric(getLongImpl());\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return new MutableNumeric(getFloatImpl());\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n                return new MutableNumeric( getDoubleImpl() );\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return getNumericImpl();\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn new MutableNumeric(getMoneyImpl(),4);\r\n        }\r\n\t\tthrow createUnspportedConversion( SQLTokenizer.DOUBLE);\r\n    }","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":32,"lastLine":34},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":25,"lastLine":27},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":60,"lastLine":62},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getMoney()","rawLines":"long getMoney() throws java.lang.Exception {\r\n        if(isNull()) return 0;\r\n        int dataType = getDataType();\t\t\r\n        switch(dataType){\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl() * 10000;\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl() * 10000;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return Utils.doubleToMoney( getFloatImpl() );\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return Utils.doubleToMoney( getDoubleImpl() );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn getMoneyImpl();\r\n        }\r\n\t\tthrow createUnspportedConversion( SQLTokenizer.DOUBLE);\r\n    }","startLine":7,"lastLine":9}],"window":3},{"content":"assertTrue( \"To few rows\", rs.next() );assertTrue( \"To few rows\", rs.next() );assertFalse( \"To many rows\", rs.next() );","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":28,"lastLine":30},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":55,"lastLine":57},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":50,"lastLine":52},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":44,"lastLine":46},{"locFile":"java+method:///smallsql/junit/TestOperatoren/runTest()","rawLines":"public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }","startLine":35,"lastLine":37}],"window":3},{"content":"break;}}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Utils/compareBytes(byte%5B%5D,byte%5B%5D)","rawLines":"static int compareBytes( byte[] leftBytes, byte[] rightBytes){\r\n        int length = Math.min( leftBytes.length, rightBytes.length );\r\n        int comp = 0;\r\n        for(int i=0; i<length; i++){\r\n            if(leftBytes[i] != rightBytes[i]){\r\n                comp = leftBytes[i] < rightBytes[i] ? -1 : 1;\r\n                break;\r\n            }\r\n        }\r\n        if(comp == 0 && leftBytes.length != rightBytes.length){\r\n            comp = leftBytes.length < rightBytes.length ? -1 : 1;\r\n        }\r\n        return comp;\r\n    }","startLine":6,"lastLine":8},{"locFile":"java+method:///smallsql/database/Index/numericToBinarySortOrder(smallsql.database.MutableNumeric)","rawLines":"final static private char[] numericToBinarySortOrder(MutableNumeric numeric){\r\n\t\tint[] value = numeric.getInternalValue();\r\n\t\tint count = 1;\r\n\t\tint i;\r\n\t\tfor(i=0; i<value.length; i++){\r\n\t\t\tif(value[i] != 0){\r\n\t\t\t\tcount = 2*(value.length - i)+1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tchar[] puffer = new char[count];\r\n\t\tpuffer[0] = (char)count;\r\n\t\tfor(int c=1; c<count;){\r\n\t\t\tpuffer[c++] = (char)(value[i] >> 16);\r\n\t\t\tpuffer[c++] = (char)value[i++];\r\n\t\t}\r\n\t\treturn puffer;\r\n\t}","startLine":7,"lastLine":9},{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":177,"lastLine":179},{"locFile":"java+method:///smallsql/database/CommandSelect/compile(smallsql.database.SSConnection)","rawLines":"boolean compile(SSConnection con) throws Exception{\r\n        boolean needCompile = false;\r\n        if(tables != null){\r\n            for(int i=0; i<tables.size(); i++){\r\n\t\t\t\tDataSource fromEntry = tables.get(i);\r\n                needCompile |= fromEntry.init( con );\r\n            }\r\n        }\r\n\r\n\t\tif(from == null){\r\n\t\t\tfrom = new NoFromResult();\r\n\t\t\ttables = new DataSources();\r\n\t\t\tneedCompile = true;\r\n\t\t}\r\n        if(!needCompile) return false;\r\n\r\n        for(int i=0; i<columnExpressions.size(); i++){\r\n            Expression col = columnExpressions.get(i);\r\n            if(col.getAlias() == null){\r\n                // generate automate names for expressions\r\n                col.setAlias(\"col\" + (i+1));\r\n            }\r\n\r\n            if(col.getType() != Expression.NAME){\r\n                compileLinkExpressionParams(col);\r\n                continue;\r\n            }\r\n\r\n            ExpressionName expr = (ExpressionName)col;\r\n\r\n            if(\"*\".equals( expr.getName() )){\r\n                String tableAlias = expr.getTableAlias();\r\n                if(tableAlias != null){\r\n                    // Syntax: tableAlias.*\r\n                    int t=0;\r\n                    for(; t<tables.size(); t++){\r\n\t\t\t\t\t\tDataSource fromEntry = tables.get(t);\r\n                        if(tableAlias.equalsIgnoreCase( fromEntry.getAlias() )){\r\n                            TableView table = fromEntry.getTableView();\r\n                            columnExpressions.remove(i);\r\n                            i = compileAdd_All_Table_Columns( fromEntry, table, i ) - 1;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(t==tables.size()) throw SmallSQLException.create(Language.COL_WRONG_PREFIX, new Object[] {tableAlias});\r\n                }else{\r\n                    // Syntax *\r\n                    columnExpressions.remove(i);\r\n                    for(int t=0; t<tables.size(); t++){\r\n\t\t\t\t\t\tDataSource fromEntry = tables.get(t);\r\n                        TableView table = fromEntry.getTableView();\r\n                        i = compileAdd_All_Table_Columns( fromEntry, table, i );\r\n                    }\r\n                    i--;\r\n                }\r\n            }else{\r\n            \t// not a * Syntax\r\n                compileLinkExpressionName( expr );\r\n            }\r\n\r\n        }\r\n        if(where != null) compileLinkExpression( where );\r\n        if(having != null) compileLinkExpression( having );\r\n        if(orderBy != null) {\r\n            for(int i=0; i<orderBy.size(); i++){\r\n            \tcompileLinkExpression( orderBy.get(i));\r\n            }\r\n        }\r\n\t\tif(groupBy != null){\r\n\t\t\tfor(int i=0; i<groupBy.size(); i++){\r\n\t\t\t\tcompileLinkExpression( groupBy.get(i) );\r\n\t\t\t}\r\n\t\t}\r\n\r\n        if(from instanceof Join){\r\n            compileJoin( (Join)from );\r\n        }\r\n        \r\n        if(where != null){\r\n        \tfrom = new Where( from, where );\r\n        }\r\n        \r\n\t\tif(isGroupResult()) {\r\n\t\t\tfrom = new GroupResult( this, from, groupBy, having, orderBy);\r\n\t\t\tif(having != null){\r\n                from = new Where( from, having );\r\n            }\r\n\t\t}\r\n\t\t\r\n\t\tif(isDistinct){\r\n\t\t\tfrom = new Distinct( from, columnExpressions );\r\n\t\t}\r\n\t\t\r\n\t\tif(orderBy != null){\r\n\t\t\tfrom = new SortedResult( from, orderBy );\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n    }","startLine":41,"lastLine":43},{"locFile":"java+method:///smallsql/database/MutableNumeric/setValue(byte%5B%5D)","rawLines":"private void setValue(byte[] complement){\r\n        int length = complement.length;\r\n        if(length == 0){\r\n            value   = EMPTY_INTS;\r\n            signum  = 0;\r\n            return;\r\n        }\r\n        value = new int[ (length + 3) / 4 ];\r\n        if(complement[0] < 0){\r\n            negate( complement );\r\n            signum = -1;\r\n        }else{\r\n\t\t\tsignum = 0;\r\n        \tfor(int i=0; i<complement.length; i++)\r\n        \t\tif(complement[i] != 0){\r\n        \t\t\tsignum = 1;\r\n        \t\t\tbreak;\r\n        \t\t}\r\n        }\r\n        for(int v=value.length-1; v>=0; v--){\r\n            int temp = 0;\r\n            for(int i=0; i<4 && 0<length; i++){\r\n                temp |= (complement[ --length ] & 0xFF) << (i*8);\r\n            }\r\n            value[v] = temp;\r\n        }\r\n    }","startLine":16,"lastLine":18},{"locFile":"java+method:///smallsql/database/SQLTokenizer/parseSQL(char%5B%5D)","rawLines":"public static List parseSQL( char[] sql ) throws SQLException{\r\n        SearchNode node = searchTree;\r\n        ArrayList tokens = new ArrayList();\r\n        int value = 0;\r\n        int tokenStart = 0;\r\n        boolean wasWhiteSpace = true;\r\n        int comment = NOT_COMMENT;\r\n        char quote = 0;\r\n        StringBuffer quoteBuffer = new StringBuffer();\r\n\r\n        for(int i=0; i<sql.length; i++){\r\n            char c = sql[i];\r\n            switch(c){\r\n                case '\\\"':\r\n                case '\\'':\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                quote = c;\r\n                            }else if(quote == c){\r\n                                // check on escaped quote\r\n                                if(i+1<sql.length && sql[i+1] == quote){\r\n                                    quoteBuffer.append(quote);\r\n                                    i++;\r\n                                }else{\r\n                                    tokens.add( new SQLToken( quoteBuffer.toString(), (quote == '\\'') ? STRING : IDENTIFIER,       tokenStart, i+1) );\r\n                                    quoteBuffer.setLength(0);\r\n                                    quote = 0;\r\n                                    tokenStart = i+1;\r\n                                    wasWhiteSpace = true;\r\n                                }\r\n                            }else quoteBuffer.append(c);\r\n                            break;\r\n                case '.':\r\n\t\t        \t\t\tif (comment != NOT_COMMENT) {\r\n\t\t        \t\t\t\tbreak;\r\n\t\t        \t\t\t}else if(quote == 0){\r\n                            \t// there are follow cases with a point\r\n                            \t// \"abc\".\"abc\"\t--> identifier --> multiple tokens\r\n                            \t// \"5\".\"3\"\t\t--> identifier --> multiple tokens\r\n                            \t// 5.3\t\t\t--> number --> one token\r\n                            \t// 5.e3\t\t\t--> number --> one token\r\n                            \t// .3\t\t\t--> number --> one token\r\n                            \t// .e3\t\t\t--> identifier --> multiple tokens\r\n                                int k=tokenStart;\r\n                                if(k == i){ // point is first character\r\n                                \tif(sql.length> k+1){\r\n\t\t\t\t\t\t\t\t\t\tchar cc = sql[k+1];\r\n\t\t\t\t\t\t\t\t\t\tif((cc >= '0') && cc <= '9') break; // is a number --> break\r\n                                \t}\r\n                                }else{\r\n\t                                for(; k<i; k++){\r\n\t                                    char cc = sql[k];\r\n\t                                    if((cc != '-' && cc != '$' && cc < '0') || cc > '9') break; // is identifier --> break\r\n\t                                }\r\n\t\t\t\t\t\t\t\t\tif(k>=i) break; // preceding tokens are only digits that it is not an identifier else a floating number\r\n                                }\r\n                            }\r\n                            // character before is not a digit that it is an identifier\r\n                            // no break;\r\n\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\tif (comment != NOT_COMMENT) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* start of single line comment */\r\n\t\t\t\t\t\t\telse if (c == '-' && (i+1 < sql.length) && (sql[i+1] == '-')) {\r\n\t                            if(!wasWhiteSpace){\r\n\t                                tokens.add( new SQLToken( value, tokenStart, i) );\r\n\t                                value = 0;\r\n\t                            }\r\n\t\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t\t\ttokenStart = i+1;\r\n\t\t\t\t\t\t\t\tcomment = LINE_COMMENT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(quote == 0 && !wasWhiteSpace){\r\n\t\t\t\t\t\t\t\tchar c1 = sql[tokenStart];\r\n\t\t\t\t\t\t\t\tchar cx = sql[i-1];\r\n\t\t\t\t\t\t\t\tif(((c1 >= '0' && c1 <= '9') || c1 == '.') && (cx == 'e' || cx == 'E'))\r\n\t\t\t\t\t\t\t\t\t//negative exponential number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tif(c1 == '$' && tokenStart+1 == i)\r\n\t\t\t\t\t\t\t\t\t// money number\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n                case ' ':\r\n\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':\r\n                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':\r\n                \t\t\t/* end of line comment */\r\n                \t\t\tif (comment == LINE_COMMENT) {\r\n                \t\t\t\t// '\\r'/'\\n' check needed because of fall-through\r\n                \t\t\t\tif (c == '\\r' || c == '\\n') {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                \t\t\t\t}\r\n                                tokenStart = i+1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\t/* end of multi-line comment */\r\n                \t\t\telse if (comment == MULTI_COMMENT) {\r\n                \t\t\t\t// '*' check needed because of fall-through\r\n                \t\t\t\tif (c == '*' && (i+1 < sql.length) && (sql[i+1] == '/')) {\r\n                \t\t\t\t\tcomment = NOT_COMMENT;\r\n                                    wasWhiteSpace = true;\r\n                                    i++;\r\n                \t\t\t\t}\r\n                                tokenStart = i + 1;\r\n                \t\t\t\tbreak;\r\n                \t\t\t}\r\n                \t\t\telse if(quote == 0){\r\n                                if(!wasWhiteSpace){\r\n                                   tokens.add( new SQLToken( value, tokenStart, i) );\r\n                                   value = 0;\r\n                                }\r\n                                switch(c){\r\n\t\t\t\t\t\t\t\t\tcase ' ':\r\n                                \tcase '\\t':\r\n                                \tcase '\\n':\r\n                                \tcase '\\r':\r\n                                    \t// skip this characters, this are not tokens, this are only source formatter   \r\n                                    \tbreak;\r\n                                    case '<':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '>')){\r\n                                            tokens.add( new SQLToken( UNEQUALS, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    case '>':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '=')){\r\n                                            tokens.add( new SQLToken( 100 + c, i, i+2) );\r\n                                            i++;\r\n                                            break;\r\n                                        }\r\n                                    /* start of multi-line comment */\r\n                                    case '/':\r\n                                        if((i+1 < sql.length) && (sql[i+1] == '*')){\r\n            \t\t\t\t\t\t\t\ti++;\r\n            \t\t\t\t\t\t\t\ttokenStart = i+1;\r\n            \t\t\t\t\t\t\t\tcomment = MULTI_COMMENT;\r\n                                            break;\r\n                                        }\r\n                                    default:\r\n                                        tokens.add( new SQLToken( c, i, i+1) );\r\n                                }\r\n                                wasWhiteSpace = true;\r\n                                tokenStart = i+1;\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            break;\r\n                default:\r\n                \t\t\tif (comment != NOT_COMMENT) {\r\n                \t\t\t\tbreak;\r\n                \t\t\t}else if(quote == 0){\r\n                                if(wasWhiteSpace){\r\n                                     node = searchTree;\r\n                                }else{\r\n                                    if(node == null){\r\n                                        value = 0;\r\n                                        wasWhiteSpace = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n\t\t\t\t\t\t\t\tc |= 0x20; // case insensitive\r\n                                while(node != null && node.letter != c) node = node.nextEntry;\r\n                                if(node != null){\r\n                                    value = node.value;\r\n                                    node = node.nextLetter;\r\n                                }else{\r\n                                    value = 0;\r\n                                    node = null;\r\n                                }\r\n                            }else{\r\n                                quoteBuffer.append(c);\r\n                            }\r\n                            wasWhiteSpace = false;\r\n                            break;\r\n            }\r\n        }\r\n        if (comment == MULTI_COMMENT) {\r\n        \tthrow SmallSQLException.create(Language.STXADD_COMMENT_OPEN);\r\n        }        \r\n        if(!wasWhiteSpace) {\r\n           tokens.add( new SQLToken( value, tokenStart, sql.length) );\r\n        }\r\n        \r\n        return tokens;\r\n    }","startLine":193,"lastLine":195},{"locFile":"java+method:///smallsql/database/Utils/like(java.lang.String,java.lang.String)","rawLines":"static boolean like(String value, String pattern){\r\n\t\tif(value == null || pattern == null) return false;\r\n\t\tif(pattern.length() == 0) return true;\r\n\r\n\t\tint mIdx = 0;//index in mask Array\r\n\t\tint sIdx = 0;//index in search Array\r\n\t\tboolean range = false;\r\n\t\tweiter:\r\n\t\twhile(pattern.length() > mIdx && value.length() > sIdx) {\r\n\t\t\tchar m = Character.toUpperCase(pattern.charAt(mIdx++));\r\n\t\t\tswitch(m) {\r\n\t\t\t\tcase '%':\r\n\t\t\t\t\trange = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '_':\r\n\t\t\t\t\tsIdx++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif(range) {//% wildcard is active\r\n\t\t\t\t\t\tfor(; sIdx < value.length(); sIdx++) {\r\n\t\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) == m) break;//Counter mustn't increment before break\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(sIdx >= value.length()) return false;\r\n\t\t\t\t\t\tint lastmIdx = mIdx - 1;\r\n\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t\twhile(pattern.length() > mIdx && value.length() > sIdx) {\r\n\t\t\t\t\t\t\tm = Character.toUpperCase(pattern.charAt(mIdx++));\r\n\t\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) != m) {\r\n\t\t\t\t\t\t\t\tif(m == '%' || m == '_') {\r\n\t\t\t\t\t\t\t\t\tmIdx--;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmIdx = lastmIdx;\r\n\t\t\t\t\t\t\t\tcontinue weiter;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trange = false;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) != m) return false;\r\n\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(pattern.length() > mIdx) {\r\n            //Search mask is not too ends yet it may only '%' be contained \r\n\t\t\tif(Character.toUpperCase(pattern.charAt(mIdx++)) != '%') return false;\r\n\t\t}\r\n\t\twhile(value.length() > sIdx && !range) return false;\r\n\t\treturn true;\r\n\t}","startLine":42,"lastLine":44},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getKeywordFromOperation(int)","rawLines":"/**\r\n     * This method only for creating an error message. Thats there is no optimizing.\r\n     * @param value\r\n     * @return\r\n     */\r\n    private static String getKeywordFromOperation(int operation){\r\n    \tint token = 0;\r\n    \tfor(int i=1; i<1000; i++){\r\n    \t\tif(getOperationFromToken(i) == operation){\r\n\t\t\t\ttoken = i;\r\n\t\t\t\tbreak;\r\n    \t\t}\r\n    \t}\r\n    \tif(operation == NEGATIVE)  token = SQLTokenizer.MINUS;\r\n    \tif(operation == ISNOTNULL) token =  SQLTokenizer.IS;\r\n    \tString keyword = SQLTokenizer.getKeyWord(token);\r\n    \tif(keyword == null) keyword = \"\" + (char)token;\r\n    \treturn keyword;\r\n    }","startLine":10,"lastLine":12}],"window":3},{"content":"formatNumber( details.month+1, 2, buf);formatNumber( details.day, 2, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":182,"lastLine":184},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":177,"lastLine":179}],"window":3},{"content":"String message = \"Check DisplaySize: \" + expectedLen + \"!=\" + Integer.MAX_VALUE + \")\";assertTrue( message, expectedLen == Integer.MAX_VALUE );}","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BasicTestCase/assertEqualsRsValue(java.lang.Object,java.sql.ResultSet,boolean)","rawLines":"void assertEqualsRsValue(Object obj, ResultSet rs, boolean needTrim) throws Exception{\r\n        String name = rs.getMetaData().getColumnName(1);\r\n\t\tassertEqualsObject( \"Values not identical on read:\", obj, rs.getObject(name), needTrim);\r\n\t\tif(obj instanceof Time){\r\n\t\t\tassertEquals(\"Time is different:\", obj, rs.getTime(name) );\r\n\t\t\tassertEquals(\"Time String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof Timestamp){\r\n\t\t\tassertEquals(\"Timestamp is different:\", obj, rs.getTimestamp(name) );\r\n\t\t\tassertEquals(\"Timestamp String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof Date){\r\n\t\t\tassertEquals(\"Date is different:\", obj, rs.getDate(name) );\r\n\t\t\tassertEquals(\"Date String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof String){\r\n            String str = (String)obj;\r\n            assertEqualsObject(\"String is different:\", str, rs.getString(name), needTrim );\r\n\t\t\tassertEquals(\"String Boolean is different:\", string2boolean(str), rs.getBoolean(name) );\r\n            try{\r\n                assertEquals(\"String Long is different:\", Long.parseLong(str), rs.getLong(name) );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Integer is different:\", Integer.parseInt(str), rs.getInt(name) );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Float is different:\", Float.parseFloat(str), rs.getFloat(name), 0.0 );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Double is different:\", Double.parseDouble(str), rs.getDouble(name), 0.0 );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n\t\t}\r\n\t\tif(obj instanceof BigDecimal){\r\n            if(!needTrim){\r\n                assertEquals(\"BigDecimal is different:\", obj, rs.getBigDecimal(name) );\r\n                assertEquals(\"Scale is different:\", ((BigDecimal)obj).scale(), rs.getMetaData().getScale(1));\r\n            }\r\n            assertEquals(\"Scale Meta is different:\", rs.getBigDecimal(name).scale(), rs.getMetaData().getScale(1));\r\n\t\t\tBigDecimal big2 = ((BigDecimal)obj).setScale(2,BigDecimal.ROUND_HALF_EVEN);\r\n\t\t\tassertEquals(\"BigDecimal mit scale is different:\", big2, rs.getBigDecimal(name, 2) );\r\n\t\t}\r\n\t\tif(obj instanceof Integer){\r\n\t\t\tassertEquals(\"Scale is different:\", 0, rs.getMetaData().getScale(1));\r\n\t\t}\r\n\t\tif(obj instanceof Number){\r\n            long longValue = ((Number)obj).longValue();\r\n\t\t\tint intValue = ((Number)obj).intValue();\r\n            if(longValue >= Integer.MAX_VALUE)\r\n                intValue = Integer.MAX_VALUE;\r\n            if(longValue <= Integer.MIN_VALUE)\r\n                intValue = Integer.MIN_VALUE;\r\n\t\t\tassertEquals(\"int is different:\", intValue, rs.getInt(name) );\r\n\t\t\tassertEquals(\"long is different:\", longValue, rs.getLong(name) );\r\n\t\t\tif(intValue >= Short.MIN_VALUE && intValue <= Short.MAX_VALUE)\r\n\t\t\t\tassertEquals(\"short is different:\", (short)intValue, rs.getShort(name) );\r\n\t\t\tif(intValue >= Byte.MIN_VALUE && intValue <= Byte.MAX_VALUE)\r\n\t\t\t\tassertEquals(\"byte is different:\", (byte)intValue, rs.getByte(name) );\r\n\t\t\t\r\n\t\t\tdouble value = ((Number)obj).doubleValue();\r\n\t\t\tassertEquals(\"Double is different:\", value, rs.getDouble(name),0.0 );\r\n\t\t\tassertEquals(\"Float is different:\", (float)value, rs.getFloat(name),0.0 );\r\n\t\t\tString valueStr = obj.toString();\r\n            if(!needTrim){\r\n                assertEquals(\"Number String is different:\", valueStr, rs.getString(name) );\r\n            }\r\n\t\t\tBigDecimal decimal = Double.isInfinite(value) || Double.isNaN(value) ? null : new BigDecimal(valueStr);\r\n            assertEqualsObject(\"Number BigDecimal is different:\", decimal, rs.getBigDecimal(name) );\r\n\t\t\tassertEquals(\"Number boolean is different:\", value != 0, rs.getBoolean(name) );\r\n\t\t}\r\n\t\tif(obj == null){\r\n\t\t\tassertNull(\"String is different:\", rs.getString(name) );\r\n\t\t\tassertNull(\"Date is different:\", rs.getDate(name) );\r\n\t\t\tassertNull(\"Time is different:\", rs.getTime(name) );\r\n\t\t\tassertNull(\"Timestamp is different:\", rs.getTimestamp(name) );\r\n\t\t\tassertNull(\"BigDecimal is different:\", rs.getBigDecimal(name) );\r\n\t\t\tassertNull(\"BigDecimal with scale is different:\", rs.getBigDecimal(name, 2) );\r\n\t\t\tassertNull(\"Bytes with scale is different:\", rs.getBytes(name) );\r\n\t\t\tassertEquals(\"Double is different:\", 0, rs.getDouble(name),0 );\r\n\t\t\tassertEquals(\"Float is different:\", 0, rs.getFloat(name),0 );\r\n\t\t\tassertEquals(\"Long is different:\", 0, rs.getLong(name) );\r\n\t\t\tassertEquals(\"Int is different:\", 0, rs.getInt(name) );\r\n\t\t\tassertEquals(\"SmallInt is different:\", 0, rs.getShort(name) );\r\n\t\t\tassertEquals(\"TinyInt is different:\", 0, rs.getByte(name) );\r\n\t\t\tassertEquals(\"Boolean is different:\", false, rs.getBoolean(name) );\r\n\t\t}\r\n\t\tif(obj instanceof byte[]){\r\n\t\t    assertTrue(\"Binary should start with 0x\", rs.getString(name).startsWith(\"0x\"));\r\n\t\t}\r\n\t\t\r\n\t\tResultSetMetaData metaData = rs.getMetaData();\r\n\t\tString className = metaData.getColumnClassName(1);\r\n\t\tassertNotNull( \"ClassName:\", className);\r\n\t\tif(obj != null){\r\n\t\t\tClass gotClass = Class.forName(className);\r\n\t\t\tClass objClass = obj.getClass();\r\n\t\t\tString objClassName = objClass.getName();\r\n\t\t\t\r\n\t\t\tint expectedLen = metaData.getColumnDisplaySize(1);\r\n\r\n\t\t\t// B/CLOBs must be treated as special cases\t\t\t\r\n\t\t\tif (gotClass.equals(java.sql.Blob.class)) {\r\n\t\t\t\tassertTrue(\r\n\t\t\t\t\t\"ClassName assignable: \"+className+\"<->\"+objClassName,\r\n\t\t\t\t\tobjClass.equals(new byte[0].getClass()));\r\n\r\n\t\t\t\tString message = \"Check DisplaySize: \" + expectedLen + \"!=\" + Integer.MAX_VALUE + \")\";\r\n\t\t\t\tassertTrue( message, expectedLen == Integer.MAX_VALUE );\r\n\t\t\t}\r\n\t\t\telse if (gotClass.equals(java.sql.Clob.class)) { // same as NCLOB\r\n\t\t\t\tassertTrue(\r\n\t\t\t\t\t\"ClassName assignable: \"+className+\"<->\"+objClassName,\r\n\t\t\t\t\tobjClass.equals(String.class));\r\n\r\n\t\t\t\tString message = \"Check DisplaySize: \" + expectedLen + \"!=\" + Integer.MAX_VALUE + \")\";\r\n\t\t\t\tassertTrue( message, expectedLen == Integer.MAX_VALUE );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tString foundStr = rs.getString(name);\r\n\t\t\t\t\r\n\t\t\t\tassertTrue(\"ClassName assignable: \"+className+\"<->\"+objClassName, gotClass.isAssignableFrom(objClass));\r\n\t\t\t\tassertTrue( \"DisplaySize to small \"+ expectedLen +\"<\"+foundStr.length()+\" (\" + foundStr + \")\", expectedLen >= foundStr.length() );\r\n\t\t\t}\r\n\t\t}\r\n   \t}","startLine":113,"lastLine":115},{"locFile":"java+method:///smallsql/junit/BasicTestCase/assertEqualsRsValue(java.lang.Object,java.sql.ResultSet,boolean)","rawLines":"void assertEqualsRsValue(Object obj, ResultSet rs, boolean needTrim) throws Exception{\r\n        String name = rs.getMetaData().getColumnName(1);\r\n\t\tassertEqualsObject( \"Values not identical on read:\", obj, rs.getObject(name), needTrim);\r\n\t\tif(obj instanceof Time){\r\n\t\t\tassertEquals(\"Time is different:\", obj, rs.getTime(name) );\r\n\t\t\tassertEquals(\"Time String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof Timestamp){\r\n\t\t\tassertEquals(\"Timestamp is different:\", obj, rs.getTimestamp(name) );\r\n\t\t\tassertEquals(\"Timestamp String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof Date){\r\n\t\t\tassertEquals(\"Date is different:\", obj, rs.getDate(name) );\r\n\t\t\tassertEquals(\"Date String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof String){\r\n            String str = (String)obj;\r\n            assertEqualsObject(\"String is different:\", str, rs.getString(name), needTrim );\r\n\t\t\tassertEquals(\"String Boolean is different:\", string2boolean(str), rs.getBoolean(name) );\r\n            try{\r\n                assertEquals(\"String Long is different:\", Long.parseLong(str), rs.getLong(name) );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Integer is different:\", Integer.parseInt(str), rs.getInt(name) );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Float is different:\", Float.parseFloat(str), rs.getFloat(name), 0.0 );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Double is different:\", Double.parseDouble(str), rs.getDouble(name), 0.0 );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n\t\t}\r\n\t\tif(obj instanceof BigDecimal){\r\n            if(!needTrim){\r\n                assertEquals(\"BigDecimal is different:\", obj, rs.getBigDecimal(name) );\r\n                assertEquals(\"Scale is different:\", ((BigDecimal)obj).scale(), rs.getMetaData().getScale(1));\r\n            }\r\n            assertEquals(\"Scale Meta is different:\", rs.getBigDecimal(name).scale(), rs.getMetaData().getScale(1));\r\n\t\t\tBigDecimal big2 = ((BigDecimal)obj).setScale(2,BigDecimal.ROUND_HALF_EVEN);\r\n\t\t\tassertEquals(\"BigDecimal mit scale is different:\", big2, rs.getBigDecimal(name, 2) );\r\n\t\t}\r\n\t\tif(obj instanceof Integer){\r\n\t\t\tassertEquals(\"Scale is different:\", 0, rs.getMetaData().getScale(1));\r\n\t\t}\r\n\t\tif(obj instanceof Number){\r\n            long longValue = ((Number)obj).longValue();\r\n\t\t\tint intValue = ((Number)obj).intValue();\r\n            if(longValue >= Integer.MAX_VALUE)\r\n                intValue = Integer.MAX_VALUE;\r\n            if(longValue <= Integer.MIN_VALUE)\r\n                intValue = Integer.MIN_VALUE;\r\n\t\t\tassertEquals(\"int is different:\", intValue, rs.getInt(name) );\r\n\t\t\tassertEquals(\"long is different:\", longValue, rs.getLong(name) );\r\n\t\t\tif(intValue >= Short.MIN_VALUE && intValue <= Short.MAX_VALUE)\r\n\t\t\t\tassertEquals(\"short is different:\", (short)intValue, rs.getShort(name) );\r\n\t\t\tif(intValue >= Byte.MIN_VALUE && intValue <= Byte.MAX_VALUE)\r\n\t\t\t\tassertEquals(\"byte is different:\", (byte)intValue, rs.getByte(name) );\r\n\t\t\t\r\n\t\t\tdouble value = ((Number)obj).doubleValue();\r\n\t\t\tassertEquals(\"Double is different:\", value, rs.getDouble(name),0.0 );\r\n\t\t\tassertEquals(\"Float is different:\", (float)value, rs.getFloat(name),0.0 );\r\n\t\t\tString valueStr = obj.toString();\r\n            if(!needTrim){\r\n                assertEquals(\"Number String is different:\", valueStr, rs.getString(name) );\r\n            }\r\n\t\t\tBigDecimal decimal = Double.isInfinite(value) || Double.isNaN(value) ? null : new BigDecimal(valueStr);\r\n            assertEqualsObject(\"Number BigDecimal is different:\", decimal, rs.getBigDecimal(name) );\r\n\t\t\tassertEquals(\"Number boolean is different:\", value != 0, rs.getBoolean(name) );\r\n\t\t}\r\n\t\tif(obj == null){\r\n\t\t\tassertNull(\"String is different:\", rs.getString(name) );\r\n\t\t\tassertNull(\"Date is different:\", rs.getDate(name) );\r\n\t\t\tassertNull(\"Time is different:\", rs.getTime(name) );\r\n\t\t\tassertNull(\"Timestamp is different:\", rs.getTimestamp(name) );\r\n\t\t\tassertNull(\"BigDecimal is different:\", rs.getBigDecimal(name) );\r\n\t\t\tassertNull(\"BigDecimal with scale is different:\", rs.getBigDecimal(name, 2) );\r\n\t\t\tassertNull(\"Bytes with scale is different:\", rs.getBytes(name) );\r\n\t\t\tassertEquals(\"Double is different:\", 0, rs.getDouble(name),0 );\r\n\t\t\tassertEquals(\"Float is different:\", 0, rs.getFloat(name),0 );\r\n\t\t\tassertEquals(\"Long is different:\", 0, rs.getLong(name) );\r\n\t\t\tassertEquals(\"Int is different:\", 0, rs.getInt(name) );\r\n\t\t\tassertEquals(\"SmallInt is different:\", 0, rs.getShort(name) );\r\n\t\t\tassertEquals(\"TinyInt is different:\", 0, rs.getByte(name) );\r\n\t\t\tassertEquals(\"Boolean is different:\", false, rs.getBoolean(name) );\r\n\t\t}\r\n\t\tif(obj instanceof byte[]){\r\n\t\t    assertTrue(\"Binary should start with 0x\", rs.getString(name).startsWith(\"0x\"));\r\n\t\t}\r\n\t\t\r\n\t\tResultSetMetaData metaData = rs.getMetaData();\r\n\t\tString className = metaData.getColumnClassName(1);\r\n\t\tassertNotNull( \"ClassName:\", className);\r\n\t\tif(obj != null){\r\n\t\t\tClass gotClass = Class.forName(className);\r\n\t\t\tClass objClass = obj.getClass();\r\n\t\t\tString objClassName = objClass.getName();\r\n\t\t\t\r\n\t\t\tint expectedLen = metaData.getColumnDisplaySize(1);\r\n\r\n\t\t\t// B/CLOBs must be treated as special cases\t\t\t\r\n\t\t\tif (gotClass.equals(java.sql.Blob.class)) {\r\n\t\t\t\tassertTrue(\r\n\t\t\t\t\t\"ClassName assignable: \"+className+\"<->\"+objClassName,\r\n\t\t\t\t\tobjClass.equals(new byte[0].getClass()));\r\n\r\n\t\t\t\tString message = \"Check DisplaySize: \" + expectedLen + \"!=\" + Integer.MAX_VALUE + \")\";\r\n\t\t\t\tassertTrue( message, expectedLen == Integer.MAX_VALUE );\r\n\t\t\t}\r\n\t\t\telse if (gotClass.equals(java.sql.Clob.class)) { // same as NCLOB\r\n\t\t\t\tassertTrue(\r\n\t\t\t\t\t\"ClassName assignable: \"+className+\"<->\"+objClassName,\r\n\t\t\t\t\tobjClass.equals(String.class));\r\n\r\n\t\t\t\tString message = \"Check DisplaySize: \" + expectedLen + \"!=\" + Integer.MAX_VALUE + \")\";\r\n\t\t\t\tassertTrue( message, expectedLen == Integer.MAX_VALUE );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tString foundStr = rs.getString(name);\r\n\t\t\t\t\r\n\t\t\t\tassertTrue(\"ClassName assignable: \"+className+\"<->\"+objClassName, gotClass.isAssignableFrom(objClass));\r\n\t\t\t\tassertTrue( \"DisplaySize to small \"+ expectedLen +\"<\"+foundStr.length()+\" (\" + foundStr + \")\", expectedLen >= foundStr.length() );\r\n\t\t\t}\r\n\t\t}\r\n   \t}","startLine":105,"lastLine":107}],"window":3},{"content":"node.addRemainderKey( rowOffset, key, i );return null;}","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/add(smallsql.database.IndexNode,long,long,boolean,int)","rawLines":"/**\r\n\t * The key has a binary sort order. This means the most significant byte is in the high byte.\r\n\t * @param digitCount The count of 16Bit digits.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, long key, boolean isLastValue, int digitCount) throws SQLException{\r\n\t\tfor(int i=digitCount-1; i>=0; i--){\r\n\t\t\tchar digit = (char)(key >> (i<<4));\r\n\t\t\tif(i == 0){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i);\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.saveValue( rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\tthrow new Error();\r\n\t}","startLine":17,"lastLine":19},{"locFile":"java+method:///smallsql/database/Index/add(smallsql.database.IndexNode,long,char%5B%5D,boolean)","rawLines":"/**\r\n\t * Add a byte array to the Index.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, char[] key, boolean isLast) throws SQLException{\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tif(++i == length){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i );\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.saveValue(rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":20,"lastLine":22}],"window":3},{"content":"con.close();con = AllTests.getConnection();st = con.createStatement();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestDataTypes/runTest()","rawLines":"public void runTest() throws Throwable {\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table \" + table +\"(abc \" + datatype + \")\");\r\n        String name = \"abc\";\r\n\r\n        Object[] values = null;\r\n        String   quote = \"\";\r\n        String escape1 = \"\";\r\n        String escape2 = \"\";\r\n        boolean needTrim = false;\r\n\r\n        ResultSet rs = st.executeQuery(\"SELECT * From \" + table);\r\n\t\tResultSetMetaData md = rs.getMetaData();\r\n        switch(md.getColumnType(1)){\r\n            case Types.CHAR:\r\n                needTrim = true;\r\n            case Types.VARCHAR:\r\n            case Types.LONGVARCHAR:\r\n            case Types.CLOB:\r\n                values = new Object[]{null,\"qwert\", \"asdfg\", \"hjhjhj\", \"1234567890 qwertzuiop 1234567890 asdfghjklö 1234567890 yxcvbnm,.- 1234567890 \"};\r\n                quote  = \"\\'\";\r\n                break;\r\n            case Types.BIGINT:\r\n                values = new Object[]{null,new Long(123), new Long(-2123), new Long(392839283)};\r\n                break;\r\n            case Types.INTEGER:\r\n                values = new Object[]{null,new Integer(123), new Integer(-2123), new Integer(392839283)};\r\n                break;\r\n            case Types.SMALLINT:\r\n                values = new Object[]{null,new Integer(123), new Integer(-2123), new Integer(32000)};\r\n                break;\r\n            case Types.TINYINT:\r\n                values = new Object[]{null,new Integer(0), new Integer(12), new Integer(228)};\r\n                break;\r\n            case Types.REAL:\r\n                values = new Object[]{null,new Float(0.0), new Float(-12.123), new Float(22812345234.9)};\r\n                break;\r\n            case Types.FLOAT:\r\n            case Types.DOUBLE:\r\n                values = new Object[]{null,new Double(0.0), new Double(-12.123), new Double(22812345234.9)};\r\n                break;\r\n            case Types.NUMERIC:\r\n            case Types.DECIMAL:\r\n                needTrim = true;\r\n            \tif(md.getPrecision(1)<16){//smallmoney\r\n\t\t\t\t\tvalues = new Object[]{null,new BigDecimal(\"0.0\"), new BigDecimal(\"-2\"), new BigDecimal(\"-12.123\")};\r\n                /*if(rs.getMetaData().isCurrency(1)){\r\n                    values = new Object[]{null, new Money(0.0), new Money(-12.123), new Money(202812.9)};*/\r\n                }else{\r\n                    values = new Object[]{null,new BigDecimal(\"0.0\"), new BigDecimal(\"-2\"), new BigDecimal(\"-12.123\"), new BigDecimal(\"22812345234.9\")};\r\n                }\r\n                break;\r\n            case Types.BIT:\r\n            case Types.BOOLEAN:\r\n                values = new Object[]{null, Boolean.TRUE, Boolean.FALSE};\r\n                break;\r\n            case Types.TIME:\r\n                values = new Object[]{null, new Time(10,17,56), new Time(0,0,0),new Time(23,59,59)};\r\n                escape1 = \"{t '\";\r\n                escape2 = \"'}\";\r\n                break;\r\n\t\t\tcase Types.DATE:\r\n\t\t\t\tvalues = new Object[]{null, new java.sql.Date(10,10,1), new java.sql.Date(0,0,1),new java.sql.Date(70,0,1)};\r\n\t\t\t\tescape1 = \"{d '\";\r\n\t\t\t\tescape2 = \"'}\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase Types.TIMESTAMP:\r\n\t\t\t\tif(md.getPrecision(1) >16)\r\n\t\t\t\t\tvalues = new Object[]{null, new Timestamp(10,10,1, 10,17,56, 0), new Timestamp(0,0,1, 0,0,0, 0),new Timestamp( 120,1,1, 23,59,59, 500000000),new Timestamp(0),new Timestamp( -120,1,1, 23,59,59, 500000000)};\r\n\t\t\t\telse//smalldatetime\r\n\t\t\t\t\tvalues = new Object[]{null, new Timestamp(10,10,1, 10,17,0, 0), new Timestamp(0,0,1, 0,0,0, 0),new Timestamp(0)};\r\n\t\t\t\tescape1 = \"{ts '\";\r\n\t\t\t\tescape2 = \"'}\";\r\n\t\t\t\tbreak;\r\n            case Types.BINARY:\r\n                needTrim = true;\r\n            case Types.VARBINARY:\r\n            case Types.LONGVARBINARY:\r\n            case Types.BLOB:\r\n                values = new Object[]{null, new byte[]{1, 127, -23}};\r\n                break;\r\n            case Types.JAVA_OBJECT:\r\n                values = new Object[]{null, new Integer(-123), new Double(1.2), new byte[]{1, 127, -23}};\r\n                break;\r\n            case -11: //UNIQUEIDENTIFER\r\n                values = new Object[]{null, \"342734E3-D9AC-408F-8724-B7A257C4529E\", \"342734E3-D9AC-408F-8724-B7A257C4529E\"};\r\n                quote  = \"\\'\";\r\n                break;\r\n            default: fail(\"Unknown column type: \" + rs.getMetaData().getColumnType(1));\r\n        }\r\n        rs.close();\r\n\t\t\r\n\t\t// remove all resource for reloading the tables from file\r\n\t\tcon.close();\r\n\t\tcon = AllTests.getConnection();\r\n\t\tst = con.createStatement();\r\n\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n            String q = (val == null) ? \"\" : quote;\r\n            String e1 = (val == null) ? \"\" : escape1;\r\n            String e2 = (val == null) ? \"\" : escape2;\r\n            if(val instanceof byte[]){\r\n                StringBuffer buf = new StringBuffer( \"0x\" );\r\n                for(int k=0; k<((byte[])val).length; k++){\r\n                    String digit = \"0\" + Integer.toHexString( ((byte[])val)[k] );\r\n                    buf.append( digit.substring( digit.length()-2 ) );\r\n                }\r\n                val = buf.toString();\r\n            }\r\n            st.execute(\"Insert into \" + table + \"(abc) Values(\" + e1 + q + val + q + e2 + \")\");\r\n        }\r\n\t\tcheckValues( st, values, needTrim);\r\n\t\t\r\n\t\tst.execute(\"Delete From \"+ table);\r\n\t\tCallableStatement cal = con.prepareCall(\"Insert Into \" + table + \"(abc) Values(?)\");\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n\t\t\tcal.setObject( 1, val);\r\n\t\t\tcal.execute();\r\n        }\r\n\t\tcal.close();\r\n\t\tcheckValues( st, values, needTrim);\r\n\t\t\r\n\t\tst.execute(\"Delete From \"+ table);\r\n\t\tcal = con.prepareCall(\"Insert Into \" + table + \"(abc) Values(?)\");\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n\t\t\tif(val == null){\r\n\t\t\t\tcal.setNull( 1, Types.NULL );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Time){\r\n\t\t\t\tcal.setTime( 1, (Time)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Timestamp){\r\n\t\t\t\tcal.setTimestamp( 1, (Timestamp)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Date){\r\n\t\t\t\tcal.setDate( 1, (Date)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof String){\r\n\t\t\t\tcal.setString( 1, (String)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Boolean){\r\n\t\t\t\tcal.setBoolean( 1, ((Boolean)val).booleanValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Byte){\r\n\t\t\t\tcal.setByte( 1, ((Byte)val).byteValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Short){\r\n\t\t\t\tcal.setShort( 1, ((Short)val).shortValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Integer){\r\n\t\t\t\tcal.setInt( 1, ((Integer)val).intValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Long){\r\n\t\t\t\tcal.setLong( 1, ((Long)val).longValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Float){\r\n\t\t\t\tcal.setFloat( 1, ((Float)val).floatValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Double){\r\n\t\t\t\tcal.setDouble( 1, ((Double)val).doubleValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof BigDecimal){\r\n\t\t\t\tcal.setBigDecimal( 1, (BigDecimal)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof byte[]){\r\n\t\t\t\tcal.setBytes( 1, (byte[])val );\r\n\t\t\t}\r\n\t\t\tcal.execute();\r\n        }\r\n\t\tcal.close();\r\n\t\tcheckValues( st, values, needTrim);\r\n\r\n        \r\n        st.execute(\"Delete From \"+ table);\r\n        Statement st2 = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs2 = st2.executeQuery(\"SELECT * From \" + table);\r\n        for(int i=0; i<values.length; i++){\r\n            rs2.moveToInsertRow();\r\n            Object val = values[i];\r\n            if(val == null){\r\n                rs2.updateNull( name );\r\n            }else\r\n            if(val instanceof Time){\r\n                rs2.updateTime( name, (Time)val );\r\n            }else\r\n            if(val instanceof Timestamp){\r\n                rs2.updateTimestamp( name, (Timestamp)val );\r\n            }else\r\n            if(val instanceof Date){\r\n                rs2.updateDate( name, (Date)val );\r\n            }else\r\n            if(val instanceof String){\r\n                rs2.updateString( name, (String)val );\r\n            }else\r\n            if(val instanceof Boolean){\r\n                rs2.updateBoolean( name, ((Boolean)val).booleanValue() );\r\n            }else\r\n            if(val instanceof Byte){\r\n                rs2.updateByte( name, ((Byte)val).byteValue() );\r\n            }else\r\n            if(val instanceof Short){\r\n                rs2.updateShort( name, ((Short)val).shortValue() );\r\n            }else\r\n            if(val instanceof Integer){\r\n                rs2.updateInt( name, ((Integer)val).intValue() );\r\n            }else\r\n            if(val instanceof Long){\r\n                rs2.updateLong( name, ((Long)val).longValue() );\r\n            }else\r\n            if(val instanceof Float){\r\n                rs2.updateFloat( name, ((Float)val).floatValue() );\r\n            }else\r\n            if(val instanceof Double){\r\n                rs2.updateDouble( name, ((Double)val).doubleValue() );\r\n            }else\r\n            if(val instanceof BigDecimal){\r\n                rs2.updateBigDecimal( name, (BigDecimal)val );\r\n            }else\r\n            if(val instanceof byte[]){\r\n                rs2.updateBytes( name, (byte[])val );\r\n            }\r\n            rs2.insertRow();\r\n        }\r\n        st2.close();\r\n        checkValues( st, values, needTrim);\r\n    }","startLine":94,"lastLine":96},{"locFile":"java+method:///smallsql/junit/TestOther/testManyColumns()","rawLines":"public void testManyColumns() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n        dropTable( con, \"ManyCols\" );\r\n\t\tStringBuffer buf = new StringBuffer(\"Create Table ManyCols(\");\r\n\t\tfor(int i=1; i<300; i++){\r\n\t\t\tif(i!=1)buf.append(',');\r\n\t\t\tbuf.append(\"column\").append(i).append(\" int\");\r\n\t\t}\r\n\t\tbuf.append(')');\r\n\t\t\r\n\t\tst.execute(buf.toString());\r\n\t\tcon.close();\r\n\t\tcon = AllTests.getConnection();\r\n\t\tst = con.createStatement();\r\n\t\tassertEquals(1,st.executeUpdate(\"Insert Into ManyCols(column260) Values(123456)\"));\r\n\t\tst.execute(\"Drop Table ManyCols\");\r\n\t}","startLine":12,"lastLine":14}],"window":3},{"content":"public void testOther() throws Exception{Connection con = AllTests.getConnection();Statement st = con.createStatement();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestStatement/testOther()","rawLines":"public void testOther() throws Exception{\r\n        //now we test all not implemented code\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        \r\n        //curently there are no known warnings\r\n        st.clearWarnings();\r\n        assertNull(st.getWarnings());\r\n        \r\n        //query execution does not need any time the time occur on next,\r\n        //but currently there is no time observer\r\n        st.setQueryTimeout(5);\r\n        assertEquals(\"QueryTimeout\", 5, st.getQueryTimeout() );\r\n        \r\n        st.setMaxFieldSize(100);\r\n        assertEquals(\"MaxFieldSize\", 100, st.getMaxFieldSize() );\r\n    }","startLine":0,"lastLine":3},{"locFile":"java+method:///smallsql/junit/TestResultSet/testOther()","rawLines":"public void testOther() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs = st.executeQuery(\"Select * From ResultSet\");\r\n        \r\n        assertEquals(st, rs.getStatement());\r\n        \r\n        //currently there are no known warnings\r\n        rs.clearWarnings();\r\n        assertNull(rs.getWarnings());\r\n        \r\n        rs.setFetchDirection(ResultSet.FETCH_FORWARD);\r\n        assertEquals( rs.getFetchDirection(), ResultSet.FETCH_FORWARD);\r\n\r\n        rs.setFetchDirection(ResultSet.FETCH_REVERSE);\r\n        assertEquals( rs.getFetchDirection(), ResultSet.FETCH_REVERSE);\r\n        \r\n        rs.setFetchSize(123);\r\n        assertEquals( rs.getFetchSize(), 123);\r\n    }","startLine":0,"lastLine":2}],"window":3},{"content":"}}while(true){","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/singleSelect()","rawLines":"/**\r\n     * A single SELECT of a UNION or only a simple single SELECT.\r\n     * @return\r\n     * @throws SQLException\r\n     */\r\n    private CommandSelect singleSelect() throws SQLException{\r\n        CommandSelect selCmd = new CommandSelect(con.log);\r\n\t\tSQLToken token;\r\n        // scan for prefix like DISTINCT, ALL and the TOP clause; sample: SELECT TOP 15 ...\r\nSwitch: while(true){\r\n\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.TOP:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tint maxRows = Integer.parseInt(token.getName(sql));\r\n\t\t\t\t\t\tselCmd.setMaxRows(maxRows);\r\n\t\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ALL:\r\n\t\t\t\t\tselCmd.setDistinct(false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.DISTINCT:\r\n\t\t\t\t\tselCmd.setDistinct(true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\tbreak Switch;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        while(true){\r\n            Expression column = expression(selCmd, 0);\r\n            selCmd.addColumnExpression( column );\r\n\r\n            token = nextToken();\r\n            if(token == null) return selCmd; // SELECT without FROM\r\n\r\n            boolean as = false;\r\n            if(token.value == SQLTokenizer.AS){\r\n                token = nextToken(MISSING_EXPRESSION);\r\n                as = true;\r\n            }\r\n\r\n            if(as || (!isKeyword(token))){\r\n            \tString alias = getIdentifier( token);\r\n                column.setAlias( alias );\r\n                token = nextToken();\r\n                if(token == null) return selCmd; // SELECT without FROM\r\n            }\r\n\r\n            switch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        break;\r\n                case SQLTokenizer.FROM:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        from(selCmd);\r\n                        return selCmd;\r\n\r\n                default:\r\n                        if(!isKeyword(token))\r\n                \t\t\tthrow createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.FROM} );\r\n                        previousToken();\r\n                        return selCmd;\r\n            }\r\n        }\r\n    }","startLine":30,"lastLine":33},{"locFile":"java+method:///smallsql/database/IndexScrollStatus/getRowOffset(boolean)","rawLines":"/**\r\n\t * Return the next rowOffset of this index. You need to call reset() before the first use. \r\n\t * @param next if true the next rowOffset else the previous rowOffset\r\n\t */\r\n\tfinal long getRowOffset( boolean scroll){\r\n\t\tif(longList != null){\r\n\t\t\tlong rowOffset = scroll ? \r\n\t\t\t\t\t\t\t\tlongList.getNext(longListEnum) : \r\n\t\t\t\t\t\t\t\tlongList.getPrevious(longListEnum);\r\n\t\t\tif(rowOffset < 0){\r\n\t\t\t\t// No more entries on this node\r\n\t\t\t\tlongList = null;\r\n\t\t\t}else{\r\n\t\t\t\treturn rowOffset;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\tIndexNodeScrollStatus status = (IndexNodeScrollStatus)nodeStack.peek();\r\n\t\t\tint level = status.level;\r\n\t\t\tif(!status.asc ^ scroll){\r\n\t\t\t\t//ASC order\r\n\t\t\t\tint idx = ++status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t\tidx = ++status.idx;\r\n\t\t\t\t}\r\n\t\t\t\tif(idx >= status.nodes.length){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n                        status.idx = status.nodes.length; //to prevent problems with scroll back after multiple calls after the end.\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}else{\r\n\t\t\t\t//DESC order\r\n\t\t\t\tint idx = --status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t}\r\n\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}\r\n\t\t}\r\n\t}","startLine":14,"lastLine":16}],"window":3},{"content":"}else{previousToken();}","cloneLocs":[{"locFile":"java+method:///smallsql/database/SQLParser/nextIdentiferPart(java.lang.String)","rawLines":"/**\r\n     * Check if the identifier is a 2 part name with a point in the middle like FIRST.SECOND\r\n     * @param name the name of the first part\r\n     * @return the second part if exist else returns the first part\r\n     * @throws SQLException \r\n     */\r\n    private String nextIdentiferPart(String name) throws SQLException{\r\n        SQLToken token = nextToken();\r\n        //check if the object name include a database name\r\n        if(token != null && token.value == SQLTokenizer.POINT){\r\n            return nextIdentifier();\r\n        }else{\r\n            previousToken();\r\n        }\r\n        return name;\r\n    }","startLine":11,"lastLine":13},{"locFile":"java+method:///smallsql/database/SQLParser/expressionSingle(smallsql.database.Command,smallsql.database.SQLToken)","rawLines":"/**\r\n     * This method parse a single expression like 12, 'qwert', 0x3F or a column name.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     */\r\n    private Expression expressionSingle(Command cmd, SQLToken token) throws SQLException{\r\n        boolean isMinus = false;\r\n        if(token != null){\r\n            switch(token.value){\r\n                case SQLTokenizer.NULL:\r\n                        return new ExpressionValue( null, SQLTokenizer.NULL );\r\n                case SQLTokenizer.STRING:\r\n                        return new ExpressionValue( token.getName(null), SQLTokenizer.VARCHAR );\r\n                case SQLTokenizer.IDENTIFIER:\r\n                        {\r\n                        String name = getIdentifier( token );\r\n                        ExpressionName expr =  new ExpressionName( name );\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                            expr.setNameAfterTableAlias( nextIdentifier() );\r\n                        }else{\r\n                            previousToken();\r\n                        }\r\n                        return expr;\r\n                        }\r\n                case SQLTokenizer.TRUE:\r\n                        return new ExpressionValue( Boolean.TRUE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.FALSE:\r\n                        return new ExpressionValue( Boolean.FALSE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.ESCAPE_L:{\r\n                        token = nextToken(COMMANDS_ESCAPE);\r\n                        SQLToken para = nextToken(MISSING_EXPRESSION);\r\n                        Expression expr;\r\n                        switch(token.value){\r\n                            case SQLTokenizer.D: // date escape sequence\r\n                            \texpr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.DATE), SQLTokenizer.DATE );\r\n                            \tbreak;\r\n                            case SQLTokenizer.T: // time escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIME), SQLTokenizer.TIME );\r\n                            \tbreak;\r\n                            case SQLTokenizer.TS: // timestamp escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP );\r\n                            \tbreak;\r\n                            case SQLTokenizer.FN: // function escape sequence\r\n                            \tnextToken(MISSING_PARENTHESIS_L);\r\n                            \texpr = function(cmd, para, true);\r\n                            \tbreak;\r\n                            case SQLTokenizer.CALL: // call escape sequence\r\n                                throw new java.lang.UnsupportedOperationException(\"call escape sequence\");\r\n                            default: throw new Error();\r\n                        }\r\n                        token = nextToken( ESCAPE_MISSING_CLOSE );\r\n                        return expr;\r\n                }\r\n                case SQLTokenizer.QUESTION:\r\n                        ExpressionValue param = new ExpressionValue();\r\n                        cmd.addParameter( param );\r\n                        return param;\r\n                case SQLTokenizer.CASE:\r\n                \t\treturn caseExpr(cmd);\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.PLUS:\r\n                        // sign detection\r\n                        do{\r\n                            if(token.value == SQLTokenizer.MINUS)\r\n                                    isMinus = !isMinus;\r\n                            token = nextToken();\r\n                            if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        }while(token.value == SQLTokenizer.MINUS || token.value == SQLTokenizer.PLUS);\r\n                        // no Break\r\n                default:\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.PARENTHESIS_L){\r\n                            if(isMinus)\r\n                                return new ExpressionArithmetic( function( cmd, token, false ),  ExpressionArithmetic.NEGATIVE );\r\n                            return function( cmd, token, false );\r\n                        }else{\r\n                            // constant expression or identifier\r\n                            char chr1 = sql[ token.offset ];\r\n\t\t\t\t\t\t\tif(chr1 == '$'){\r\n\t\t\t\t\t\t\t\tpreviousToken();\r\n\t                            String tok = new String(sql, token.offset+1, token.length-1);\r\n                                if(isMinus) tok = \"-\" + tok;\r\n\t\t\t\t\t\t\t\treturn new ExpressionValue( new Money(Double.parseDouble(tok)), SQLTokenizer.MONEY );\r\n\t\t\t\t\t\t\t}\r\n                            String tok = new String(sql, token.offset, token.length);\r\n                            if((chr1 >= '0' && '9' >= chr1) || chr1 == '.'){\r\n                                previousToken();\r\n                                // first character is a digit\r\n                                if(token.length>1 && (sql[ token.offset +1 ] | 0x20) == 'x'){\r\n                                    // binary data as hex\r\n                                    if(isMinus) {\r\n                \t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_OPER_MINUS);\r\n                                    }\r\n                                    return new ExpressionValue( Utils.hex2bytes( sql, token.offset+2, token.length-2), SQLTokenizer.VARBINARY );\r\n                                }\r\n                                if(isMinus) tok = \"-\" + tok;\r\n                                if(Utils.indexOf( '.', sql, token.offset, token.length ) >= 0 ||\r\n                                   Utils.indexOf( 'e', sql, token.offset, token.length ) >= 0){\r\n                                    return new ExpressionValue( new Double(tok), SQLTokenizer.DOUBLE );\r\n                                }else{\r\n                                    try{\r\n                                        return new ExpressionValue( new Integer(tok), SQLTokenizer.INT );\r\n                                    }catch(NumberFormatException e){\r\n                                        return new ExpressionValue( new Long(tok), SQLTokenizer.BIGINT );\r\n                                    }\r\n                                }\r\n                            }else{\r\n                                // identifier\r\n                                checkValidIdentifier( tok, token );\r\n                                ExpressionName expr = new ExpressionName(tok);\r\n                                if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                                    expr.setNameAfterTableAlias( nextIdentifier() );\r\n                                }else{\r\n                                    previousToken();\r\n                                }\r\n                                if(isMinus)\r\n                                    return new ExpressionArithmetic( expr,  ExpressionArithmetic.NEGATIVE );\r\n                                return expr;\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return null;\r\n    }","startLine":113,"lastLine":115},{"locFile":"java+method:///smallsql/database/SQLParser/expressionSingle(smallsql.database.Command,smallsql.database.SQLToken)","rawLines":"/**\r\n     * This method parse a single expression like 12, 'qwert', 0x3F or a column name.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     */\r\n    private Expression expressionSingle(Command cmd, SQLToken token) throws SQLException{\r\n        boolean isMinus = false;\r\n        if(token != null){\r\n            switch(token.value){\r\n                case SQLTokenizer.NULL:\r\n                        return new ExpressionValue( null, SQLTokenizer.NULL );\r\n                case SQLTokenizer.STRING:\r\n                        return new ExpressionValue( token.getName(null), SQLTokenizer.VARCHAR );\r\n                case SQLTokenizer.IDENTIFIER:\r\n                        {\r\n                        String name = getIdentifier( token );\r\n                        ExpressionName expr =  new ExpressionName( name );\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                            expr.setNameAfterTableAlias( nextIdentifier() );\r\n                        }else{\r\n                            previousToken();\r\n                        }\r\n                        return expr;\r\n                        }\r\n                case SQLTokenizer.TRUE:\r\n                        return new ExpressionValue( Boolean.TRUE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.FALSE:\r\n                        return new ExpressionValue( Boolean.FALSE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.ESCAPE_L:{\r\n                        token = nextToken(COMMANDS_ESCAPE);\r\n                        SQLToken para = nextToken(MISSING_EXPRESSION);\r\n                        Expression expr;\r\n                        switch(token.value){\r\n                            case SQLTokenizer.D: // date escape sequence\r\n                            \texpr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.DATE), SQLTokenizer.DATE );\r\n                            \tbreak;\r\n                            case SQLTokenizer.T: // time escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIME), SQLTokenizer.TIME );\r\n                            \tbreak;\r\n                            case SQLTokenizer.TS: // timestamp escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP );\r\n                            \tbreak;\r\n                            case SQLTokenizer.FN: // function escape sequence\r\n                            \tnextToken(MISSING_PARENTHESIS_L);\r\n                            \texpr = function(cmd, para, true);\r\n                            \tbreak;\r\n                            case SQLTokenizer.CALL: // call escape sequence\r\n                                throw new java.lang.UnsupportedOperationException(\"call escape sequence\");\r\n                            default: throw new Error();\r\n                        }\r\n                        token = nextToken( ESCAPE_MISSING_CLOSE );\r\n                        return expr;\r\n                }\r\n                case SQLTokenizer.QUESTION:\r\n                        ExpressionValue param = new ExpressionValue();\r\n                        cmd.addParameter( param );\r\n                        return param;\r\n                case SQLTokenizer.CASE:\r\n                \t\treturn caseExpr(cmd);\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.PLUS:\r\n                        // sign detection\r\n                        do{\r\n                            if(token.value == SQLTokenizer.MINUS)\r\n                                    isMinus = !isMinus;\r\n                            token = nextToken();\r\n                            if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        }while(token.value == SQLTokenizer.MINUS || token.value == SQLTokenizer.PLUS);\r\n                        // no Break\r\n                default:\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.PARENTHESIS_L){\r\n                            if(isMinus)\r\n                                return new ExpressionArithmetic( function( cmd, token, false ),  ExpressionArithmetic.NEGATIVE );\r\n                            return function( cmd, token, false );\r\n                        }else{\r\n                            // constant expression or identifier\r\n                            char chr1 = sql[ token.offset ];\r\n\t\t\t\t\t\t\tif(chr1 == '$'){\r\n\t\t\t\t\t\t\t\tpreviousToken();\r\n\t                            String tok = new String(sql, token.offset+1, token.length-1);\r\n                                if(isMinus) tok = \"-\" + tok;\r\n\t\t\t\t\t\t\t\treturn new ExpressionValue( new Money(Double.parseDouble(tok)), SQLTokenizer.MONEY );\r\n\t\t\t\t\t\t\t}\r\n                            String tok = new String(sql, token.offset, token.length);\r\n                            if((chr1 >= '0' && '9' >= chr1) || chr1 == '.'){\r\n                                previousToken();\r\n                                // first character is a digit\r\n                                if(token.length>1 && (sql[ token.offset +1 ] | 0x20) == 'x'){\r\n                                    // binary data as hex\r\n                                    if(isMinus) {\r\n                \t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_OPER_MINUS);\r\n                                    }\r\n                                    return new ExpressionValue( Utils.hex2bytes( sql, token.offset+2, token.length-2), SQLTokenizer.VARBINARY );\r\n                                }\r\n                                if(isMinus) tok = \"-\" + tok;\r\n                                if(Utils.indexOf( '.', sql, token.offset, token.length ) >= 0 ||\r\n                                   Utils.indexOf( 'e', sql, token.offset, token.length ) >= 0){\r\n                                    return new ExpressionValue( new Double(tok), SQLTokenizer.DOUBLE );\r\n                                }else{\r\n                                    try{\r\n                                        return new ExpressionValue( new Integer(tok), SQLTokenizer.INT );\r\n                                    }catch(NumberFormatException e){\r\n                                        return new ExpressionValue( new Long(tok), SQLTokenizer.BIGINT );\r\n                                    }\r\n                                }\r\n                            }else{\r\n                                // identifier\r\n                                checkValidIdentifier( tok, token );\r\n                                ExpressionName expr = new ExpressionName(tok);\r\n                                if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                                    expr.setNameAfterTableAlias( nextIdentifier() );\r\n                                }else{\r\n                                    previousToken();\r\n                                }\r\n                                if(isMinus)\r\n                                    return new ExpressionArithmetic( expr,  ExpressionArithmetic.NEGATIVE );\r\n                                return expr;\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return null;\r\n    }","startLine":20,"lastLine":22},{"locFile":"java+method:///smallsql/database/SQLParser/index(smallsql.database.Command,int,java.lang.String,java.lang.String,java.lang.String)","rawLines":"/**\r\n\t * Parse construct like:<br>\r\n\t * <li>PRIMARY KEY (col1)\r\n\t * <li>UNIQUE (col1, col2)\r\n\t * <li>FOREIGN KEY REFERENCES ref_table(col1)\r\n\t * @param cmd\r\n\t * @param constraintType one of SQLTokenizer.PRIMARY, SQLTokenizer.UNIQUE or SQLTokenizer.FOREIGN.\r\n\t * @param if it a constrain of the current column else null\r\n\t * @return a new IndexDescription\r\n\t */\r\n\tprivate IndexDescription index(Command cmd, int constraintType, String tableName, String contrainName, String columnName) throws SQLException{\r\n\t\tif(constraintType != SQLTokenizer.UNIQUE) nextToken( MISSING_KEY );\r\n\t\tSQLToken token = nextToken();\r\n        if(token != null){\r\n    \t\tswitch(token.value){\r\n    \t\t\tcase SQLTokenizer.CLUSTERED:\r\n    \t\t\tcase SQLTokenizer.NONCLUSTERED:\r\n    \t\t\t\t// ignoring, this tokens form MS SQL Server are ignored\r\n    \t\t\t\tbreak;\r\n                default:\r\n                    previousToken();\r\n    \t\t}\r\n        }else{\r\n            previousToken();\r\n        }\r\n\t\tStrings columns = new Strings();\r\n\t\tExpressions expressions = new Expressions();\r\n\t\tif(columnName != null){\r\n\t\t\t//Constraint for a single column together with the column definition\r\n\t\t\tcolumns.add(columnName);\r\n\t\t\texpressions.add(new ExpressionName(columnName));\r\n\t\t}else{\r\n\t\t\t//Constraint as addition definition\r\n            expressionDefList( cmd, expressions, columns );\r\n\t\t}\r\n\t\treturn new IndexDescription( contrainName, tableName, constraintType, expressions, columns);\r\n\t}","startLine":22,"lastLine":24},{"locFile":"java+method:///smallsql/database/SQLParser/tableSource(smallsql.database.Command,smallsql.database.DataSources)","rawLines":"/**\r\n     * read a table or view name in a FROM clause. If the keyword AS exists then read it also the alias\r\n     */\r\n    private RowSource tableSource( Command cmd, DataSources tables) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        switch(token.value){\r\n            case SQLTokenizer.PARENTHESIS_L: // (\r\n                    return rowSource( cmd, tables, SQLTokenizer.PARENTHESIS_R );\r\n            case SQLTokenizer.ESCAPE_L: // {\r\n                    token = nextToken(MISSING_OJ);\r\n                    return rowSource( cmd, tables, SQLTokenizer.ESCAPE_R );\r\n            case SQLTokenizer.SELECT:\r\n            \t\t// inner select\r\n            \t\tViewResult viewResult = new ViewResult( con, select() );\r\n            \t\ttables.add(viewResult);\r\n            \t\treturn viewResult;\r\n        }\r\n        String catalog = null;\r\n        String name = getIdentifier( token );\r\n\t\ttoken = nextToken();\r\n\t\t//check if the table name include a database name\r\n\t\tif(token != null && token.value == SQLTokenizer.POINT){\r\n\t\t\tcatalog = name;\r\n\t\t\tname = nextIdentifier();\r\n\t\t\ttoken = nextToken();\r\n\t\t}\r\n\t\t//TableResult table = new TableResult();\r\n\t\t//table.setName( catalog, name );\r\n\t\tTableView tableView = Database.getTableView( con, catalog, name);\r\n\t\tTableViewResult table = TableViewResult.createResult(tableView);\r\n        tables.add( table );\r\n\r\n        if(token != null && token.value == SQLTokenizer.AS){\r\n            // skip AS keyword, if exists\r\n            token = nextToken(MISSING_EXPRESSION);\r\n            table.setAlias( token.getName( sql ) );\r\n        }else{\r\n            previousToken();\r\n        }\r\n        return table;\r\n    }","startLine":36,"lastLine":38}],"window":3},{"content":"buf.append('-');formatNumber( details.year, 4, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":89,"lastLine":91},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":158,"lastLine":160}],"window":3},{"content":"buf.append('/');formatNumber( details.year, 4, buf);return buf.toString();","cloneLocs":[{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":61,"lastLine":63},{"locFile":"java+method:///smallsql/database/DateTime/toString(int)","rawLines":"/**\r\n\t * @param style a value like the syle of CONVERT function from MS SQL Server.\r\n\t */\r\n\tString toString(int style){\r\n\t\tif(style < 0)\r\n\t\t\treturn toString();\r\n\t\tDetails details = new Details(time);\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tswitch(style){\r\n\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 8: //hh:mm:ss\r\n\t\t\tcase 108:\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 112: // ISO yyyymmdd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 13:\r\n\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 14:\r\n\t\t\tcase 114: // hh:mi:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tdefault:\r\n\t\t\t\treturn toString();\r\n\t\t}\r\n\t\t\r\n\t}","startLine":33,"lastLine":35}],"window":3},{"content":"try{PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );long time = -System.currentTimeMillis();","cloneLocs":[{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepareBatch(java.sql.Connection)","rawLines":"/**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":10,"lastLine":12},{"locFile":"java+method:///smallsql/junit/BenchTest/test_UpdateRowsPrepare(java.sql.Connection)","rawLines":"/**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }","startLine":7,"lastLine":9}],"window":3},{"content":"switch(operation){case IN:case EQUALS_NULL:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":25,"lastLine":27},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":106,"lastLine":108},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":36,"lastLine":38},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":72,"lastLine":74},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":56,"lastLine":58},{"locFile":"java+method:///smallsql/database/ExpressionArithmetic/getBoolean()","rawLines":"boolean getBoolean() throws java.lang.Exception {\r\n        switch(operation){\r\n        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;\r\n        }\r\n        final boolean leftIsNull = left.isNull();\r\n        int dataType;\r\n        if(operation == NEGATIVE || operation == BIT_NOT){\r\n        \tif(leftIsNull) return false;\r\n        \tdataType = left.getDataType();\r\n        }else{\r\n            final boolean rightIsNull = right.isNull();\r\n        \tif(operation == EQUALS_NULL && leftIsNull && rightIsNull) return true;\r\n        \tif(leftIsNull || rightIsNull) return false;\r\n        \tdataType = getDataType(left, right);\r\n        }\r\n        switch(dataType){\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return left.getBoolean() == right.getBoolean();\r\n\t\t\t\t\t\tcase UNEQUALS:  return left.getBoolean() != right.getBoolean();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//break; interpret it as BIT \r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIT:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;\r\n                    }\r\n            case SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;\r\n                    }\r\n            case SQLTokenizer.REAL:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;\r\n                    }\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;\r\n                    }\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;\r\n                    }\r\n            case SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:{\r\n\t\t\t\t\tif(operation == NEGATIVE)\r\n\t\t\t\t\t\treturn left.getNumeric().getSignum() != 0;\r\n\t\t\t\t\tint comp = left.getNumeric().compareTo( right.getNumeric() );\r\n\t\t\t\t\tswitch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.CLOB:{\r\n                    final String leftStr = left.getString();\r\n                    final String rightStr = right.getString();\r\n                    int comp = String.CASE_INSENSITIVE_ORDER.compare( leftStr, rightStr );\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);\r\n                    }\r\n                    break;}\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:{\r\n                    byte[] leftBytes = left.getBytes();\r\n                    byte[] rightBytes= right.getBytes();\r\n                    int comp = Utils.compareBytes( leftBytes, rightBytes);\r\n                    switch(operation){\r\n\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );\r\n                    }\r\n                    break;}\r\n        }\r\n        throw createUnspportedDataType();\r\n    }","startLine":89,"lastLine":91}],"window":3},{"content":"value = newValue;break;case SQLTokenizer.MONEY:","cloneLocs":[{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":86,"lastLine":88},{"locFile":"java+method:///smallsql/database/ExpressionValue/accumulate(smallsql.database.Expression)","rawLines":"/*==============================================================================\r\nmethods for Grouping\r\n==============================================================================*/\r\n\t/**\r\n\t * Accumulate the value of the expression to this aggregate function value. \r\n\t */\r\n    void accumulate(Expression expr) throws Exception{\r\n\t\tint type = getType();\r\n\t\tif(type != GROUP_BY) expr = expr.getParams()[0];\r\n\t\tswitch(type){\r\n\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();\r\n\t\t}\r\n\t}","startLine":143,"lastLine":145}],"window":3},{"content":"}else{switch(expr.getDataType()){case SQLTokenizer.REAL:","cloneLocs":[{"locFile":"java+method:///smallsql/database/Index/findRows(smallsql.database.IndexNode,smallsql.database.Expression,boolean,java.util.ArrayList)","rawLines":"/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}","startLine":19,"lastLine":21},{"locFile":"java+method:///smallsql/database/Index/addValues(long,smallsql.database.Expressions)","rawLines":"/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","startLine":13,"lastLine":15}],"window":3},{"content":"for(int i=1; i<=3; i++){ResultSet rs = pr.executeQuery( );assertTrue  ( \"loop:\"+i, rs.next());","cloneLocs":[{"locFile":"java+method:///smallsql/junit/TestGroupBy/testCountOrderBy()","rawLines":"public void testCountOrderBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tPreparedStatement pr = con.prepareStatement(\"Select count(*) FROM \" + table1 + \" Group By name Order By name DESC\");\r\n\t\tfor(int i=1; i<=3; i++){\r\n\t\t\tResultSet rs = pr.executeQuery( );\r\n\t\t\tassertTrue  ( \"loop:\"+i, rs.next());\r\n\t\t\tassertEquals( \"loop:\"+i, 1, rs.getInt(1));\r\n\t\t\tassertTrue  ( \"loop:\"+i, rs.next());\r\n\t\t\tassertEquals( \"loop:\"+i, 3, rs.getInt(1));\r\n\t\t}\r\n\t}","startLine":4,"lastLine":6},{"locFile":"java+method:///smallsql/junit/TestGroupBy/testGroupByWithExpression()","rawLines":"public void testGroupByWithExpression() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tPreparedStatement pr = con.prepareStatement(\"Select sum(id), name+'a' as ColumnName FROM \" + table1 + \" Group By name+'a' Order By Name+'a'\");\r\n\t\tfor(int i=1; i<=3; i++){\r\n\t\t\tResultSet rs = pr.executeQuery( );\r\n\t\t\tassertTrue  ( \"loop:\"+i, rs.next());\r\n\t\t\tassertEquals( \"loop:\"+i, 3, rs.getInt(1));\r\n\t\t\tassertTrue  ( \"loop:\"+i, rs.next());\r\n\t\t\tassertEquals( \"loop:\"+i, 1, rs.getInt(1));\r\n\t\t\tassertEquals( \"loop:\"+i+\" Alias name von Expression\", \"ColumnName\", rs.getMetaData().getColumnName(2));\r\n\t\t}\r\n\t}","startLine":4,"lastLine":6},{"locFile":"java+method:///smallsql/junit/TestGroupBy/testComplex()","rawLines":"public void testComplex() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tPreparedStatement pr = con.prepareStatement(\"Select abs(sum(abs(3-id))+2) FROM \" + table1 + \" Group By name+'a' Order By 'b'+(Name+'a')\");\r\n\t\tfor(int i=1; i<=3; i++){\r\n\t\t\tResultSet rs = pr.executeQuery( );\r\n\t\t\tassertTrue  ( \"loop:\"+i, rs.next());\r\n\t\t\tassertEquals( \"loop:\"+i, 5, rs.getInt(1));\r\n\t\t\tassertTrue  ( \"loop:\"+i, rs.next());\r\n\t\t\tassertEquals( \"loop:\"+i, 4, rs.getInt(1));\r\n\t\t}\r\n\t}","startLine":4,"lastLine":6}],"window":3}]